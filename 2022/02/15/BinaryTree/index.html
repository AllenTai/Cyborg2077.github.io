<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>二叉树 | Kyle's Blog</title><meta name="keywords" content="算法训练,二叉树"><meta name="author" content="Kyle Violet"><meta name="copyright" content="Kyle Violet"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二叉树相关习题的题解 题目来源：力扣（Leetcode）">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="https://cyborg2077.github.io/2022/02/15/BinaryTree/index.html">
<meta property="og:site_name" content="Kyle&#39;s Blog">
<meta property="og:description" content="二叉树相关习题的题解 题目来源：力扣（Leetcode）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=781630402,3569603339&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281">
<meta property="article:published_time" content="2022-02-15T08:41:32.000Z">
<meta property="article:modified_time" content="2022-05-16T02:53:02.667Z">
<meta property="article:author" content="Kyle Violet">
<meta property="article:tag" content="算法训练">
<meta property="article:tag" content="二叉树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=781630402,3569603339&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cyborg2077.github.io/2022/02/15/BinaryTree/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f8440b73b5064587c92bcc0ec23ce01c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-RQZSMGWCQS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-RQZSMGWCQS');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-16 10:53:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3049706_ndj6cftvaf9.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-artitalk-pro/lib/card.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.css"><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.15/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/18/fj4XvrdM5o62hbA.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw iconfont icon-bilibili"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/04/15/bZMPtkVepfK6uJI.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kyle's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyan"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw iconfont icon-bilibili"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-15T08:41:32.000Z" title="发表于 2022-02-15 16:41:32">2022-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-16T02:53:02.667Z" title="更新于 2022-05-16 10:53:02">2022-05-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8A%9B%E6%89%A3/">力扣</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="leetcode-calendar-wall" style="background:#313d4b;">
    <div class="leetcode-tips-container">
    </div>
    <div class="leetcode-top-part">
      <canvas id="leetcode-sub-calendar" style="width: 100%;z-index: 99;" stamp-param={"1641772800":8,"1641859200":36,"1641945600":20,"1642032000":13,"1642118400":5,"1642204800":12,"1642291200":7,"1642377600":14,"1642464000":4,"1642550400":10,"1642636800":16,"1642723200":5,"1642809600":24,"1642896000":7,"1642982400":25,"1643068800":11,"1644278400":2,"1644624000":2,"1644710400":9,"1644796800":4,"1644883200":16,"1644969600":28,"1645056000":2,"1645660800":10,"1645747200":8,"1645833600":5,"1646006400":8,"1646179200":6,"1646265600":12,"1646352000":3,"1646438400":1,"1646524800":10,"1646611200":6,"1646697600":6,"1646784000":20,"1646870400":6,"1646956800":5,"1647043200":6,"1647129600":26,"1647216000":1,"1647648000":8,"1647734400":4,"1647820800":7,"1647907200":3,"1647993600":13,"1648080000":12,"1648684800":18,"1648771200":19,"1648857600":4,"1649030400":5,"1649116800":14,"1649203200":1,"1649289600":6,"1649376000":3,"1649462400":1,"1651449600":8,"1651536000":3,"1651622400":5,"1651708800":14,"1651795200":8,"1651881600":9,"1651968000":11,"1652054400":20,"1652140800":13,"1652227200":13,"1652659200":11,"1652832000":8,"1653004800":7,"1653091200":4}>
      </canvas>
      <div class="leetcode-contri-footer">
      <div class="datasource">数据来源<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/cyborg2077">@cyborg2077</a></div>
      <svg width="120px" height="35px" style="flex:1; display: block;" viewBox="0 0 458 111" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <!-- Generator: Sketch 49.1 (51147) - http://www.bohemiancoding.com/sketch -->
        <title>logo_english_dark</title>
        <desc>Created with Sketch.</desc>
        <defs></defs>
        <g id="LeetCode’s-new-logo" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g transform="translate(-812.000000, -3714.000000)" id="logo_english_dark">
                <g transform="translate(812.000000, 3714.000000)">
                    <g id="Logo_English">
                        <g id="Group-10">
                            <path d="M67.5068339,83.0664138 C70.0005384,80.5763786 74.0371402,80.5828822 76.5228362,83.0809398 C79.0085322,85.5789975 79.00204,89.6226456 76.5083355,92.1126808 L65.4351451,103.169577 C55.2192332,113.370744 38.5604663,113.518673 28.1722578,103.513204 C28.112217,103.455678 23.486583,98.9201326 8.22702585,83.9570195 C-1.92478479,74.0028895 -2.93614945,58.0748736 6.61697549,47.8463644 L24.4286944,28.7745461 C33.9100043,18.6218594 51.3874487,17.5122246 62.2279907,26.2789232 L78.4052912,39.3620235 C81.1448956,41.5776292 81.5728103,45.5984975 79.3610655,48.3428842 C77.1493207,51.0872709 73.1354592,51.5159327 70.3958548,49.300327 L54.2186634,36.2173149 C48.5492813,31.6325105 38.631911,32.2621597 33.7398535,37.5006265 L15.9279056,56.5726899 C11.2772073,61.552182 11.7865613,69.5740156 17.1461283,74.8292186 C28.3515339,85.8169393 36.9874071,94.2846214 36.9973988,94.294225 C42.3981571,99.4959838 51.130862,99.418438 56.43358,94.1233737 L67.5068339,83.0664138 Z" id="Combined-Shape" fill="#FFA116" fill-rule="nonzero"></path>
                            <path d="M40.6069914,72.0014117 C37.086019,72.0014117 34.2317068,69.142117 34.2317068,65.6149982 C34.2317068,62.0878794 37.086019,59.2285847 40.6069914,59.2285847 L87.6247154,59.2285847 C91.1456879,59.2285847 94,62.0878794 94,65.6149982 C94,69.142117 91.1456879,72.0014117 87.6247154,72.0014117 L40.6069914,72.0014117 Z" id="Path-2" fill="#B3B3B3"></path>
                            <path d="M49.4124315,2.02335002 C51.8178981,-0.552320454 55.852269,-0.686893945 58.4234511,1.72277172 C60.9946333,4.13243738 61.1289722,8.17385083 58.7235056,10.7495213 L15.9282277,56.5728697 C11.2773659,61.551984 11.7867168,69.5737689 17.1459309,74.8291832 L36.9094236,94.2091099 C39.4255514,96.6764051 39.4686234,100.719828 37.0056277,103.240348 C34.5426319,105.760868 30.5062548,105.804016 27.990127,103.33672 L8.22654289,83.9567041 C-1.92467414,74.0021005 -2.93603527,58.0741402 6.61751533,47.846311 L49.4124315,2.02335002 Z" id="Stroke-3" fill="#000000"></path>
                        </g>
                        <path d="M131.914062,38.8828125 L131.914062,80.9140625 C131.914062,82.5286539 132.486973,83.9088484 133.632812,85.0546875 C134.778652,86.2005266 136.158846,86.7734375 137.773438,86.7734375 L149.140625,86.7734375 C150.130213,86.7734375 150.976559,87.1249965 151.679688,87.828125 C152.382816,88.5312535 152.734375,89.3775992 152.734375,90.3671875 L152.734375,90.4453125 C152.734375,91.4349008 152.382816,92.2682258 151.679688,92.9453125 C150.976559,93.648441 150.130213,94 149.140625,94 L137.773438,94 C134.153628,94 131.067721,92.7239711 128.515625,90.171875 C125.963529,87.6197789 124.6875,84.5338723 124.6875,80.9140625 L124.6875,38.8828125 C124.6875,37.8932242 125.039059,37.0468785 125.742188,36.34375 C126.445316,35.6666633 127.278641,35.328125 128.242188,35.328125 L128.359375,35.328125 C129.322921,35.328125 130.156246,35.6666633 130.859375,36.34375 C131.562504,37.0468785 131.914062,37.8932242 131.914062,38.8828125 Z M177.1875,58.6484375 C173.28123,58.6484375 169.94793,60.028632 167.1875,62.7890625 C164.453111,65.549493 163.085938,68.882793 163.085938,72.7890625 C163.085938,73.492191 163.13802,74.1822883 163.242188,74.859375 L187.96875,63.6875 C185.156236,60.3281082 181.562522,58.6484375 177.1875,58.6484375 Z M196.5625,63.8046875 C196.979169,64.6901086 197.018231,65.6015578 196.679688,66.5390625 C196.341144,67.4505254 195.71615,68.1145812 194.804688,68.53125 C191.158836,70.1718832 186.367217,72.3333199 180.429688,75.015625 C173.059859,78.348975 168.281261,80.5104117 166.09375,81.5 C168.906264,85.093768 172.604144,86.890625 177.1875,86.890625 C180.23439,86.890625 182.994779,85.9921965 185.46875,84.1953125 C187.864595,82.4505121 189.544266,80.1849098 190.507812,77.3984375 C191.080732,75.7838461 192.226554,74.9765625 193.945312,74.9765625 C195.169277,74.9765625 196.14583,75.4843699 196.875,76.5 C197.578129,77.4895883 197.721356,78.5703066 197.304688,79.7421875 C195.846347,83.9609586 193.294289,87.3723828 189.648438,89.9765625 C185.924461,92.6588676 181.770856,94 177.1875,94 C171.302054,94 166.276063,91.9166875 162.109375,87.75 C157.942687,83.5833125 155.859375,78.5573211 155.859375,72.671875 C155.859375,66.7864289 157.942687,61.7604375 162.109375,57.59375 C166.276063,53.4270625 171.302054,51.34375 177.1875,51.34375 C181.432313,51.34375 185.312482,52.5025926 188.828125,54.8203125 C192.291684,57.0859488 194.869783,60.0807105 196.5625,63.8046875 Z M224.726562,58.6484375 C220.820293,58.6484375 217.486993,60.028632 214.726562,62.7890625 C211.992174,65.549493 210.625,68.882793 210.625,72.7890625 C210.625,73.492191 210.677083,74.1822883 210.78125,74.859375 L235.507812,63.6875 C232.695298,60.3281082 229.101584,58.6484375 224.726562,58.6484375 Z M244.101562,63.8046875 C244.518231,64.6901086 244.557293,65.6015578 244.21875,66.5390625 C243.880207,67.4505254 243.255213,68.1145812 242.34375,68.53125 C238.697898,70.1718832 233.90628,72.3333199 227.96875,75.015625 C220.598921,78.348975 215.820323,80.5104117 213.632812,81.5 C216.445327,85.093768 220.143206,86.890625 224.726562,86.890625 C227.773453,86.890625 230.533842,85.9921965 233.007812,84.1953125 C235.403658,82.4505121 237.083329,80.1849098 238.046875,77.3984375 C238.619795,75.7838461 239.765616,74.9765625 241.484375,74.9765625 C242.708339,74.9765625 243.684892,75.4843699 244.414062,76.5 C245.117191,77.4895883 245.260419,78.5703066 244.84375,79.7421875 C243.385409,83.9609586 240.833352,87.3723828 237.1875,89.9765625 C233.463523,92.6588676 229.309919,94 224.726562,94 C218.841116,94 213.815125,91.9166875 209.648438,87.75 C205.48175,83.5833125 203.398438,78.5573211 203.398438,72.671875 C203.398438,66.7864289 205.48175,61.7604375 209.648438,57.59375 C213.815125,53.4270625 218.841116,51.34375 224.726562,51.34375 C228.971375,51.34375 232.851545,52.5025926 236.367188,54.8203125 C239.830746,57.0859488 242.408846,60.0807105 244.101562,63.8046875 Z M255.78125,35.328125 C256.744796,35.328125 257.578121,35.6666633 258.28125,36.34375 C258.984379,37.0468785 259.335938,37.8932242 259.335938,38.8828125 L259.335938,51.34375 L266.367188,51.34375 C267.330734,51.34375 268.164059,51.695309 268.867188,52.3984375 C269.570316,53.101566 269.921875,53.9479117 269.921875,54.9375 L269.921875,55.015625 C269.921875,56.0052133 269.570316,56.8385383 268.867188,57.515625 C268.164059,58.2187535 267.330734,58.5703125 266.367188,58.5703125 L259.335938,58.5703125 L259.335938,82.90625 C259.335938,83.9739637 259.713538,84.8854129 260.46875,85.640625 C261.223962,86.3958371 262.148432,86.7734375 263.242188,86.7734375 L266.367188,86.7734375 C267.330734,86.7734375 268.164059,87.1249965 268.867188,87.828125 C269.570316,88.5312535 269.921875,89.3775992 269.921875,90.3671875 L269.921875,90.4453125 C269.921875,91.4349008 269.570316,92.2682258 268.867188,92.9453125 C268.164059,93.648441 267.330734,94 266.367188,94 L263.242188,94 C260.169255,94 257.539073,92.9192816 255.351563,90.7578125 C253.190093,88.5703016 252.109375,85.9531402 252.109375,82.90625 L252.109375,38.8828125 C252.109375,37.8932242 252.460934,37.0468785 253.164063,36.34375 C253.867191,35.6666633 254.700516,35.328125 255.664063,35.328125 L255.78125,35.328125 Z M303.75,35.328125 C306.223971,35.328125 308.658842,35.6276012 311.054688,36.2265625 C312.851571,36.6953148 313.75,37.8411367 313.75,39.6640625 L313.75,39.78125 C313.75,40.9270891 313.281255,41.8645797 312.34375,42.59375 C311.432287,43.2968785 310.416672,43.5052098 309.296875,43.21875 C307.473949,42.7499977 305.625009,42.515625 303.75,42.515625 C297.65622,42.515625 292.447938,44.6770617 288.125,49 C283.802062,53.3229383 281.640625,58.5442402 281.640625,64.6640625 C281.640625,70.7838848 283.802062,76.0051867 288.125,80.328125 C292.447938,84.6250215 297.65622,86.7734375 303.75,86.7734375 C305.625009,86.7734375 307.473949,86.5520855 309.296875,86.109375 C310.416672,85.8229152 311.432287,86.0312465 312.34375,86.734375 C313.281255,87.4375035 313.75,88.3749941 313.75,89.546875 L313.75,89.625 C313.75,91.4739676 312.851571,92.6328102 311.054688,93.1015625 C308.658842,93.7005238 306.223971,94 303.75,94 C295.651001,94 288.737008,91.1354453 283.007812,85.40625 C277.278617,79.6770547 274.414062,72.7630613 274.414062,64.6640625 C274.414062,56.5650637 277.278617,49.6510703 283.007812,43.921875 C288.737008,38.1926797 295.651001,35.328125 303.75,35.328125 Z M340.15625,58.6484375 C336.24998,58.6484375 332.91668,60.028632 330.15625,62.7890625 C327.421861,65.549493 326.054688,68.882793 326.054688,72.7890625 C326.054688,76.6692902 327.421861,79.9895695 330.15625,82.75 C332.91668,85.5104305 336.24998,86.890625 340.15625,86.890625 C344.06252,86.890625 347.382799,85.5104305 350.117188,82.75 C352.877618,79.9895695 354.257812,76.6692902 354.257812,72.7890625 C354.257812,68.882793 352.877618,65.549493 350.117188,62.7890625 C347.382799,60.028632 344.06252,58.6484375 340.15625,58.6484375 Z M340.15625,51.34375 C346.041696,51.34375 351.067687,53.4270625 355.234375,57.59375 C359.401063,61.7604375 361.484375,66.7864289 361.484375,72.671875 C361.484375,78.5573211 359.401063,83.5833125 355.234375,87.75 C351.067687,91.9166875 346.041696,94 340.15625,94 C334.270804,94 329.244813,91.9166875 325.078125,87.75 C320.911437,83.5833125 318.828125,78.5573211 318.828125,72.671875 C318.828125,66.7864289 320.911437,61.7604375 325.078125,57.59375 C329.244813,53.4270625 334.270804,51.34375 340.15625,51.34375 Z M388.28125,58.6484375 C384.37498,58.6484375 381.04168,60.028632 378.28125,62.7890625 C375.546861,65.549493 374.179688,68.882793 374.179688,72.7890625 C374.179688,76.6692902 375.546861,79.9895695 378.28125,82.75 C381.04168,85.5104305 384.37498,86.890625 388.28125,86.890625 C392.18752,86.890625 395.507799,85.5104305 398.242188,82.75 C401.002618,79.9895695 402.382812,76.6692902 402.382812,72.7890625 C402.382812,68.882793 401.002618,65.549493 398.242188,62.7890625 C395.507799,60.028632 392.18752,58.6484375 388.28125,58.6484375 Z M406.054688,35.328125 C407.018234,35.328125 407.851559,35.6666633 408.554688,36.34375 C409.257816,37.0468785 409.609375,37.8932242 409.609375,38.8828125 L409.609375,72.7890625 C409.583333,78.6484668 407.487,83.6484168 403.320313,87.7890625 C399.153625,91.9297082 394.140654,94 388.28125,94 C382.395804,94 377.369813,91.9166875 373.203125,87.75 C369.036437,83.5833125 366.953125,78.5573211 366.953125,72.671875 C366.953125,66.7864289 369.036437,61.7604375 373.203125,57.59375 C377.369813,53.4270625 382.395804,51.34375 388.28125,51.34375 C393.64586,51.34375 398.346334,53.1275863 402.382813,56.6953125 L402.382813,38.8828125 C402.382813,37.8932242 402.734371,37.0468785 403.4375,36.34375 C404.140629,35.6666633 404.973954,35.328125 405.9375,35.328125 L406.054688,35.328125 Z M437.578125,58.6484375 C433.671855,58.6484375 430.338555,60.028632 427.578125,62.7890625 C424.843736,65.549493 423.476562,68.882793 423.476562,72.7890625 C423.476562,73.492191 423.528645,74.1822883 423.632812,74.859375 L448.359375,63.6875 C445.546861,60.3281082 441.953147,58.6484375 437.578125,58.6484375 Z M456.953125,63.8046875 C457.369794,64.6901086 457.408856,65.6015578 457.070312,66.5390625 C456.731769,67.4505254 456.106775,68.1145812 455.195312,68.53125 C451.549461,70.1718832 446.757842,72.3333199 440.820312,75.015625 C433.450484,78.348975 428.671886,80.5104117 426.484375,81.5 C429.296889,85.093768 432.994769,86.890625 437.578125,86.890625 C440.625015,86.890625 443.385404,85.9921965 445.859375,84.1953125 C448.25522,82.4505121 449.934891,80.1849098 450.898438,77.3984375 C451.471357,75.7838461 452.617179,74.9765625 454.335938,74.9765625 C455.559902,74.9765625 456.536455,75.4843699 457.265625,76.5 C457.968754,77.4895883 458.111981,78.5703066 457.695312,79.7421875 C456.236972,83.9609586 453.684914,87.3723828 450.039062,89.9765625 C446.315086,92.6588676 442.161481,94 437.578125,94 C431.692679,94 426.666688,91.9166875 422.5,87.75 C418.333312,83.5833125 416.25,78.5573211 416.25,72.671875 C416.25,66.7864289 418.333312,61.7604375 422.5,57.59375 C426.666688,53.4270625 431.692679,51.34375 437.578125,51.34375 C441.822938,51.34375 445.703107,52.5025926 449.21875,54.8203125 C452.682309,57.0859488 455.260408,60.0807105 456.953125,63.8046875 Z" id="LeetCode" fill="#000000"></path>
                      </g>
                  </g>
                </g>
              </g>
            </svg>
        <div class="colorpanel">
        Less<ul class="color-array" style="margin: 0px;padding: 0px 10px;" sub-colors="#ebedf0,#fdcdec,#fc9bd9,#fa6ac5,#f838b2,#f5089f,#c4067e,#92055e,#540336,#48022f,#30021f" submit-gap="5"><li></li><li></li><li></li><li></li><li></li>
        </ul>More
      </div >
      </div>
    </div>
  
    <div class="leetcode-bottom-part">
      <div class="leetcode-annual-sub" >
      <div class="leetcode-bottom-text">过去一年提交数
      </div>
      <div class="leetcode-annul-sub-text" style="color: #c4c6c9;">0
      </div>
      <div class="leetcode-bottom-text"></div>
      </div>
      <div class="leetcode-type">
        <div class="leetcode-bottom-text">不同难度提交数</div>
        <div class="leetcode-type-frame">
          <div class="leetcode-type-simple">
            <div class="leetcode-type-text leetcode-text-simple">Simple
            </div>
            <span class="leetcode-sub-count-text" style="color: #c4c6c9;" id="leetcode-sub-count-simple">69</span>
            <span class="leetcode-total-count-text" id="leetcode-total-count-simple"> / 690</span>
          </div>
          <div class="leetcode-type-medium">
            <div class="leetcode-type-text leetcode-text-medium">Medium
            </div>
            <span class="leetcode-sub-count-text" style="color: #c4c6c9;" id="leetcode-sub-count-medium"> 84</span>
            <span class="leetcode-total-count-text" id="leetcode-total-count-medium"> / 1397</span>
          </div>
          <div class="leetcode-type-hard">
            <div class="leetcode-type-text leetcode-text-hard">Hard
            </div>
            <span class="leetcode-sub-count-text" style="color: #c4c6c9;" id="leetcode-sub-count-hard"> 7</span>
            <span class="leetcode-total-count-text" id="leetcode-total-count-hard"> / 556</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    .panel {
    margin-top: 60px;
    border-radius: 10px;
    padding-top: 20px;
    padding-bottom: 10px;
    box-shadow: rgba(0, 0, 0, 0.25) 0px 14px 28px, rgba(0, 0, 0, 0.22) 0px 10px 10px;
}

.leetcode-tips-container {
    width: 180px;
    height: 40px;
    text-align: center;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 6px;
    position: fixed;
    display: none;
    z-index: 999;
}

.datasource {
    color: #999a9c;
    font-size: 12px;
    margin-left: 20px;
    flex: 1;
}

.leetcode-calendar-wall {
    padding: 10px;
    margin-top: 30px;
    border-radius: 10px;
    box-shadow: rgba(0, 0, 0, 0.25) 0px 14px 28px, rgba(0, 0, 0, 0.22) 0px 10px 10px;
}

.leetcode-bottom-part {
    display: none;
    margin-top: 15px;
}

.leetcode-annual-sub {
    flex: 1;
    padding: 10px;
    border-top: 1px solid #a3a1a1;
    border-right: 1px solid #a3a1a1;
    text-align: center;
    padding: 10px;
}

.leetcode-bottom-text {
    color: #626b72;
    font-size: 12px;
}

.leetcode-type {
    text-align: center;
    border-top: 1px solid #a3a1a1;
    height: auto;
    flex: 2;
    padding: 4px 10px 0px 10px;
}

.leetcode-type-frame {
    display: flex;
    margin-top: 2px;
}

.leetcode-annul-sub-text {
    font-size: 28px;
}

.leetcode-type-simple {
    flex: 1
}

.leetcode-type-medium {
    flex: 1
}

.leetcode-type-hard {
    flex: 1
}

.leetcode-bottom-text {}

.leetcode-sub-count-text {
    font-size: 28px;
}

.leetcode-total-count-text {
    font-size: 14px;
    color: #535160;
}

.leetcode-type-text {
    font-size: 18px;
    font-family: sans-serif;
}

.leetcode-text-simple {
    color: #64d3bebf
}

.leetcode-text-medium {
    color: #d9a73be0
}

.leetcode-text-hard {
    color: #ef7053c2
}

.colorpanel {
    flex: 1;
    display: inline-block;
    font-size: 14px;
    color: #999a9c;
    margin-right: 20px;
    text-align: right;
}

.datapanel {
    float: left;
}

.color-array li {
    width: 10px;
    height: 10px;
    display: inline-block;
}

.color-array {
    list-style: none;
    display: inline-block;
    position: relative;
    padding: 0;
    margin: 0 5px;
}

.leetcode-contri-footer {
    display: flex;
    width: 100%;
    height: 26px;
    align-items: center;
}

@font-face {
    font-family: 'iconfont';
    /* project id 3357837 */
    src: url('');
    src: url('?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_3357837_7jn8nu1mtoc.woff2') format('woff2'), url('//at.alicdn.com/t/font_3357837_7jn8nu1mtoc.woff') format('woff'), url('//at.alicdn.com/t/font_3357837_7jn8nu1mtoc.ttf') format('truetype'), url('#iconfont') format('svg');
}
  </style>
<!-- 防止一些博客没有jquery 先引入3版本 -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script>
    (function leetcodeCalendar() {
    var leetCanvas = document.getElementById('leetcode-sub-calendar');
    var leetCtx = leetCanvas.getContext('2d');
    var width = leetCanvas.width = getComputedStyle(leetCanvas).width.match(/[0-9]+/)[0];
    const dayMillSeconds = 24 * 60 * 60 * 1000;
    const maxRowSize = 7
    const maxColSize = 52
    const months = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
    const weeks = ['日', '二', '四', '六']
    const subColors = []
    const submitGap = document.getElementsByClassName('color-array')[0].getAttribute('submit-gap')
    for (let str of document.getElementsByClassName('color-array')[0].getAttribute('sub-colors').split(",")) {
        subColors.push(str)
    }
    const curDate = new Date();
    const curDateConvert = new Date(curDate.getFullYear(), curDate.getMonth(), +curDate.getDate(), 8, 0, 0);
    const curWeekDay = curDate.getDay() == 0 ? 7 : curDate.getDay() + 1
    const initDate = new Date(curDateConvert.getTime() - (maxRowSize * (maxColSize - 1) + curWeekDay - 1) * dayMillSeconds)
    const userName = document.getElementsByClassName('datasource')[0].getElementsByTagName('a')[0].innerHTML.substring(1)
    const objectMap = JSON.parse(document.getElementById('leetcode-sub-calendar').getAttribute("stamp-param"))
    const map = new Map()
    for (key of Object.keys(objectMap)) {
        map.set(key * 1000, objectMap[key])
    }

    removeAttribute()

    handle(map);

    function handle(data) {
        leetCtx.fillStyle = '#ebedf0'

        var divMargin = 3
        var monthFontSize = 10
        var calendarTopMargin = 20
        var calendarBottomMargin = 10
        var calendarLeftMargin = Math.floor(0.05 * width)
        var divSize = (width - 2 * calendarLeftMargin) / maxColSize - divMargin
        var isInSmallClient = false;

        var height = leetCanvas.height = calendarTopMargin + monthFontSize + 7 * (divSize + divMargin) + calendarBottomMargin

        // 更新height高度
        judgeClientWidth()

        var getPixelRatio = function(context) {
            var backingStore = context.backingStorePixelRatio ||
                context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;
            return (window.devicePixelRatio || 1) / backingStore;
        };
        var ratio = getPixelRatio(leetCtx);
        // deal problems in showing in  high-dpi screen
        if (ratio != 1) {
            leetCanvas.style.width = leetCanvas.width + "px";
            leetCanvas.style.height = leetCanvas.height + "px";
            width = leetCanvas.width = leetCanvas.width * ratio;
            height = leetCanvas.height = leetCanvas.height * ratio;
            monthFontSize *= ratio
            divMargin *= ratio
            calendarTopMargin *= ratio
            calendarBottomMargin *= ratio
            calendarLeftMargin = Math.floor(0.05 * width)
            divSize = (width - 2 * calendarLeftMargin) / maxColSize - divMargin
        }

        // Draw main days block with canvas
        for (col = 0; col < maxColSize; col++) {
            tempRow = maxRowSize;
            if (col == maxColSize - 1) {
                tempRow = curWeekDay;
            }

            for (row = 0; row < tempRow; row++) {
                let curX = calendarLeftMargin + col * (divSize + divMargin)
                let curY = calendarTopMargin + monthFontSize + row * (divSize + divMargin)
                curStamp = initDate.getTime() + (col * 7 + row) * dayMillSeconds
                if (data.get(curStamp) != null) {
                    leetCtx.fillStyle = subColors[Math.min(Math.floor(data.get(curStamp) / submitGap), subColors.length - 1)]
                } else {
                    leetCtx.fillStyle = subColors[0]
                }
                leetCtx.fillRect(curX, curY, divSize, divSize)
            }

        }


        if (!isInSmallClient) {
            drawMonth()
            drawWeekDay()
        }

        setMouseListener()

        fillColorArr()

        calcAnnualSubCount(data)

        changeYearGapText()

        // 根据当前鼠标在页面的绝对坐标和相对canvas的坐标来判断是否在box上
        function judgeAndGenTooltips(x, y, pageX, pageY) {
            if (x < calendarLeftMargin || x > calendarLeftMargin + maxColSize * (divSize + divMargin) - divMargin) {
                return false;
            }
            if (y < calendarTopMargin + monthFontSize || y > calendarTopMargin + monthFontSize +
                7 * (divMargin + divSize) - divMargin) {
                return false;
            }
            toolTipsContainer = document.getElementsByClassName("leetcode-tips-container")[0];
            curCol = Math.floor((x - calendarLeftMargin) / (divMargin + divSize))
            curRow = Math.floor((y - calendarTopMargin - monthFontSize) / (divMargin + divSize))
            selectDate = new Date(initDate.getTime() + (curCol * 7 + curRow) * dayMillSeconds)
            toolTips = document.getElementById("leetcode-tips")
                // 没必要动态加载, 后期直接在页面内预装好模块
            if (toolTips == null) {
                toolTips = document.createElement("p")
                toolTips.style = "color: #fff;line-height: 40px;margin: 0px;"

                toolTipsContainer.appendChild(toolTips)
                toolTips.id = "leetcode-tips"
            }
            let subCount = 0;
            if (data.get(selectDate.getTime()) != null) {
                subCount = data.get(selectDate.getTime());
            }
            const content = selectDate.getFullYear() + "-" + (selectDate.getMonth() + 1) + "-" + selectDate.getDate() + "  " + subCount + "次提交"
            const containerHeight = window.getComputedStyle(toolTipsContainer).height.match(/[0-9]+/)[0];
            const containerWidth = window.getComputedStyle(toolTipsContainer).width.match(/[0-9]+/)[0];
            toolTips.innerHTML = content
            toolTipsContainer.style.display = "block"
            toolTipsContainer.style.left = pageX - containerWidth / 2 + "px";
            toolTipsContainer.style.top = pageY - containerHeight - 20 + "px"
        }

        function drawWeekDay() {
            const weekDayVerticalMargin = (divMargin + divSize) * 2
            const weekDayLeftMargin = 0.03 * width
            for (i in weeks) {
                curX = weekDayLeftMargin
                curY = calendarTopMargin + monthFontSize + 10 * ratio + i * weekDayVerticalMargin
                leetCtx.fillText(weeks[i], curX, curY)
            }
        }

        function drawMonth() {
            leetCtx.fillStyle = '#999a9c'
            const monthsHorizonMargin = Math.floor(0.05 * width)
            const monthMargin = (width - months.length * monthFontSize - 2.5 * monthsHorizonMargin) / (months.length - 1)
            leetCtx.font = monthFontSize + "px Arial"
            startMonth = initDate.getMonth()

            for (i = 0; i < months.length + 1; i++) {
                curX = 1.5 * monthsHorizonMargin + i * (monthMargin + monthFontSize)
                curY = calendarTopMargin
                leetCtx.fillText(months[(i + startMonth + 1) % 12], curX, curY)
            }
        }

        function changeYearGapText() {
            dom = document.getElementsByClassName("leetcode-bottom-text")[1]
            dom.innerHTML = initDate.getFullYear() + "-" + (initDate.getMonth() + 1) + "-" + initDate.getDate() +
                " - " + curDate.getFullYear() + "-" + (curDate.getMonth() + 1) + "-" + curDate.getDate()
        }

        function calcAnnualSubCount(data) {
            sum = 0
            for (let [key, value] of data.entries()) {
                if (parseInt(key) > initDate.getTime()) {
                    sum += value
                }
            }
            dom = document.getElementsByClassName("leetcode-annul-sub-text")[0]
            dom.innerHTML = sum
        }

        function fillColorArr() {
            li_list = document.getElementsByClassName("color-array")[0];
            for (i in li_list.children) {
                li_list.children[i].style = 'background: ' + subColors[i] + ';'
            }
        }

        function setMouseListener() {
            leetCanvas.onmousemove = function(event) {
                judgeAndGenTooltips(event.offsetX, event.offsetY, event.x, event.y)
            }
            leetCanvas.onmouseout = function(event) {
                toolTipsContainer = document.getElementsByClassName("leetcode-tips-container")[0];
                toolTipsContainer.style.display = "none"
            }
        }

        // 客户端窗口过小不显示下方数据栏
        function judgeClientWidth() {
            if (document.body.clientWidth < 700) {
                isInSmallClient = true;
                document.getElementsByClassName("leetcode-bottom-part")[0].style.display = "none"
                divMargin = 1
                divSize = (width - 2 * calendarLeftMargin) / maxColSize - divMargin
            } else {
                document.getElementsByClassName("leetcode-bottom-part")[0].style.display = "flex"
            }
        }
    }

    function removeAttribute() {
        document.getElementsByClassName('color-array')[0].removeAttribute('submit-gap')
        document.getElementsByClassName('color-array')[0].removeAttribute('sub-colors')
        document.getElementById('leetcode-sub-calendar').removeAttribute('stamp-param')
    }
})()
  </script>
  
<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>
<h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[1,2,3]</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt=""><br>输入：root = [1,2]<br>输出：[1,2]</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt=""><br>输入：root = [1,null,2]<br>输出：[1,2]</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>往左下走到头  无路可走的时候弹栈 往右走一步 继续往左走到头</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		pre(list, root);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		list.add(node.val);</span><br><span class="line">		pre(list, node.left);</span><br><span class="line">		pre(list, node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">				res.add(root.val);</span><br><span class="line">				stack.push(root);</span><br><span class="line">				root = root.left;</span><br><span class="line">			&#125;</span><br><span class="line">			TreeNode tmp = stack.poll();</span><br><span class="line">			root = tmp.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>
<h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[1,3,2]</p>
<h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p>
<h2 id="示例-4-1"><a href="#示例-4-1" class="headerlink" title="示例 4"></a>示例 4</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt=""><br>输入：root = [1,2]<br>输出：[2,1]</p>
<h2 id="示例-5-1"><a href="#示例-5-1" class="headerlink" title="示例 5"></a>示例 5</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt=""><br>输入：root = [1,null,2]<br>输出：[1,2]</p>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>迭代算法和之前的前序遍历差不多</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		inorder(root, list);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		inorder(root.left, list);</span><br><span class="line">		list.add(root.val);</span><br><span class="line">		inorder(root.right, list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">				stack.push(root);</span><br><span class="line">				root = root.left;</span><br><span class="line">			&#125;</span><br><span class="line">			root = stack.poll();</span><br><span class="line">			res.add(root.val);</span><br><span class="line">			root = root.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
<h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵二叉树的根节点 root ，返回其节点值的后序遍历 。</p>
<h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[3,2,1]</p>
<h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="进阶-2"><a href="#进阶-2" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>迭代算法几乎和前序遍历一模一样 前序遍历是按照 中左右遍历，那后序遍历我们按照 中右左 再逆序即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		postorder(root, list);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		postorder(root.left, list);</span><br><span class="line">		postorder(root.right, list);</span><br><span class="line">		list.add(root.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">				res.add(root.val);</span><br><span class="line">				stack.push(root);</span><br><span class="line">				root = root.right;</span><br><span class="line">			&#125;</span><br><span class="line">			TreeNode tmp = stack.poll();</span><br><span class="line">			root = tmp.left;</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.reverse(res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
<h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p>
<h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [1]<br>输出：[[1]]</p>
<h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>一层一层模拟<br>首先先将根节点加入到队列中<br>将每一层的元素入队后，记录队列中的元素个数(levelCount)<br>新建一个列表，将该层所有节点出队，每个节点出队的同时，将它的子节点入队<br>这样能保证每次遍历时，队列中的元素个数是每一层的元素个数<br>将这个列表添加到结果列表中<br>往复进行这个操作，直到队为空</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学会层序遍历之后，下面的十道题都可以通杀</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">		ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				list.add(tmp.val);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(list);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p>
<h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p>
<h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [1]<br>输出：[[1]]</p>
<h2 id="示例-3-4"><a href="#示例-3-4" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>在上题的代码上加一行逆序即可</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">		ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				list.add(tmp.val);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(list);</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.reverse(res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p>
<h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。<br>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt=""><br>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p>
<h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""><br>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p>
<h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>跟层序遍历的区别只有判断子节点是否为空</p>
<h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">		ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				Node tmp = deque.pollFirst();</span><br><span class="line">				list.add(tmp.val);</span><br><span class="line">				<span class="keyword">for</span> (Node child : tmp.children) &#123;</span><br><span class="line">					<span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">						deque.offer(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(list);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>
<h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt=""><br>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p>
<h2 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: [1,null,3]<br>输出: [1,3]</p>
<h2 id="示例-3-5"><a href="#示例-3-5" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: []<br>输出: []</p>
<h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;= Node.val &lt;= 100 </p>
<h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>遍历到每层最后一个元素时，将它加入结果集合即可</p>
<h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">				<span class="keyword">if</span> (i == size - <span class="number">1</span>)</span><br><span class="line">					res.add(tmp.val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></p>
<h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p>
<h2 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。</p>
<h2 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt=""><br>输入：root = [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p>
<h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>树中节点数量在 [1, 10^4] 范围内<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>一层一层遍历时，用一个变量对当前层的元素求和，再除以size，得到平均值，加入到结果集合中</p>
<h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				sum += tmp.val;</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(sum / size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p>
<h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>每当遍历一层的时候 深度加一即可</p>
<h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			depth++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> depth;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>
<h2 id="问题叙述-9"><a href="#问题叙述-9" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<h2 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：2</p>
<h2 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [2,null,3,null,4,null,5,null,6]<br>输出：5</p>
<h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>树中节点数的范围在 [0, 10^5] 内<br>-1000 &lt;= Node.val &lt;= 1000</p>
<h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>题目中说 最小深度是从根节点到最近叶子节点的最短路径上的节点数量<br>而叶子节点是指没有子节点的节点<br>跟最大深度类似 每当遍历一层的时候 深度加一<br>所以我们一层一层遍历 找到一个叶子节点的时候 返回它的深度即可</p>
<h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			depth++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> depth;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>
<h2 id="问题叙述-10"><a href="#问题叙述-10" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt=""><br>输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入: root = [1,2,3]<br>输出: [1,3]</p>
<h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1</p>
<h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>遍历每一层的时候 实时更新一下最大值即可</p>
<h2 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.add(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.poll();</span><br><span class="line">				max = Math.max(max, tmp.val);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.add(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.add(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p>
<h2 id="问题叙述-11"><a href="#问题叙述-11" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h2 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt=""><br>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p>
<h2 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数量在 [0, 2^12 - 1] 范围内<br>-1000 &lt;= node.val &lt;= 1000</p>
<h2 id="进阶-3"><a href="#进阶-3" class="headerlink" title="进阶"></a>进阶</h2><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>每个元素出队的时候 让它的next指向队首元素即可 遍历到末尾元素时 让它指向null</p>
<h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				Node tmp = deque.pollFirst();</span><br><span class="line">				<span class="keyword">if</span> (i == size - <span class="number">1</span>) tmp.next = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">else</span> tmp.next = deque.peek();</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<h2 id="问题叙述-12"><a href="#问题叙述-12" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树</p>
<p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h2 id="进阶-4"><a href="#进阶-4" class="headerlink" title="进阶"></a>进阶</h2><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt=""><br>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。</p>
<h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p>
<h2 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h2><p>跟上题的代码一模一样</p>
<h2 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				Node tmp = deque.pollFirst();</span><br><span class="line">				<span class="keyword">if</span> (i == size - <span class="number">1</span>) tmp.next = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">else</span> tmp.next = deque.peek();</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p>
<h2 id="问题叙述-13"><a href="#问题叙述-13" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<h2 id="示例-1-10"><a href="#示例-1-10" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt=""><br>输入：root = [1,2,3,4,5,6]<br>输出：6</p>
<h2 id="示例-2-10"><a href="#示例-2-10" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：0</p>
<h2 id="示例-3-6"><a href="#示例-3-6" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：1</p>
<h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目范围是[0, 5 <em> 10^4]<br>0 &lt;= Node.val &lt;= 5 </em> 10^4<br>题目数据保证输入的树是 完全二叉树</p>
<h2 id="进阶-5"><a href="#进阶-5" class="headerlink" title="进阶"></a>进阶</h2><p>遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p>
<h2 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h2><h2 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				list.add(tmp.val);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<h2 id="问题叙述-14"><a href="#问题叙述-14" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<h2 id="示例-1-11"><a href="#示例-1-11" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt=""><br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<h2 id="示例-2-11"><a href="#示例-2-11" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt=""><br>输入：root = [2,1,3]<br>输出：[2,3,1]</p>
<h2 id="示例-3-7"><a href="#示例-3-7" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p>
<h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目范围在 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h2><p>层序遍历时 交换每个节点两个子节点即可</p>
<h2 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> size = deque.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				TreeNode tmp = deque.pollFirst();</span><br><span class="line">				swapNode(tmp);</span><br><span class="line">				<span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.push(tmp.left);</span><br><span class="line">				<span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.push(tmp.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swapNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		TreeNode tmp = root.left;</span><br><span class="line">		root.left = root.right;</span><br><span class="line">		root.right = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		TreeNode tmp;</span><br><span class="line">		tmp = root.left;</span><br><span class="line">		root.left = root.right;</span><br><span class="line">		root.right = tmp;</span><br><span class="line">		invertTree(root.left);</span><br><span class="line">		invertTree(root.right);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<h2 id="问题叙述-15"><a href="#问题叙述-15" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<h2 id="示例-1-12"><a href="#示例-1-12" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt=""><br>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p>
<h2 id="示例-2-12"><a href="#示例-2-12" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt=""><br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
<h2 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h2><p>我们可以利用双端队列的特性 把他当成两个队列用<br>比较左右两边的节点是否对称 那我们把左边的节点从对头插入 右边的节点从队尾插入<br>节点入队的时候也要按对称的顺序</p>
<h2 id="Code-15"><a href="#Code-15" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offerFirst(root.left);</span><br><span class="line">		deque.offerLast(root.right);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			TreeNode left = deque.pollFirst();</span><br><span class="line">			TreeNode right = deque.pollLast();</span><br><span class="line">			<span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			deque.offerFirst(left.left);</span><br><span class="line">			deque.offerFirst(left.right);</span><br><span class="line">			deque.offerLast(right.right);</span><br><span class="line">			deque.offerLast(right.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> CompareNode(root, root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">CompareNode</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> p.val == q.val &amp;&amp; CompareNode(p.left, q.right) &amp;&amp; CompareNode(p.right, q.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<h2 id="问题叙述-16"><a href="#问题叙述-16" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：true</p>
<h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt=""><br>输入：root = [1,2,2,3,3,null,null,4,4]<br>输出：false</p>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：root = []<br>输出：true</p>
<h2 id="提示-15"><a href="#提示-15" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数在范围 [0, 5000] 内<br>-10^4 &lt;= Node.val &lt;= 10^4</p>
<h2 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h2><p>对于当前遍历到的节点，先遍历它的左右子树是否平衡，再判断以当前节点为根节点的子树是否平衡，如果平衡，则返回它的高度，不平衡则返回-1(高度如果存在则必然大于等于0)，如果左子树或右子树有一个不平衡，或者左右子树高度差大于1，则整棵二叉树不平衡</p>
<h2 id="Code-16"><a href="#Code-16" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> left_Height = height(root.left);</span><br><span class="line">		<span class="keyword">int</span> right_Height = height(root.right);</span><br><span class="line">		<span class="keyword">if</span> (left_Height == -<span class="number">1</span> || right_Height == -<span class="number">1</span> || Math.abs(left_Height - right_Height) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + Math.max(left_Height, right_Height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>
<h2 id="问题叙述-17"><a href="#问题叙述-17" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点 是指没有子节点的节点。</p>
<h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>![])(<a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg">https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg</a>)<br>输入：root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p>
<h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：root = [1]<br>输出：[“1”]</p>
<h2 id="提示-16"><a href="#提示-16" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [1, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p>
<h2 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h2><p>DFS<br>在用深度优先搜索遍历二叉树时，我们只需要考虑当前节点和他的子节点</p>
<ul>
<li>如果当前节点是叶子节点，那我们只需要在当前路径的末尾加上该节点，然后我们就得到了一条由根节点到叶子节点的路径，将路径加入到结果中即可</li>
<li>如果当前节点不是叶子节点，则在当前路径的末尾加上该节点，然后继续递归遍历该节点的子节点<h2 id="Code-17"><a href="#Code-17" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Magic(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Magic</span><span class="params">(TreeNode root, String curPath, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			StringBuffer sb = <span class="keyword">new</span> StringBuffer(curPath);</span><br><span class="line">			sb.append(root.val);</span><br><span class="line">			<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">				res.add(sb.toString());</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				sb.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">				Magic(root.left, sb.toString(), res);</span><br><span class="line">				Magic(root.right, sb.toString(), res);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p>
<h2 id="问题叙述-18"><a href="#问题叙述-18" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt=""><br>输入: root = [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<h2 id="示例2-3"><a href="#示例2-3" class="headerlink" title="示例2"></a>示例2</h2><p>输入: root = [1]<br>输出: 0</p>
<h2 id="提示-17"><a href="#提示-17" class="headerlink" title="提示"></a>提示</h2><p>节点数在 [1, 1000] 范围内<br>-1000 &lt;= Node.val &lt;= 1000</p>
<h2 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h2><p>判断每个节点的左节点是否为叶子节点，然后递归的求取左子树的左叶子之和，右子树的左叶子之和，相加便是整个树的左叶子之和</p>
<h2 id="Code-18"><a href="#Code-18" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)</span><br><span class="line">			sum += root.left.val;</span><br><span class="line">		<span class="keyword">return</span> sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>
<h2 id="问题叙述-19"><a href="#问题叙述-19" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p>
<h2 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt=""><br>输入: root = [2,1,3]<br>输出: 1</p>
<h2 id="示例2-4"><a href="#示例2-4" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt=""><br>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7</p>
<h2 id="提示-18"><a href="#提示-18" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [1,10^4]<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1 </p>
<h2 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h2><p>层序遍历YYDS<br>我们需要找最底层最左边节点的值<br>那我们层序遍历时 从右往左遍历 遍历到的最后一个元素就是要找的节点</p>
<h2 id="Code-19"><a href="#Code-19" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		deque.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">			root = deque.poll();</span><br><span class="line">			<span class="keyword">if</span> (root.right != <span class="keyword">null</span>) deque.offer(root.right);</span><br><span class="line">			<span class="keyword">if</span> (root.left != <span class="keyword">null</span>) deque.offer(root.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p>
<h2 id="问题叙述-20"><a href="#问题叙述-20" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br>叶子节点 是指没有子节点的节点。</p>
<h2 id="示例1-5"><a href="#示例1-5" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt=""><br>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。</p>
<h2 id="示例2-5"><a href="#示例2-5" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt=""><br>输入：root = [1,2,3], targetSum = 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 —&gt; 2): 和为 3<br>(1 —&gt; 3): 和为 4<br>不存在 sum = 5 的根节点到叶子节点的路径。</p>
<h2 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3"></a>示例3</h2><p>输入：root = [], targetSum = 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p>
<h2 id="提示-19"><a href="#提示-19" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;= Node.val &lt;= 1000<br>-1000 &lt;= targetSum &lt;= 1000</p>
<h2 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h2><p>递归<br>如果当前节点是叶子节点，那我们可以直接判断val是否等于targetSum<br>如果当前节点不是叶子节点，那我们递归的判断他的子节点的val是否满足targetSum-val</p>
<h2 id="Code-20"><a href="#Code-20" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">		<span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val)</span><br><span class="line">				|| hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p>
<h2 id="问题叙述-21"><a href="#问题叙述-21" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<h2 id="示例-1-13"><a href="#示例-1-13" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt=""><br>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]</p>
<h2 id="示例2-6"><a href="#示例2-6" class="headerlink" title="示例2"></a>示例2</h2><p>输入：inorder = [-1], postorder = [-1]<br>输出：[-1]</p>
<h2 id="提示-20"><a href="#提示-20" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= inorder.length &lt;= 3000<br>postorder.length == inorder.length<br>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000<br>inorder 和 postorder 都由 不同 的值组成<br>postorder 中每一个值都在 inorder 中<br>inorder 保证是树的中序遍历<br>postorder 保证是树的后序遍历</p>
<h2 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h2><p>递归<br>终止条件是数组长度为0 也就是空节点<br>如果不为空 我们取后序遍历的最后一个节点作为根节点<br>我们按照这个根节点 可以把中序遍历数组分为左数组和右数组<br>同样 将后序遍历数组分为左数组和右数组<br>递归处理左区间和右区间<br>PS:题目中说 中序和后序遍历都是由不同的值构成 所以不用担心有重值的情况</p>
<h2 id="Code-21"><a href="#Code-21" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> n = postorder.length;</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(postorder[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">				root.left = buildTree(Arrays.copyOfRange(inorder, <span class="number">0</span>, i), Arrays.copyOfRange(postorder, <span class="number">0</span>, i));</span><br><span class="line">				root.right = buildTree(Arrays.copyOfRange(inorder, i + <span class="number">1</span>, n), Arrays.copyOfRange(postorder, i, n - <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a>从前序和中序遍历序列构造二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<h2 id="问题叙述-22"><a href="#问题叙述-22" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<h2 id="示例-1-14"><a href="#示例-1-14" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt=""><br>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p>
<h2 id="示例-2-13"><a href="#示例-2-13" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: preorder = [-1], inorder = [-1]<br>输出: [-1]</p>
<h2 id="提示-21"><a href="#提示-21" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= preorder.length &lt;= 3000<br>inorder.length == preorder.length<br>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h2 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h2><p>和上题没有本质上的区别</p>
<h2 id="Code-22"><a href="#Code-22" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> n = preorder.length;</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">				root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(inorder, <span class="number">0</span>, i));</span><br><span class="line">				root.right = buildTree(Arrays.copyOfRange(preorder, i + <span class="number">1</span>, n), Arrays.copyOfRange(inorder, i + <span class="number">1</span>, n));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">https://leetcode-cn.com/problems/maximum-binary-tree/</a></p>
<h2 id="问题叙述-23"><a href="#问题叙述-23" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:<br>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<h2 id="示例-1-15"><a href="#示例-1-15" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt=""><br>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。<h2 id="示例-2-14"><a href="#示例-2-14" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt=""><br>输入：nums = [3,2,1]<br>输出：[3,null,2,null,1]<h2 id="提示-22"><a href="#提示-22" class="headerlink" title="提示"></a>提示</h2>1 &lt;= nums.length &lt;= 1000<br>0 &lt;= nums[i] &lt;= 1000<br>nums 中的所有整数 互不相同<h2 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h2>题目中已经给了思路了 照做就行 跟上题类似<h2 id="Code-23"><a href="#Code-23" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> maxIndex = findMaxIndex(nums);</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">		root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxIndex));</span><br><span class="line">		root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="number">1</span>, nums.length));</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">				max = nums[i];</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">https://leetcode-cn.com/problems/merge-two-binary-trees/</a><h2 id="问题叙述-24"><a href="#问题叙述-24" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。<h2 id="示例-1-16"><a href="#示例-1-16" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt=""><br>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<h2 id="示例-2-15"><a href="#示例-2-15" class="headerlink" title="示例 2"></a>示例 2</h2>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]<h2 id="提示-23"><a href="#提示-23" class="headerlink" title="提示"></a>提示</h2>两棵树中的节点数目在范围 [0, 2000] 内<br>-10^4 &lt;= Node.val &lt;= 10^4<h2 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h2>合并两棵树<br>如果root1是null 那就返回root2即可(root2是null也无所谓 反正也是返回null)<br>如果root2是null 那就返回root1<br>剩下的情况就是 root1和root2都不是null<br>那就把他们的值相加 合并成新节点<br>然后再用前序遍历递归处理即可(中序后序也可以)<h2 id="Code-24"><a href="#Code-24" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)</span><br><span class="line">			root = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">		<span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">		<span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">		root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">		root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化版 直接在root1或root2上修改也行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">		<span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">		root1.val += root2.val;</span><br><span class="line">		root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">		root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">		<span class="keyword">return</span> root1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h1>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a><h2 id="问题叙述-25"><a href="#问题叙述-25" class="headerlink" title="问题叙述"></a>问题叙述</h2>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。<br>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。<h2 id="示例-1-17"><a href="#示例-1-17" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 2<br>输出：[2,1,3]<h2 id="示例-2-16"><a href="#示例-2-16" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 5<br>输出：[]<h2 id="提示-24"><a href="#提示-24" class="headerlink" title="提示"></a>提示</h2>数中节点数在 [1, 5000] 范围内<br>1 &lt;= Node.val &lt;= 10^7<br>root 是二叉搜索树<br>1 &lt;= val &lt;= 10^7<h2 id="分析-25"><a href="#分析-25" class="headerlink" title="分析"></a>分析</h2>先来说一下什么叫二叉搜索树<br>在二叉搜索树中：</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</li>
<li>若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</li>
<li>任意结点的左、右子树也分别为二叉搜索树。</li>
<li>二叉搜索树的中序遍历是升序<br>根据二叉搜索树的性质 如果要找的val值大于根节点的值 那val只可能在该根节点的右子树上找到<br>同理 如果要找的val值小于根节点的值 那val只可能在该根节点的左子树上找到<h2 id="Code-25"><a href="#Code-25" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">		<span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">		<span class="keyword">if</span> (root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化版 前两条if语句可以合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">		<span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">		<span class="keyword">if</span> (root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">https://leetcode-cn.com/problems/validate-binary-search-tree/</a><h2 id="问题叙述-26"><a href="#问题叙述-26" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<h2 id="示例-1-18"><a href="#示例-1-18" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt=""><br>输入：root = [2,1,3]<br>输出：true<h2 id="示例2-7"><a href="#示例2-7" class="headerlink" title="示例2"></a>示例2</h2><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt=""><br>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<h2 id="提示-25"><a href="#提示-25" class="headerlink" title="提示"></a>提示</h2>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1<h2 id="分析-26"><a href="#分析-26" class="headerlink" title="分析"></a>分析</h2>二叉搜索树的中序遍历是升序的<br>所以我们用中序遍历二叉搜索树<br>如果当且节点值<strong>小于等于</strong>上一节点值 则满足条件<br>否则则不是二叉搜索树<h2 id="Code-26"><a href="#Code-26" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isValidBST(root.left)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.val &lt;= pre)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		pre = root.val;</span><br><span class="line">		<span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树的最小绝对值差"><a href="#二叉搜索树的最小绝对值差" class="headerlink" title="二叉搜索树的最小绝对值差"></a>二叉搜索树的最小绝对值差</h1>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a><h2 id="问题叙述-27"><a href="#问题叙述-27" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。<br>差值是一个正数，其数值等于两值之差的绝对值。<h2 id="示例-1-19"><a href="#示例-1-19" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt=""><br>输入：root = [4,2,6,1,3]<br>输出：1<h2 id="示例2-8"><a href="#示例2-8" class="headerlink" title="示例2"></a>示例2</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt=""><br>输入：root = [1,0,48,null,null,12,49]<br>输出：1<h2 id="提示-26"><a href="#提示-26" class="headerlink" title="提示"></a>提示</h2>树中节点的数目范围是 [2, 104]<br>0 &lt;= Node.val &lt;= 105<h2 id="分析-27"><a href="#分析-27" class="headerlink" title="分析"></a>分析</h2>题目要求找<strong>任意</strong>两节点之差绝对值的最小值<br>由于中序遍历的顺序是升序的 所以最小绝对值差 只可能是中序遍历序列中两个相邻元素之差<h2 id="Code-27"><a href="#Code-27" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		inorder(root, list);</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			min = Math.min(list.get(i + <span class="number">1</span>) - list.get(i), min);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		inorder(root.left, list);</span><br><span class="line">		list.add(root.val);</span><br><span class="line">		inorder(root.right, list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p>
<h2 id="问题叙述-28"><a href="#问题叙述-28" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：</p>
<ol>
<li>结点左子树中所含节点的值 小于等于 当前节点的值</li>
<li>结点右子树中所含节点的值 大于等于 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树<h2 id="示例-1-20"><a href="#示例-1-20" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt=""><br>输入：root = [1,null,2,2]<br>输出：[2]<h2 id="示例-2-17"><a href="#示例-2-17" class="headerlink" title="示例 2"></a>示例 2</h2>输入：root = [0]<br>输出：[0]<h2 id="提示-27"><a href="#提示-27" class="headerlink" title="提示"></a>提示</h2>树中节点的数目在范围 [1, 10^4] 内<br>-10^5 &lt;= Node.val &lt;= 10^5<br>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）<h2 id="分析-28"><a href="#分析-28" class="headerlink" title="分析"></a>分析</h2>中序遍历是有序序列<br>所以这道题就简化为从有序序列中寻找众数<br>用pre记录当前节点的上一个节点 初始化为null<br>count记录当前数字重复次数<br>maxCount表示已经扫描过的数字中出现的最大次数<br>如果pre和root的值相同，也就是当前节点与上一个节点的值相等 则count++<br>pre为null时 是判断第一个节点 此时执行count++也没问题<br>否则 则将count初始化为1<br>然后将root赋给pre<br>接着比较当前的count和maxCount<br>如果二者相等 则有多个众数 将当前节点的val加入到结果中<br>如果当前的count大于maxCount 则说明出现了新的众数 将原有结果清空 同时将maxCount更新为当前count 将该节点的val加入到结果中<h2 id="Code-28"><a href="#Code-28" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">	TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		inorder(root, list);</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			res[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		inorder(root.left, list);</span><br><span class="line">		<span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.val == root.val) &#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = root;</span><br><span class="line">		<span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">			list.add(root.val);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">			list.clear();</span><br><span class="line">			maxCount = count;</span><br><span class="line">			list.add(root.val);</span><br><span class="line">		&#125;</span><br><span class="line">		inorder(root.right, list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a><h2 id="问题叙述-29"><a href="#问题叙述-29" class="headerlink" title="问题叙述"></a>问题叙述</h2>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<h2 id="示例-1-21"><a href="#示例-1-21" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<h2 id="示例-2-18"><a href="#示例-2-18" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<h2 id="示例-3-8"><a href="#示例-3-8" class="headerlink" title="示例 3"></a>示例 3</h2>输入：root = [1,2], p = 1, q = 2<br>输出：1<h2 id="提示-28"><a href="#提示-28" class="headerlink" title="提示"></a>提示</h2>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;= Node.val &lt;= 10^9<br>所有 Node.val 互不相同 。<br>p != q<br>p 和 q 均存在于给定的二叉树中。<h2 id="分析-29"><a href="#分析-29" class="headerlink" title="分析"></a>分析</h2>递归<br>若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</li>
<li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root 的左或右子树中；</li>
<li>q = root，且 p 在 root 的左或右子树中；</li>
</ol>
<p>后序遍历整棵二叉树<br>用 left 和 right 分别表示 当前节点的左子树或右子树是否包含节点p或 q ，如果包含为true 否则为false<br>那么符合条件的最近公共祖先则满足以下条件:<br>        (left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right))<br>(left &amp;&amp; right)对应情况1 p和q分裂当前root节点的异侧<br>(root == p || root == q) &amp;&amp; (left || right) 对应条件2和3<br>由于我们是自底向顶遍历的 所以我们找到满足root == p || root == q的节点时 要判断它的左子树或右子树是否包含另一个节点<br>由于我们是自底向顶遍历的 所以满足条件的root必然是深度最大的 也就是最近的公共祖先</p>
<h2 id="Code-29"><a href="#Code-29" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	TreeNode res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasPorQ</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> left = hasPorQ(root.left, p, q);</span><br><span class="line">		<span class="keyword">boolean</span> right = hasPorQ(root.right, p, q);</span><br><span class="line">		<span class="keyword">if</span> ((left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right)))</span><br><span class="line">			res = root;</span><br><span class="line">		<span class="keyword">return</span> left || right || root.val == p.val || root.val == q.val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		hasPorQ(root, p, q);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<h2 id="问题叙述-30"><a href="#问题叙述-30" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p>
<h2 id="示例-1-22"><a href="#示例-1-22" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<h2 id="示例-2-19"><a href="#示例-2-19" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<h2 id="分析-30"><a href="#分析-30" class="headerlink" title="分析"></a>分析</h2><p>利用二叉搜索树的性质<br>左子树中所含节点的值 小于等于 当前节点的值<br>右子树中所含节点的值 大于等于 当前节点的值<br>从根节点开始遍历<br>如果当前节点的值大于p和q的值 那么p和q则应该在当前节点的左子树上 所以我们把当前节点移到它的左子节点上<br>如果当前节点的值小于p和q的值 那么p和q则应该在当前节点的右子树上 所以我们把当前节点移到它的右子节点上<br>如果不满足上述两条要求 则说明p和q分布在当前节点两侧 或者当前节点是p或q 满足要求 返回当前节点即可</p>
<p>直接用上题的代码也可以</p>
<h2 id="Code-30"><a href="#Code-30" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">				root = root.left;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">				root = root.right;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
<h2 id="问题叙述-31"><a href="#问题叙述-31" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<h2 id="示例-1-23"><a href="#示例-1-23" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p>
<h2 id="示例-2-20"><a href="#示例-2-20" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt=""><br>输入：root = [40,20,60,10,30,50,70], val = 25<br>输出：[40,20,60,10,30,50,70,null,null,25]</p>
<h2 id="示例-3-9"><a href="#示例-3-9" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<br>输出：[4,2,7,1,3,5]</p>
<h2 id="提示-29"><a href="#提示-29" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数将在 [0, 10^4]的范围内。<br>-10^8 &lt;= Node.val &lt;= 10^8<br>所有值 Node.val 是 独一无二 的。<br>-10^8 &lt;= val &lt;= 10^8<br>保证 val 在原始BST中不存在。</p>
<h2 id="分析-31"><a href="#分析-31" class="headerlink" title="分析"></a>分析</h2><p>递归<br>比较root.val和目标val的大小关系<br>如果root.val大于目标val 则说明需要插入到左子树中<br>如果root.val小于目标val 则说明需要插入到右子树中<br>如果此时的左/右子树为null  则表明可以直接插入 返回新建一个目标val的节点即可<br>否则的话 继续执行上述两步 直至找到一个合适的位置可供插入</p>
<h2 id="Code-31"><a href="#Code-31" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">		<span class="keyword">if</span> (val &lt; root.val) root.left = insertIntoBST(root.left, val);</span><br><span class="line">		<span class="keyword">if</span> (val &gt; root.val) root.right = insertIntoBST(root.right, val);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p>
<h2 id="问题叙述-32"><a href="#问题叙述-32" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。<h2 id="示例-1-24"><a href="#示例-1-24" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt=""><br>输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<h2 id="示例-2-21"><a href="#示例-2-21" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt=""><br>输入: root = [5,3,6,2,4,null,7], key = 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点<h2 id="示例-3-10"><a href="#示例-3-10" class="headerlink" title="示例 3"></a>示例 3</h2>输入: root = [], key = 0<br>输出: []<h2 id="提示-30"><a href="#提示-30" class="headerlink" title="提示"></a>提示</h2>节点数的范围 [0, 10^4].<br>-10^5 &lt;= Node.val &lt;= 10^5<br>节点值唯一<br>root 是合法的二叉搜索树<br>-10^5 &lt;= key &lt;= 10^5<h2 id="分析-32"><a href="#分析-32" class="headerlink" title="分析"></a>分析</h2>递归</li>
<li>没找到删除节点 返回原来的根节点即可</li>
<li>找到了目标节点 目标节点的两个孩子都不存在 那我们执行root=null:</li>
<li>找到了目标节点 目标节点的左孩子是null 那就直接把目标节点的right 替换到当前节点 root=root.right:</li>
<li>找到了目标节点 目标节点的右孩子是null 那就直接把目标节点的left 替换到当前节点 root=root.left:</li>
<li>找到了目标节点 目标节点的左右孩子均存在 由于二叉搜索树的中序遍历是递增的 那目标节点的左孩子树的所有值均小于右孩子树的最小值 所以我们找到右孩子树上的最左节点 也就是右孩子树上最小的节点 我们将目标节点的左孩子放在右孩子树上最小节点的左孩子的位置 就能满足题目要求<h2 id="Code-32"><a href="#Code-32" class="headerlink" title="Code"></a>Code</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">		<span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">		<span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) root = root.right;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) root = root.left;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				TreeNode node = root.right;</span><br><span class="line">				<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">				node.left = root.left;</span><br><span class="line">				root = root.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">https://leetcode-cn.com/problems/trim-a-binary-search-tree/</a></p>
<h2 id="问题叙述-33"><a href="#问题叙述-33" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。<br>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<h2 id="示例-1-25"><a href="#示例-1-25" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt=""><br>输入：root = [1,0,2], low = 1, high = 2<br>输出：[1,null,2]</p>
<h2 id="示例-2-22"><a href="#示例-2-22" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt=""><br>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3<br>输出：[3,2,null,1]</p>
<h2 id="提示-31"><a href="#提示-31" class="headerlink" title="提示"></a>提示</h2><p>树中节点数在范围 [1, 10^4] 内<br>0 &lt;= Node.val &lt;= 10^4<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;= low &lt;= high &lt;= 10^4</p>
<h2 id="分析-33"><a href="#分析-33" class="headerlink" title="分析"></a>分析</h2><h2 id="Code-33"><a href="#Code-33" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//如果当前节点的值 比左区间端点还小 那就尝试一下当前节点的右节点</span></span><br><span class="line">		<span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">			root = root.right;</span><br><span class="line">			root = trimBST(root, low, high);</span><br><span class="line">		<span class="comment">//如果当前节点的值 比右区间断电还大 那就尝试一下当前节点的左节点</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">			root = root.left;</span><br><span class="line">			root = trimBST(root, low, high);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当前节点满足在区间内 那就先序遍历递归处理所有节点</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root.left = trimBST(root.left, low, high);</span><br><span class="line">			root.right = trimBST(root.right, low, high);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简洁版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.val &lt; low) <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">		<span class="keyword">if</span> (root.val &gt; high) <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">		root.left = trimBST(root.left, low, high);</span><br><span class="line">		root.right = trimBST(root.right, low, high);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="将有序数组转化为二叉搜索树"><a href="#将有序数组转化为二叉搜索树" class="headerlink" title="将有序数组转化为二叉搜索树"></a>将有序数组转化为二叉搜索树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<h2 id="问题叙述-34"><a href="#问题叙述-34" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<h2 id="示例-1-26"><a href="#示例-1-26" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt=""><br>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：<br><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt=""></p>
<h2 id="示例-2-23"><a href="#示例-2-23" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt=""><br>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
<h2 id="提示-32"><a href="#提示-32" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 按 严格递增 顺序排列</p>
<h2 id="分析-34"><a href="#分析-34" class="headerlink" title="分析"></a>分析</h2><p>二分 每次找出数组最中间的值 令它作为根节点</p>
<h2 id="Code-34"><a href="#Code-34" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="keyword">null</span> : Magic(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">TreeNode <span class="title">Magic</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = ((right + left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">		root.left = Magic(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">		root.left = Magic(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="把二叉搜索树转化为累加树"><a href="#把二叉搜索树转化为累加树" class="headerlink" title="把二叉搜索树转化为累加树"></a>把二叉搜索树转化为累加树</h1><p>来源：力扣（Leetcode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p>
<h2 id="问题叙述-35"><a href="#问题叙述-35" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br>提醒一下，二叉搜索树满足下列约束条件：<br>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<h2 id="示例-1-27"><a href="#示例-1-27" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt=""><br>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<h2 id="示例-2-24"><a href="#示例-2-24" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [0,null,1]<br>输出：[1,null,1]</p>
<h2 id="示例-3-11"><a href="#示例-3-11" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1,0,2]<br>输出：[3,3,2]</p>
<h2 id="示例-4-2"><a href="#示例-4-2" class="headerlink" title="示例 4"></a>示例 4</h2><p>输入：root = [3,2,4,1]<br>输出：[7,9,4,10]</p>
<h2 id="提示-33"><a href="#提示-33" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数介于 0 和 10^4 之间。<br>每个节点的值介于 -10^4 和 10^4 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p>
<h2 id="分析-35"><a href="#分析-35" class="headerlink" title="分析"></a>分析</h2><p>读不懂题 然后我去看了1038题 总算读懂了<br>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。<br>由于中序遍历是递增的 左边到右边依次增大<br>所以每个节点的值是 本身+右边所有节点<br>所以我们从右往左进行中序遍历即可  每个节点的值 都等于 自身+上一个节点</p>
<h2 id="Code-35"><a href="#Code-35" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		convertBST(root.right);</span><br><span class="line">		num += root.val;</span><br><span class="line">		root.val = num;</span><br><span class="line">		convertBST(root.left);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Kyle Violet</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cyborg2077.github.io/2022/02/15/BinaryTree/">https://cyborg2077.github.io/2022/02/15/BinaryTree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cyborg2077.github.io" target="_blank">Kyle's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/">算法训练</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=781630402,3569603339&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/21/LanqiaoCup2021/"><img class="prev-cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第十二届蓝桥杯省赛 Java--B组</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/13/StackAndQueue/"><img class="next-cover" src="https://img0.baidu.com/it/u=3661854634,2575655772&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">栈与队列</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src="https://s2.loli.net/2022/04/18/fj4XvrdM5o62hbA.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.4</div><div class="player-name">Kyle Violet</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:35.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>35/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:29.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>29/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:5.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>5/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description">The furthest distance in the world <br>ls not between life and death <br>But when l stand in front of you <br> Yet you don't know that l love you</div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Cyborg2077"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Cyborg2077" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1586385296&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=608935942" target="_blank" title="网抑云"><i class="iconfont icon-wangyiyunyinleclick"></i></a><a class="social-icon" href="https://space.bilibili.com/160218990" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.5.</span> <span class="toc-text">示例 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.6.</span> <span class="toc-text">示例 5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">1.7.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.8.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.9.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code"><span class="toc-number">1.10.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">二叉树的中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-1"><span class="toc-number">2.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-1"><span class="toc-number">2.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-1"><span class="toc-number">2.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4-1"><span class="toc-number">2.5.</span> <span class="toc-text">示例 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5-1"><span class="toc-number">2.6.</span> <span class="toc-text">示例 5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="toc-number">2.7.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-1"><span class="toc-number">2.8.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">2.9.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-1"><span class="toc-number">2.10.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-2"><span class="toc-number">3.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-2"><span class="toc-number">3.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-2"><span class="toc-number">3.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-2"><span class="toc-number">3.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-2"><span class="toc-number">3.6.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">3.7.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-2"><span class="toc-number">3.8.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.</span> <span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-3"><span class="toc-number">4.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-3"><span class="toc-number">4.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-3"><span class="toc-number">4.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-3"><span class="toc-number">4.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">4.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-3"><span class="toc-number">4.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II"><span class="toc-number">5.</span> <span class="toc-text">二叉树的层序遍历II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-4"><span class="toc-number">5.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-4"><span class="toc-number">5.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-4"><span class="toc-number">5.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-4"><span class="toc-number">5.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-4"><span class="toc-number">5.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-4"><span class="toc-number">5.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.</span> <span class="toc-text">N叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-5"><span class="toc-number">6.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-5"><span class="toc-number">6.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-5"><span class="toc-number">6.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-5"><span class="toc-number">6.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-5"><span class="toc-number">6.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-5"><span class="toc-number">6.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-6"><span class="toc-number">7.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-6"><span class="toc-number">7.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-6"><span class="toc-number">7.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-5"><span class="toc-number">7.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-6"><span class="toc-number">7.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-6"><span class="toc-number">7.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-6"><span class="toc-number">7.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">8.</span> <span class="toc-text">二叉树的层平均值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-7"><span class="toc-number">8.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-7"><span class="toc-number">8.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-7"><span class="toc-number">8.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-7"><span class="toc-number">8.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-7"><span class="toc-number">8.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-7"><span class="toc-number">8.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-8"><span class="toc-number">9.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-8"><span class="toc-number">9.3.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-8"><span class="toc-number">9.4.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-9"><span class="toc-number">10.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-8"><span class="toc-number">10.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-8"><span class="toc-number">10.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-8"><span class="toc-number">10.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-9"><span class="toc-number">10.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-9"><span class="toc-number">10.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">11.</span> <span class="toc-text">在每个树行中找最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-10"><span class="toc-number">11.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">11.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">11.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-9"><span class="toc-number">11.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-10"><span class="toc-number">11.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-10"><span class="toc-number">11.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">12.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-11"><span class="toc-number">12.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-9"><span class="toc-number">12.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-9"><span class="toc-number">12.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-10"><span class="toc-number">12.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-3"><span class="toc-number">12.5.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-11"><span class="toc-number">12.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-11"><span class="toc-number">12.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II"><span class="toc-number">13.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-12"><span class="toc-number">13.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-4"><span class="toc-number">13.2.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">13.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-11"><span class="toc-number">13.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-12"><span class="toc-number">13.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-12"><span class="toc-number">13.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-13"><span class="toc-number">14.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-10"><span class="toc-number">14.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-10"><span class="toc-number">14.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-6"><span class="toc-number">14.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-12"><span class="toc-number">14.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-5"><span class="toc-number">14.6.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-13"><span class="toc-number">14.7.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-13"><span class="toc-number">14.8.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">15.</span> <span class="toc-text">翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-14"><span class="toc-number">15.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-11"><span class="toc-number">15.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-11"><span class="toc-number">15.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-7"><span class="toc-number">15.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-13"><span class="toc-number">15.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-14"><span class="toc-number">15.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-14"><span class="toc-number">15.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">16.</span> <span class="toc-text">对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-15"><span class="toc-number">16.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-12"><span class="toc-number">16.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-12"><span class="toc-number">16.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-14"><span class="toc-number">16.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-15"><span class="toc-number">16.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-15"><span class="toc-number">16.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">17.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-16"><span class="toc-number">17.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-1"><span class="toc-number">17.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-1"><span class="toc-number">17.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3"><span class="toc-number">17.4.</span> <span class="toc-text">示例3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-15"><span class="toc-number">17.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-16"><span class="toc-number">17.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-16"><span class="toc-number">17.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">18.</span> <span class="toc-text">二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-17"><span class="toc-number">18.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-2"><span class="toc-number">18.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-2"><span class="toc-number">18.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-16"><span class="toc-number">18.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-17"><span class="toc-number">18.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-17"><span class="toc-number">18.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">19.</span> <span class="toc-text">左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-18"><span class="toc-number">19.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-3"><span class="toc-number">19.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-3"><span class="toc-number">19.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-17"><span class="toc-number">19.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-18"><span class="toc-number">19.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-18"><span class="toc-number">19.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">20.</span> <span class="toc-text">找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-19"><span class="toc-number">20.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-4"><span class="toc-number">20.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-4"><span class="toc-number">20.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-18"><span class="toc-number">20.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-19"><span class="toc-number">20.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-19"><span class="toc-number">20.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">21.</span> <span class="toc-text">路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-20"><span class="toc-number">21.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-5"><span class="toc-number">21.2.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-5"><span class="toc-number">21.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3-1"><span class="toc-number">21.4.</span> <span class="toc-text">示例3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-19"><span class="toc-number">21.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-20"><span class="toc-number">21.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-20"><span class="toc-number">21.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">22.</span> <span class="toc-text">从中序和后序遍历构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-21"><span class="toc-number">22.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-13"><span class="toc-number">22.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-6"><span class="toc-number">22.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-20"><span class="toc-number">22.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-21"><span class="toc-number">22.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-21"><span class="toc-number">22.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">23.</span> <span class="toc-text">从前序和中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-22"><span class="toc-number">23.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-14"><span class="toc-number">23.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-13"><span class="toc-number">23.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-21"><span class="toc-number">23.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-22"><span class="toc-number">23.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-22"><span class="toc-number">23.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">24.</span> <span class="toc-text">最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-23"><span class="toc-number">24.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-15"><span class="toc-number">24.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-14"><span class="toc-number">24.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-22"><span class="toc-number">24.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-23"><span class="toc-number">24.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-23"><span class="toc-number">24.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">25.</span> <span class="toc-text">合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-24"><span class="toc-number">25.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-16"><span class="toc-number">25.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-15"><span class="toc-number">25.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-23"><span class="toc-number">25.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-24"><span class="toc-number">25.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-24"><span class="toc-number">25.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">26.</span> <span class="toc-text">二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-25"><span class="toc-number">26.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-17"><span class="toc-number">26.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-16"><span class="toc-number">26.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-24"><span class="toc-number">26.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-25"><span class="toc-number">26.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-25"><span class="toc-number">26.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">27.</span> <span class="toc-text">验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-26"><span class="toc-number">27.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-18"><span class="toc-number">27.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-7"><span class="toc-number">27.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-25"><span class="toc-number">27.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-26"><span class="toc-number">27.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-26"><span class="toc-number">27.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%B7%AE"><span class="toc-number">28.</span> <span class="toc-text">二叉搜索树的最小绝对值差</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-27"><span class="toc-number">28.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-19"><span class="toc-number">28.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-8"><span class="toc-number">28.3.</span> <span class="toc-text">示例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-26"><span class="toc-number">28.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-27"><span class="toc-number">28.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-27"><span class="toc-number">28.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">29.</span> <span class="toc-text">二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-28"><span class="toc-number">29.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-20"><span class="toc-number">29.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-17"><span class="toc-number">29.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-27"><span class="toc-number">29.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-28"><span class="toc-number">29.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-28"><span class="toc-number">29.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">30.</span> <span class="toc-text">二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-29"><span class="toc-number">30.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-21"><span class="toc-number">30.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-18"><span class="toc-number">30.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-8"><span class="toc-number">30.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-28"><span class="toc-number">30.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-29"><span class="toc-number">30.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-29"><span class="toc-number">30.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">31.</span> <span class="toc-text">二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-30"><span class="toc-number">31.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-22"><span class="toc-number">31.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-19"><span class="toc-number">31.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">31.4.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-30"><span class="toc-number">31.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-30"><span class="toc-number">31.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">32.</span> <span class="toc-text">二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-31"><span class="toc-number">32.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-23"><span class="toc-number">32.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-20"><span class="toc-number">32.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-9"><span class="toc-number">32.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-29"><span class="toc-number">32.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-31"><span class="toc-number">32.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-31"><span class="toc-number">32.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">33.</span> <span class="toc-text">删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-32"><span class="toc-number">33.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-24"><span class="toc-number">33.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-21"><span class="toc-number">33.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-10"><span class="toc-number">33.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-30"><span class="toc-number">33.5.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-32"><span class="toc-number">33.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-32"><span class="toc-number">33.7.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">34.</span> <span class="toc-text">修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-33"><span class="toc-number">34.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-25"><span class="toc-number">34.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-22"><span class="toc-number">34.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-31"><span class="toc-number">34.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-33"><span class="toc-number">34.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-33"><span class="toc-number">34.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">35.</span> <span class="toc-text">将有序数组转化为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-34"><span class="toc-number">35.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-26"><span class="toc-number">35.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-23"><span class="toc-number">35.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-32"><span class="toc-number">35.4.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-34"><span class="toc-number">35.5.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-34"><span class="toc-number">35.6.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">36.</span> <span class="toc-text">把二叉搜索树转化为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%99%E8%BF%B0-35"><span class="toc-number">36.1.</span> <span class="toc-text">问题叙述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-27"><span class="toc-number">36.2.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-24"><span class="toc-number">36.3.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-11"><span class="toc-number">36.4.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4-2"><span class="toc-number">36.5.</span> <span class="toc-text">示例 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-33"><span class="toc-number">36.6.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-35"><span class="toc-number">36.7.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-35"><span class="toc-number">36.8.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/Array/" title="数组"><img src="https://img0.baidu.com/it/u=518815500,4294667560&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="数组"></a><div class="content"><a class="title" href="/2022/01/18/Array/" title="数组">数组</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/20/BackTracking/" title="回溯"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fbf0e4aa0bee8b05d446914c97ae4a611b64f6837.png&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645340425&t=0731cf208414cf55a532ab7a232cc4ff" alt="回溯"></a><div class="content"><a class="title" href="/2022/03/20/BackTracking/" title="回溯">回溯</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/07/DP/" title="动态规划(DP)"><img src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="动态规划(DP)"></a><div class="content"><a class="title" href="/2022/01/07/DP/" title="动态规划(DP)">动态规划(DP)</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/GreedyMethod/" title="贪心算法"><img src="https://img0.baidu.com/it/u=3721396657,2943407387&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=453" alt="贪心算法"></a><div class="content"><a class="title" href="/2022/01/11/GreedyMethod/" title="贪心算法">贪心算法</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/HashTable/" title="哈希表"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fbf0e4aa0bee8b05d446914c97ae4a611b64f6837.png&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645340425&t=0731cf208414cf55a532ab7a232cc4ff" alt="哈希表"></a><div class="content"><a class="title" href="/2022/01/21/HashTable/" title="哈希表">哈希表</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/19/LinkedList/" title="链表"><img src="https://img2.baidu.com/it/u=3099029793,1123284373&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="链表"></a><div class="content"><a class="title" href="/2022/01/19/LinkedList/" title="链表">链表</a><time datetime="2022-05-11" title="发表于 2022-05-11">2022-05-11</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg,#ace0f9,#a1c4fd)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Kyle Violet</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">The worst way to miss someone is to be sitting right beside her <br> knowing you can't have her.</div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))i.fas.fa-adjust--><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-1iozy0e3e-cyborg2077.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-1iozy0e3e-cyborg2077.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo@1.4.14/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-1iozy0e3e-cyborg2077.vercel.app/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo@1.4.14/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="7134539309" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script async src="/js/diytitle.js"></script><script async src="/js/grayscale.js"></script><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/sun_moon.js" async></script><script src="/js/chocolate.js" async></script><script id="canvas_nest" defer="defer" color="255,192,203" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-RQZSMGWCQS', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function card_artitalk_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-shuo"><div class="card-content" style="height:auto;min-height:280px;"><div class="item-headline"><i class="fas fa-comments"></i><span><a href="/artitalk/" title="artitalk page link">碎碎念</a></span><a id="cardVisual" style="cursor:pointer;float:right" onclick="cardVisual()">编辑</a></div><div id="artitalk_main" style="width:100%;height:100%;padding:1px"></div></div></div>';
    console.log('已挂载card_artitalk');
    parent_div_git.insertAdjacentHTML("afterbegin",item_html);
    (()=>{
      const init = () => {
        new Artitalk(Object.assign({
          appId: 'W8Vs5lhPyoXONr88rXUqnTTb-MdYXbMMI',
          appKey: 'CVYbhIp5zeHNMxFpH5ySmrgU',
        }, {"serverURL":"https://W8Vs5lhP.api.lncldglobal.com","lang":"zh","pageSize":1,"color1":"#49b1f5","color2":"#00c4b6","atEmoji":{"Mafumafu1":"https://cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/Mafumafu/199749454.png","Mafumafu2":"https://cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/Mafumafu/199749455.png"}} ))
      }
      if (typeof Artitalk === 'function') {
        init()
      } else {
        getScript('https://npm.elemecdn.com/artitalk').then(init)
      }
    })()
    }
  var elist = '/artitalk/,/posts/'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    card_artitalk_injector_config();
  }
  else if (epage === cpage){
    card_artitalk_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-artitalk-pro/lib/card_visual.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣/&quot;);" href="javascript:void(0);">力扣</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">刷题指南</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题日志/&quot;);" href="javascript:void(0);">刷题日志</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">Leetcode刷题日志，目标成为千题大佬</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">写给自己看的一些笔记</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/蓝桥杯/&quot;);" href="javascript:void(0);">蓝桥杯</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">厕所战神杯 狗都不报</span></li><li class="categoryBar-list-item" style="background:url(http://p9.itc.cn/images03/20200525/07539bdba160465d80d23b3f16db8620.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂谈/&quot;);" href="javascript:void(0);">杂谈</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">随便唠唠</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.1.0"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2021/12/25/JavaThread/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2021/12/25/JavaThread/&quot;);" href="javascript:void(0);" alt="">Java---多线程</a><div class="blog-slider__text">Java学习笔记---多线程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2021/12/25/JavaThread/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2021/11/17/SortMenu/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=852907915,3528076091&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-11-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2021/11/17/SortMenu/&quot;);" href="javascript:void(0);" alt="">十大排序算法</a><div class="blog-slider__text">Java学习笔记---排序算法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2021/11/17/SortMenu/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/04/26/JavaIO/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F7195c774995376cbaf3c2868706521746c0e9142.png&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645330580&amp;t=7ef089d6818c156c451e5072f53f3597" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-04-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/04/26/JavaIO/&quot;);" href="javascript:void(0);" alt="">Java---IO流</a><div class="blog-slider__text">Java学习笔记---IO流</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/04/26/JavaIO/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/04/24/JavaGenerics/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-04-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/04/24/JavaGenerics/&quot;);" href="javascript:void(0);" alt="">Java---泛型</a><div class="blog-slider__text">Java学习笔记---泛型</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/04/24/JavaGenerics/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/04/17/JavaEnumAndAnnotation/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=1144121390,2782791282&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-04-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/04/17/JavaEnumAndAnnotation/&quot;);" href="javascript:void(0);" alt="">Java---枚举类和注解</a><div class="blog-slider__text">Java学习笔记---枚举类和注解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/04/17/JavaEnumAndAnnotation/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/04/21/JavaCollections/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-7f659641f358fab5aa28640c3f62978a_r.jpg&amp;refer=http%3A%2F%2Fpic3.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645330580&amp;t=3c5f025bbdcc09fad7cfd3e8aae5ccc9" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-04-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/04/21/JavaCollections/&quot;);" href="javascript:void(0);" alt="">Java---集合</a><div class="blog-slider__text">Java学习笔记---集合</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/04/21/JavaCollections/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/04/15/JavaCommonClasses/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=1415156609,1199509453&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=949&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-04-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/04/15/JavaCommonClasses/&quot;);" href="javascript:void(0);" alt="">Java---常用类</a><div class="blog-slider__text">Java学习笔记---常用类</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/04/15/JavaCommonClasses/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"log":false});</script></body></html>