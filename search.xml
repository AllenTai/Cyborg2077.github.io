<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java---枚举类和注解</title>
      <link href="/2022/04/17/EnumAndAnnotation/"/>
      <url>/2022/04/17/EnumAndAnnotation/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用类 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java---常用类</title>
      <link href="/2022/04/15/JavaCommonClasses/"/>
      <url>/2022/04/15/JavaCommonClasses/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8之前的日期时间API"><a href="#JDK8之前的日期时间API" class="headerlink" title="JDK8之前的日期时间API"></a>JDK8之前的日期时间API</h1><p><img src="https://s2.loli.net/2022/04/15/ILkq4x1bJOzvcN5.png" alt=""></p><h2 id="System类中获取时间戳的方法"><a href="#System类中获取时间戳的方法" class="headerlink" title="System类中获取时间戳的方法"></a>System类中获取时间戳的方法</h2><blockquote><p>System类提供的public static long currentTimeMillis() 当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p></blockquote><p>此方法适于计算时间差</p><p>例如我想测试不同排序算法对10W个数据排序的时间</p><p>就可以在执行排序算发之前获取一下当前毫秒数</p><p>等排序算法执行完毕后,再获取一下当前毫秒数</p><p>二者只差即为排序算法执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java中两个Date类的使用"><a href="#Java中两个Date类的使用" class="headerlink" title="Java中两个Date类的使用"></a>Java中两个Date类的使用</h2><blockquote><p>java.util.Date类和java.sql.Date类</p><ol><li>两个构造器的使用<ul><li>Date()            创建一个对应当前时间的Date对象</li><li>Date(long time)   创建一个指定毫秒数的Date对象</li></ul></li><li>两个方法的使用<ul><li>toString()        显示当前时间的 年,月,日,时,分,秒</li><li>getTime()         获取当前Date对象对应的毫秒数(时间戳)</li></ul></li><li>java.sql.Date对应着数据库中的日期类型变量<ul><li>如何实例化</li><li>如何将java.util.Date对象转化为java.sql.Date对象</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date1.toString());    <span class="comment">//toString()可以省略  Fri Apr 15 16:57:32 CST 2022</span></span><br><span class="line">System.out.println(date1.getTime());    <span class="comment">//当前毫秒数 1650013052397</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器二:创建指定毫秒数的Date对象</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1650045342397L</span>);</span><br><span class="line">System.out.println(date2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1650045342397L</span>);</span><br><span class="line">System.out.println(date3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何将java.util.Date对象转化为java.sql.Date</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">Date date4 = <span class="keyword">new</span> java.sql.Date(<span class="number">1650045342397L</span>);</span><br><span class="line">java.sql.Date date5 = (java.sql.Date) date4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二 常用</span></span><br><span class="line">Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleDateFormat的使用"><a href="#SimpleDateFormat的使用" class="headerlink" title="SimpleDateFormat的使用"></a>SimpleDateFormat的使用</h2><ul><li><p>Date类的API不易于国际化,大部分都被废弃了,java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</p></li><li><p>它允许执行</p><ul><li>格式化: 日期 —&gt; 文本</li><li>解析: 文本 —&gt; 日期</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"><span class="comment">//格式化日期 --&gt; 字符串</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);<span class="comment">//Fri Apr 15 18:34:46 CST 2022</span></span><br><span class="line">System.out.println(sdf.format(date));<span class="comment">//22-4-15 下午6:34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析:格式化的逆过程 字符串 --&gt; 日期</span></span><br><span class="line">String str = <span class="string">&quot;20-12-18 上午8:26&quot;</span>;</span><br><span class="line">Date date1 = sdf.parse(str);<span class="comment">//这里要用try/catch包起来或者抛异常</span></span><br><span class="line">System.out.println(date1);<span class="comment">//Fri Dec 18 08:26:00 CST 2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定样式的格式化</span></span><br><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy.MM.dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf1.format(date));<span class="comment">//2022.04.15 06:34:19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定样式的解析</span></span><br><span class="line">Date date2 = sdf1.parse(<span class="string">&quot;2077.08.26 23:12:13&quot;</span>);</span><br><span class="line">System.out.println(date2);<span class="comment">//Thu Aug 26 11:12:13 CST 2077</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意大小写:大写Y表示weekYear 大写H表示24小时制 小写h表示12小时制<br>详情参阅API文档<a href="https://www.runoob.com/manual/jdk11api/java.base/java/text/SimpleDateFormat.html#year">Class SimpleDateFormat</a></p></blockquote><h2 id="SimpleDateFormat的练习"><a href="#SimpleDateFormat的练习" class="headerlink" title="SimpleDateFormat的练习"></a>SimpleDateFormat的练习</h2><blockquote><p>练习一: 字符串”2020-09-08”转换为java.sql.Date</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">Date date = sdf.parse(str);</span><br><span class="line">java.sql.Date date1 = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">System.out.println(date1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>练习二: 三天打鱼两天晒网<br>从1990.01.01开始 三天打鱼两天晒网<br>那么在2022.04.14时 是在打鱼还是晒网</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算出相差多少天之后 对5整除 如果结果是1,2,3那么就是在打鱼 否则在晒网</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;1990.01.01&quot;</span>;</span><br><span class="line">String str1 = <span class="string">&quot;2022.04.14&quot;</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line">Date startDate = sdf.parse(str);</span><br><span class="line">Date endDate = sdf.parse(str1);</span><br><span class="line"><span class="keyword">long</span> a = (endDate.getTime() - startDate.getTime()) / (<span class="number">1000</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> b = a % <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || b == <span class="number">2</span> || b == <span class="number">3</span>) System.out.println(<span class="string">&quot;打鱼&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(<span class="string">&quot;晒网&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Calendar类的使用"><a href="#Calendar类的使用" class="headerlink" title="Calendar类的使用"></a>Calendar类的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 实例化</span></span><br><span class="line"><span class="comment">//方式一:创建其子类 GregorianCalendar()的对象</span></span><br><span class="line"><span class="comment">//方式二:调用其静态方法getInstance()  ---&gt; 常用 实际上还是创建的GregorianCalendar类的实例</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getClass()); <span class="comment">//class java.util.GregorianCalendar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//今天是2022.4.16 星期六</span></span><br><span class="line"><span class="comment">//int get(int field) 返回给定日历字段的值</span></span><br><span class="line"><span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);    <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">System.out.println(days);    <span class="comment">//106</span></span><br><span class="line"></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">System.out.println(days);    <span class="comment">//7 星期日是第1天 星期一是第2天 以此类推 星期六是第7天</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> months = calendar.get(Calendar.MONTH);</span><br><span class="line">System.out.println(months); <span class="comment">//3 一月份是0 以此类推 十二月份是11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void set(int field,int value) 将给定的日历字段设置为给定值。</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">13</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);    <span class="comment">//13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void add() 根据日历的规则，将指定的时间量添加或减去给定的日历字段</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">10</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);    <span class="comment">//13 + 10 = 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Date getTime() 日历类---&gt; Date  返回表示此 Calendar的时间值（距离 Epoch的毫秒偏移量）的 Date对象。</span></span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line">System.out.println(date);    <span class="comment">//Sat Apr 23 12:36:04 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void setTime(Date date)Date ---&gt; 日历类 使用给定的Date设置此日历的时间。</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK8中日期时间API的介绍"><a href="#JDK8中日期时间API的介绍" class="headerlink" title="JDK8中日期时间API的介绍"></a>JDK8中日期时间API的介绍</h1><blockquote><p>新日期时间API出现的背景</p></blockquote><p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li>可变性：像日期和时间这样的类应该是不可变的。</li><li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li><li>格式化：格式化只对Date有用，Calendar则不行。</li><li>此外，它们也不是线程安全的；不能处理闰秒等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//偏移量</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">2022</span>,<span class="number">4</span>,<span class="number">16</span>); <span class="comment">//Tue May 16 00:00:00 CST 3922</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//年份从1900开始算起 月份从0开始算起</span></span><br><span class="line">date = <span class="keyword">new</span> Date(<span class="number">2022</span>-<span class="number">1900</span>,<span class="number">4</span>-<span class="number">1</span>,<span class="number">16</span>);<span class="comment">//Sat Apr 16 00:00:00 CST 2022</span></span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p><p>Java 8 吸收了Joda-Time 的精华，以一个新的开始为Java 创建优秀的API。新的java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的Date 类新增了toInstant()方法，用于把Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</p><h2 id="LocalDate、LocalTime、LocalDateTime的使用"><a href="#LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="LocalDate、LocalTime、LocalDateTime的使用"></a>LocalDate、LocalTime、LocalDateTime的使用</h2><blockquote><p>LocalDate、LocalTime、LocalDateTime类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p></blockquote><ul><li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li><li>LocalTime表示一个时间，而不是日期。</li><li>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</li></ul><blockquote><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取年月日</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取年月日&quot;</span>);</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取时分秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取时分秒&quot;</span>);</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">System.out.println(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年月日时分秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取年月日时分秒&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置指定的年,月,日,时,分,秒 没有偏移量</span></span><br><span class="line">System.out.println(<span class="string">&quot;设置指定的年,月,日,时,分,秒 没有偏移量&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2077</span>, <span class="number">8</span>, <span class="number">26</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">21</span>);</span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getXxx()</span></span><br><span class="line">System.out.println(<span class="string">&quot;getXxx()&quot;</span>);</span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());    <span class="comment">//当前月的第几天</span></span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());    <span class="comment">//星期几</span></span><br><span class="line">System.out.println(localDateTime.getDayOfYear());    <span class="comment">//一年的第几天</span></span><br><span class="line">System.out.println(localDateTime.getMonth());        <span class="comment">//月份</span></span><br><span class="line">System.out.println(localDateTime.getMinute());        <span class="comment">//分钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//体现不可变性</span></span><br><span class="line"><span class="comment">//withXxx():设置相关属性</span></span><br><span class="line">System.out.println(<span class="string">&quot;体现不可变性&quot;</span>);</span><br><span class="line">LocalDateTime localDateTime2 = localDateTime1.withDayOfMonth(<span class="number">10</span>);</span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line">System.out.println(localDateTime2);</span><br><span class="line"><span class="comment">//plusXxx/minusXxx():在当前对象上加减日/年/月/周等</span></span><br><span class="line">LocalDateTime localDateTime3 = localDateTime1.plusDays(<span class="number">10</span>);</span><br><span class="line">LocalDateTime localDateTime4 = localDateTime1.minusHours(<span class="number">8</span>);</span><br><span class="line">System.out.println(localDateTime3);</span><br><span class="line">System.out.println(localDateTime4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">now()</td><td style="text-align:center">静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td style="text-align:center">of()</td><td style="text-align:center">静态方法，根据指定日期/时间创建对象</td></tr><tr><td style="text-align:center">getDayOfMonth()/getDayOfYear()</td><td style="text-align:center">获得月份天数(1-31)/获得年份天数(1-366)</td></tr><tr><td style="text-align:center">getDayOfWeek()</td><td style="text-align:center">获得星期几(返回一个DayOfWeek枚举值)</td></tr><tr><td style="text-align:center">getMonth()</td><td style="text-align:center">获得月份,返回一个Month枚举值</td></tr><tr><td style="text-align:center">getHour()/getMinute()/getSecond()</td><td style="text-align:center">获得当前对象对应的小时、分钟、秒</td></tr><tr><td style="text-align:center">withDayOfMonth()/withDayOfYear()/ withMonth()/withYear()</td><td style="text-align:center">将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td style="text-align:center">minusMonths()/minusWeeks()/minusDays()/ minusYears()/minusHours()</td><td style="text-align:center">从当前对象减去几月、几周、几天、几年、几小时</td></tr></tbody></table></div><h2 id="Instant类的使用"><a href="#Instant类的使用" class="headerlink" title="Instant类的使用"></a>Instant类的使用</h2><ul><li><p>Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</p></li><li><p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p></li><li><p>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p></li></ul><blockquote><p>1秒 = 1000毫秒 = 10^6微秒 = 10^9纳秒</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">now()</td><td style="text-align:center">静态方法，返回默认UTC时区的Instant类的对象</td></tr><tr><td style="text-align:center">of()</td><td style="text-align:center">静态方法，返回在1970-01-01 00:00:00基础上 加上指定毫秒数之后的Instant类的对象</td></tr><tr><td style="text-align:center">atOffset(ZoneOffset offset)</td><td style="text-align:center">结合即时的偏移来创建一个OffsetDateTime</td></tr><tr><td style="text-align:center">toEpochMilli()</td><td style="text-align:center">返回1970-01-0100:00:00到当前时间的毫秒数，即为时间戳</td></tr></tbody></table></div><blockquote><p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//now()获取本初子午线对应的标准时间 与北京时间有8小时时差 因为北京在东八区</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//atOffset(ZoneOffset offset) 设置偏移量</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line"><span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">Instant instant1 = Instant.ofEpochMilli(<span class="number">1650166369891L</span>);</span><br><span class="line">System.out.println(instant1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateTimeFormatter的使用"><a href="#DateTimeFormatter的使用" class="headerlink" title="DateTimeFormatter的使用"></a>DateTimeFormatter的使用</h2><blockquote><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p></blockquote><ol><li>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li><li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li><li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li></ol><p>依旧是自定义格式最常用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">System.out.println(<span class="string">&quot;方式一&quot;</span>);</span><br><span class="line">DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line"><span class="comment">//格式化：日期 ---&gt; 字符串</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(dateTimeFormatter1.format(localDateTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：字符串 ---&gt; 日期</span></span><br><span class="line">TemporalAccessor parse = dateTimeFormatter1.parse(<span class="string">&quot;2077-01-01T00:00:00.000&quot;</span>);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">System.out.println(<span class="string">&quot;方式二&quot;</span>);</span><br><span class="line">DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">System.out.println(dateTimeFormatter2.format(localDateTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三 自定义格式ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)</span></span><br><span class="line">System.out.println(<span class="string">&quot;方式三&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter3 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(dateTimeFormatter3.format(localDateTime));</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">TemporalAccessor parse1 = dateTimeFormatter3.parse(<span class="string">&quot;2077-01-17 12:52:47&quot;</span>);</span><br><span class="line">System.out.println(parse1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java中的对象，正常情况下，只能进行比较：==或 != 。不能使用 &gt;或&lt;的，但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 如何实现？使用两个接口中的任何一个：Comparable或 Comparator</p><p>Java实现对象排序的方式有两种：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><h2 id="Comparable自然排序举例"><a href="#Comparable自然排序举例" class="headerlink" title="Comparable自然排序举例"></a>Comparable自然排序举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;EE&quot;</span>, <span class="string">&quot;FF&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;BB&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//默认升序排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类实现Comparable自然排序"><a href="#自定义类实现Comparable自然排序" class="headerlink" title="自定义类实现Comparable自然排序"></a>自定义类实现Comparable自然排序</h2><blockquote><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个商品类实现Comparable接口，重写compareTo()方法，按照商品价格升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指明商品比较大小的方式:按照价格从低到高排序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">Goods goods = (Goods) o;</span><br><span class="line"><span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.getPrice(),goods.getPrice());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据类型不一致&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;联想&quot;</span>, <span class="number">20</span>);</span><br><span class="line">goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;小米&quot;</span>, <span class="number">50</span>);</span><br><span class="line">goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;华为&quot;</span>, <span class="number">40</span>);</span><br><span class="line">goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;罗技&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(goods);</span><br><span class="line">System.out.println(Arrays.toString(goods));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Comparator实现定制排序"><a href="#使用Comparator实现定制排序" class="headerlink" title="使用Comparator实现定制排序"></a>使用Comparator实现定制排序</h2><ol><li><p>背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p></li><li><p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;EE&quot;</span>, <span class="string">&quot;FF&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;BB&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//重写方法变成降序排序</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"><span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;联想&quot;</span>, <span class="number">20</span>);</span><br><span class="line">goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;小米&quot;</span>, <span class="number">50</span>);</span><br><span class="line">goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;华为&quot;</span>, <span class="number">40</span>);</span><br><span class="line">goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;罗技&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(goods, <span class="keyword">new</span> Comparator&lt;Goods&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods o1, Goods o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(goods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparable接口与Comparator的使用的对比"><a href="#Comparable接口与Comparator的使用的对比" class="headerlink" title="Comparable接口与Comparator的使用的对比"></a>Comparable接口与Comparator的使用的对比</h2><ul><li><p>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</p></li><li><p>Comparator接口属于临时性的比较。每次比较时都需要重写一遍compate方法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用类 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记</title>
      <link href="/2022/04/12/LuaLearningNotes/"/>
      <url>/2022/04/12/LuaLearningNotes/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平时练习</title>
      <link href="/2022/03/31/UsualPractice/"/>
      <url>/2022/03/31/UsualPractice/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>2 &lt;= nums.length &lt;= 10^4<br>-10^9 &lt;= nums[i] &lt;= 10^9<br>-10^9 &lt;= target &lt;= 10^9<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>HashMap<br>暴力算法直接两层for循环<br>时间复杂度为O(N)的算法用HashMap<br>每次存入数据时(nums[i])，判断一下当前map中是否存在target-nums[i]<br>如果有的话 直接把他俩作为结果返回<br>没有的话就正常存入</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hashmap.containsKey(target - nums[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, hashmap.get(target - nums[i])&#125;;</span><br><span class="line">hashmap.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;= Node.val &lt;= 9<br>题目数据保证列表表示的数字不含前导零</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode cur = pre;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line"><span class="keyword">int</span> y = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line"><span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">sum %= <span class="number">10</span>;</span><br><span class="line">cur.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">cur = cur.next;</span><br><span class="line"><span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line"><span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a>      </p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= s.length &lt;= 5 * 10^4<br>s 由英文字母、数字、符号和空格组成</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">map.put(s.charAt(i), i);</span><br><span class="line">max = Math.max(i - left + <span class="number">1</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h1><p>来源：力扣（LeetCode）<br>链接：</p><h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 动态规划(DP) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九届蓝桥杯省赛 Java--B组</title>
      <link href="/2022/03/30/LanqiaoCup04/"/>
      <url>/2022/03/30/LanqiaoCup04/</url>
      
        <content type="html"><![CDATA[<h1 id="试题-A：第几天-5分"><a href="#试题-A：第几天-5分" class="headerlink" title="试题 A：第几天(5分)"></a>试题 A：第几天(5分)</h1><p>2000年的1月1日，是那一年的第1天。<br>那么，2000年的5月4日，是那一年的第几天？</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>签到题</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">31</span> + <span class="number">29</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案：125</span></span><br></pre></td></tr></table></figure><h1 id="试题-B：方格计数-7分"><a href="#试题-B：方格计数-7分" class="headerlink" title="试题 B：方格计数(7分)"></a>试题 B：方格计数(7分)</h1><p>如下图所示，在二维平面上有无数个1x1的小方格。<br><img src="https://img-blog.csdn.net/20180401224202573" alt=""><br>我们以某个小方格的一个顶点为圆心画一个半径为1000的圆。<br>你能计算出这个圆里有多少个完整的小方格吗？ </p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>以圆心建立平面直角坐标系 枚举第一象限1000*1000范围内的的所有格子<br>只要每个小方格的右上角到圆心的距离小于1000(半径) 那么这个格子就在圆内<br>结果乘以四 就是最终结果</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (i * i + j * j &lt;= <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line">res++;</span><br><span class="line">System.out.println(<span class="number">4</span> * res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-C：复数幂-13分"><a href="#试题-C：复数幂-13分" class="headerlink" title="试题 C：复数幂(13分)"></a>试题 C：复数幂(13分)</h1><p>设i为虚数单位。对于任意正整数n，(2+3i)^n 的实部和虚部都是整数。<br>求 (2+3i)^123456 等于多少？ 即(2+3i)的123456次幂，这个数字很大，要求精确表示。</p><p>答案写成 “实部±虚部i” 的形式，实部和虚部都是整数（不能用科学计数法表示），中间任何地方都不加空格，实部为正时前面不加正号。(2+3i)^2 写成: -5+12i，<br>(2+3i)^5 的写成: 122-597i</p><p>注意：需要提交的是一个很庞大的复数，不要填写任何多余内容。</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>(a+bi)<em>(c+di) = (a</em>c-b<em>d) + (a</em>d+b<em>c)i<br>(2+3i)</em>(2+3i) = (2<em>2-3</em>3) + (2<em>3+2</em>3)i<br>c+di保持2+3i不变<br>每次运算完毕后 将a+bi更新为计算结果<br>循环123456次<br>答案太长 就不贴了 13W+个字符</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line">BigInteger b = BigInteger.valueOf(<span class="number">3</span>);</span><br><span class="line">BigInteger c = BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line">BigInteger d = BigInteger.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">123456</span>; i++) &#123;</span><br><span class="line">BigInteger A = a.multiply(c).subtract(b.multiply(d));</span><br><span class="line">BigInteger B = a.multiply(d).add(b.multiply(c));</span><br><span class="line">a = A;</span><br><span class="line">b = B;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a.toString() + b + <span class="string">&quot;i&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-D：测试次数-17分"><a href="#试题-D：测试次数-17分" class="headerlink" title="试题 D：测试次数(17分)"></a>试题 D：测试次数(17分)</h1><p>x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。<br>各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。</p><p>x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。</p><p>如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。<br>特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。<br>如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n</p><p>为了减少测试次数，从每个厂家抽样3部手机参加测试。</p><p>某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？</p><p>请填写这个最多测试次数。</p><p>注意：需要填写的是一个整数，不要填写任何多余内容。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十届蓝桥杯省赛 Java--B组</title>
      <link href="/2022/03/26/LanqiaoCup03/"/>
      <url>/2022/03/26/LanqiaoCup03/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pan.baidu.com/s/18PbrvXoOFxb-_lmR5DASaA">第十届蓝桥杯Java省赛B组题目下载  提取码: qx4j</a></p><h1 id="试题-A-组队-5分"><a href="#试题-A-组队-5分" class="headerlink" title="试题 A: 组队(5分)"></a>试题 A: 组队(5分)</h1><p>作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？</p><p><img src="https://img-blog.csdnimg.cn/20190604115436261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNDM5Nzc1NTIw,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>暴力枚举<br>要求这五个人不在同一行即可  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">arr[i][j] = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">20</span>; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">20</span>; b++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">20</span>; c++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">20</span>; d++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; <span class="number">20</span>; e++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[a][<span class="number">0</span>] + arr[b][<span class="number">1</span>] + arr[c][<span class="number">2</span>] + arr[d][<span class="number">3</span>] + arr[e][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> ((a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; a != e) &amp;&amp; (b != c &amp;&amp; b != d &amp;&amp; b != e) &amp;&amp; (c != d &amp;&amp; c != e) &amp;&amp; (d != e)) &#123;</span><br><span class="line">max = Math.max(tmp, max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">97 90 0 0 0 92 85 96 0 0 0 0 0 0 93 0 0 0 80 86 89 83 97 0 0 82 86 0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 87 90 0 97 96 0 0 0 0 89 0 0 95 99 0 0 0 0 0 96 97 0 0 0 0 93 98 94 91 0 0</span></span><br><span class="line"><span class="comment">0 0 83 87 0 0 0 0 98 97 98 0 0 0 93 86 98 83 99 98 81 93 87 92 96 98 0 0 0 89</span></span><br><span class="line"><span class="comment">92 0 99 96 95 81</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：490</span></span><br></pre></td></tr></table></figure><h1 id="试题-B-不同子串-5分"><a href="#试题-B-不同子串-5分" class="headerlink" title="试题 B: 不同子串(5分)"></a>试题 B: 不同子串(5分)</h1><p>一个字符串的非空子串是指字符串中长度至少为 1 的连续的一段字符组成 的串。例如，字符串aaab 有非空子串a, b, aa, ab, aaa, aab, aaab，一共 7 个。 注意在计算时，只算本质不同的串的个数。 请问，字符串0100110001010001 有多少个不同的非空子串？</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>暴力枚举 set去重</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;0100110001010001&quot;</span>;</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str.length(); j++)</span><br><span class="line">set.add(str.substring(i, j + <span class="number">1</span>));</span><br><span class="line">System.out.println(set.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：100</span></span><br></pre></td></tr></table></figure><h1 id="试题-C-数列求值-10分"><a href="#试题-C-数列求值-10分" class="headerlink" title="试题 C: 数列求值(10分)"></a>试题 C: 数列求值(10分)</h1><p>给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求 第 20190324 项的最后 4 位数字。</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>相当于三项的斐波那契数列<br>20190324项肯定会溢出<br>我们只保留末尾四位数字</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20190324</span>];</span><br><span class="line">dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">20190324</span>; i++)</span><br><span class="line">dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">3</span>]) % <span class="number">10000</span>;</span><br><span class="line">System.out.println(dp[<span class="number">20190323</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：4659</span></span><br></pre></td></tr></table></figure><h1 id="试题-D-数的分解-10分"><a href="#试题-D-数的分解-10分" class="headerlink" title="试题 D: 数的分解(10分)"></a>试题 D: 数的分解(10分)</h1><p>本题总分：10 分</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包 含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>三个数凑成2019<br>有 ABC ACB BAC BCA CAB CBA 这六种<br>AAB ABA BAA 这三种<br>AAA 这一种<br>一共十种情况<br>题目要求3个各不相同的正整数<br>那我们就选取ABC这种情况 其中ABC是依次递增的</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2019</span> / <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (method(i)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">2019</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (method(j)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">2019</span> - i - j;</span><br><span class="line"><span class="keyword">if</span> (method(k)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; j) res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (num + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;2&quot;</span>) || (num + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：40785</span></span><br></pre></td></tr></table></figure><h1 id="试题-E：迷宫-15分"><a href="#试题-E：迷宫-15分" class="headerlink" title="试题 E：迷宫(15分)"></a>试题 E：迷宫(15分)</h1><p>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。<br>010000<br>000100<br>001001<br>110000<br>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。<br>对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。<br>对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。<br>请注意在字典序中D&lt;L&lt;R&lt;U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）<br>01010101001011001001010110010110100100001000101010<br>00001000100000101010010000100000001001100110100101<br>01111011010010001000001101001011100011000000010000<br>01000000001010100011010000101000001010101011001011<br>00011111000000101000010010100010100000101100000000<br>11001000110101000010101100011010011010101011110111<br>00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010<br>00111000001010100001100010000001000101001100001001<br>11000110100001110010001001010101010101010001101000<br>00010000100100000101001010101110100010101010000101<br>11100100101001001000010000010101010100100100010100<br>00000010000000101011001111010001100000101010100011<br>10101010011100001000011000010110011110110100001000<br>10101010100001101010100101000010100000111011101001<br>10000000101100010000101100101101001011100000000100<br>10101001000000010100100001000100000100011110101001<br>00101001010101101001010100011010101101110000110101<br>11001010000100001100000010100101000001000111000010<br>00001000110000110101101000000100101001001000011101<br>10100101000101000000001110110010110101101010100001<br>00101000010000110101010000100010001001000100010101<br>10100001000110010001000010101001010101011111010010<br>00000100101000000110010100101001000001000000000010<br>11010000001001110111001001000011101001011011101000<br>00000110100010001000100000001000011101000000110011<br>10101000101000100010001111100010101001010000001000<br>10000010100101001010110000000100101010001011101000<br>00111100001000010000000110111000000001000000001011<br>10000001100111010111010001000110111010101101111000</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>BFS</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] X = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] Y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;<span class="comment">//D,L,R,U</span></span><br><span class="line"><span class="keyword">static</span> String[] stepPath = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;U&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">n = scan.nextInt();</span><br><span class="line">m = scan.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">String str = scan.next();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">map[i][j] = str.charAt(j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkedList&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> Node(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">Node tmp = que.poll();</span><br><span class="line">vis[tmp.x][tmp.y] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp.x == n &amp;&amp; tmp.y == m) &#123;</span><br><span class="line">System.out.println(tmp.path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> newX = tmp.x + X[i];</span><br><span class="line"><span class="keyword">int</span> newY = tmp.y + Y[i];</span><br><span class="line"><span class="keyword">if</span> (check(newX, newY)) &#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(newX, newY, tmp.path + stepPath[i]);</span><br><span class="line">que.offer(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> !vis[x][y] &amp;&amp; map[x][y] != <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">String path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.path = path;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案：DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</span></span><br></pre></td></tr></table></figure><h1 id="试题-F-特别数的和-15分"><a href="#试题-F-特别数的和-15分" class="headerlink" title="试题 F: 特别数的和(15分)"></a>试题 F: 特别数的和(15分)</h1><p>小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行包含两个整数 n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个整数，表示满足条件的数的和。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>40</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>574</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 20% 的评测用例，1≤n≤10。<br>对于 50% 的评测用例，1≤n≤100。<br>对于 80% 的评测用例，1≤n≤1000。<br>对于所有评测用例，1≤n≤10000。</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>送分题</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;2&quot;</span>) || (i + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;0&quot;</span>) || (i + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;1&quot;</span>) || (i + <span class="string">&quot;&quot;</span>).contains(<span class="string">&quot;9&quot;</span>))</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-G-外卖店优先级-20分"><a href="#试题-G-外卖店优先级-20分" class="headerlink" title="试题 G: 外卖店优先级(20分)"></a>试题 G: 外卖店优先级(20分)</h1><p>“饱了么”外卖系统中维护着 N 家外卖店，编号 1 ∼ N。每家外卖店都有 一个优先级，初始时 (0 时刻) 优先级都为 0。 每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减 到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。 如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果 优先级小于等于 3，则会被清除出优先缓存。 给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优 先缓存中。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含 3 个整数 N、M 和 T。 以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到 一个订单。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数代表答案。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>2 6 6<br>1 1<br>5 2<br>3 1<br>6 2<br>2 1<br>6 2</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>1</p><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6， 加入优先缓存。所以是有 1 家店 (2 号) 在优先缓存中。</p><h2 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 80% 的评测用例，1≤ N,M,T ≤10000。<br>对于所有评测用例，1≤ N,M,T ≤100000，1 ≤ ts ≤ T，1 ≤ id ≤ N。</p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>DP<br>创建一个二维数组dp<br>dp[i][j]初始化为在 i时刻 j店铺 拥有的订单数<br>拿样例输入距离就是 dp[1][1]表示在1时刻 1店铺有一个订单 我们直接dp[ts][id]++即可(允许同一时刻收到多个订单 优先级与订单数成正比)<br>当前时刻的优先级只与上一时刻的优先级有关<br>如果当前店铺当前时刻有订单(dp[i][j]&gt;0) 那么当前店铺当前时刻的优先级 就是 当前店铺上一时刻的优先级的基础上 + 2 *（当前店铺当前时刻订单数）<br>否则当前店铺的优先级-1 也就是在上一时刻的优先级的基础上-1  此时我们需要判断一下上一时刻优先级是否为0<br>每次变更完优先级之后 判断是否加入或删除于优先缓存中<br>内存超限 通过90%的样例<br>优化思路：HashMap(以后再写)</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> N = scan.nextInt(), M = scan.nextInt(), T = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[T + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">boolean</span>[] isPriority = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">dp[scan.nextInt()][scan.nextInt()]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j] * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; <span class="number">5</span>)</span><br><span class="line">isPriority[j] = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] == <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &lt;= <span class="number">3</span>)</span><br><span class="line">isPriority[j] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">boolean</span> a : isPriority)</span><br><span class="line"><span class="keyword">if</span> (a) res++;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-H-人物相关性分析-20分"><a href="#试题-H-人物相关性分析-20分" class="headerlink" title="试题 H: 人物相关性分析(20分)"></a>试题 H: 人物相关性分析(20分)</h1><p>小明正在分析一本小说中的人物相关性。他想知道在小说中 Alice 和 Bob 有多少次同时出现。 更准确的说，小明定义 Alice 和 Bob“同时出现”的意思是：在小说文本 中 Alice 和 Bob 之间不超过 K 个字符。 例如以下文本： ThisisastoryaboutAliceandBob.AlicewantstosendaprivatemessagetoBob. 假设 K = 20，则 Alice 和 Bob 同时出现了 2 次，分别是”Alice and Bob” 和”Bob. Alice”。前者 Alice 和 Bob 之间有 5 个字符，后者有 2 个字符。 注意: 1. Alice 和 Bob 是大小写敏感的，alice 或 bob 等并不计算在内。 2. Alice 和 Bob 应为单独的单词，前后可以有标点符号和空格，但是不能 有字母。例如 Bobbi 並不算出现了 Bob。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 K。 第二行包含一行字符串，只包含大小写字母、标点符号和空格。长度不超过 1000000。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示 Alice 和 Bob 同时出现的次数。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><p>20<br>This is a story about Alice and Bob.Alice wants to send a private message to Bob.</p><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p><h2 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，1≤ K ≤1000000。</p><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><p>分别创建两个一维数组Alice和Bob 用来存储Alice和Bob在文章中出现的位置<br>需要判断Alice和Bob前后的字符不为字母<br>Alice[i]表示 第i个Alice出现的位置是Alice[i]<br>我们只需要判断在 (Alice[i]-K-3,Alice[i]+5+K)这个区间内出现了多少个Bob即可<br>使用双指针<br>依次遍历Bob的索引值<br>Left指针记录上述区间内的第一个Bob的索引值Bob[left]<br>Right指针记录上述区间内的最后一个Bob的索引值Bob[right]<br>然后我们用right-left就是当前区间内的Bob数</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> K;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String text;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">K = in.nextInt();</span><br><span class="line">in.nextLine();</span><br><span class="line">text = in.nextLine();</span><br><span class="line">length = text.length();</span><br><span class="line"><span class="keyword">int</span>[] Alice = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span>[] Bob = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IsLetter(x - <span class="number">1</span>) &amp;&amp; !IsLetter(x + <span class="number">5</span>) &amp;&amp; text.startsWith(<span class="string">&quot;Alice&quot;</span>, x))</span><br><span class="line">Alice[count1++] = x;</span><br><span class="line"><span class="keyword">if</span> (!IsLetter(x - <span class="number">1</span>) &amp;&amp; !IsLetter(x + <span class="number">3</span>) &amp;&amp; text.startsWith(<span class="string">&quot;Bob&quot;</span>, x))</span><br><span class="line">Bob[count2++] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count1 == <span class="number">0</span> || count2 == <span class="number">0</span>)</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; count1; x++) &#123;</span><br><span class="line"><span class="keyword">while</span> (right &lt; count2 &amp;&amp; Bob[right] &lt;= Alice[x] + K + <span class="number">5</span>)</span><br><span class="line">right++;</span><br><span class="line"><span class="keyword">while</span> (Bob[left] + <span class="number">3</span> + K &lt; Alice[x])</span><br><span class="line">left++;</span><br><span class="line">result += right - left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsLetter</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= length)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">char</span> charAt = text.charAt(index);</span><br><span class="line"><span class="keyword">return</span> (charAt &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; charAt &lt;= <span class="string">&#x27;z&#x27;</span>) || (charAt &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; charAt &lt;= <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-I-后缀表达式-25分"><a href="#试题-I-后缀表达式-25分" class="headerlink" title="试题 I: 后缀表达式(25分)"></a>试题 I: 后缀表达式(25分)</h1><p>给定 N 个加号、M 个减号以及 N + M + 1 个整数 A1,A2,··· ,AN+M+1，小 明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？<br>请你输出这个最大的结果。 例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 N 和 M。 第二行包含 N + M + 1 个整数 A1,A2,··· ,AN+M+1。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，代表答案。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><p>1 1 1 2 3</p><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p><h2 id="评测用例规模与约定-3"><a href="#评测用例规模与约定-3" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，0≤ N,M ≤100000，−10^9 ≤ Ai ≤10^9。</p><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><p>分类讨论</p><ol><li>没有负号<br>没有负号就直接把所有数加起来 就是结果</li><li>有负号<br>只要有一个负号 就能把所有的负数变成正数</li></ol><ul><li>如果数字都是正数 那就用这些正数之和 减去一个最小的正数 —&gt; 最大数-最小数+剩余正数之和</li><li>如果数字都是负数 那就用最大的负数 减去剩余所有负数之和 —&gt; 最大数-最小数-剩余负数之和=最大数-最小数+剩余数的绝对值</li><li>如果有正有负 最大的整数-最小的负数+剩余数的绝对值之和(一个负号可以把所有数变成正数 减去负数等于加上正数)<br>总结一下就是 排序之后，最大数-最小数 然后和其他数的绝对值全部相加。<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + m + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m + <span class="number">1</span>; i++)</span><br><span class="line">arr[i] = sc.nextInt();</span><br><span class="line"><span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">res += i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> ans = arr[arr.length - <span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + m; i++)</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt;= <span class="number">0</span>) res += arr[i];</span><br><span class="line"><span class="keyword">else</span> res -= arr[i];</span><br><span class="line">res += ans;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="试题-J：灵能传输-25分"><a href="#试题-J：灵能传输-25分" class="headerlink" title="试题 J：灵能传输(25分)"></a>试题 J：灵能传输(25分)</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。</p><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是 i−1、i + 1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai &lt; 0 则其两旁的高阶圣堂武士， 也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。形 式化来讲就是 ai−1+ = ai,ai+1+ = ai,ai−= 2ai。 </p><p>灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxn i=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。 接下来一行包含 n 个数 a1,a2,··· ,an。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 T 行。每行一个整数依次表示每组询问的答案。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><p>3<br>3<br>5 -2 3<br>4<br>0 0 0 0<br>3<br>1 2 3</p><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><p>3<br>0<br>3</p><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>对于第一组询问：<br>对 2 号高阶圣堂武士进行传输操作后 a1 = 3，a2 = 2，a3 = 1。答案为 3。<br>对于第二组询问：<br>这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><p>3<br>4<br>-1 -2 -3 7<br>4<br>2 3 4 -8<br>5<br>-1 -1 6 -1 -1</p><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><p>5<br>7<br>4</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><p>见文件trans3.in。</p><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><p>见文件trans3.ans。</p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于所有评测用例，T ≤3，3≤n≤300000，|ai|≤10^9。<br>评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：<br><img src="https://img-blog.csdnimg.cn/20190415193901701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA2OTE0MA==,size_16,color_FFFFFF,t_70" alt=""><br>注意：本题输入量较大请使用快速的读入方式。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2022/03/20/BackTracking/"/>
      <url>/2022/03/20/BackTracking/</url>
      
        <content type="html"><![CDATA[<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：n = 4, k = 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：n = 1, k = 1<br>输出：[[1]]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= n &lt;= 20<br>1 &lt;= k &lt;= n</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>图源：<a href="https://leetcode-cn.com/u/liweiwei1419/">力扣liweiwei1419</a><br>抽象成树形结构<br><img src="https://pic.leetcode-cn.com/1599488203-TzmCXb-image.png" alt=""><br>用一个名为path的双端队列来存储我们所需要的的组合<br>当我们path的长度 等于 k 的长度时<br>也就是满足了k个数的组合的条件 将此时满足条件的path加入到结果中<br>然后我们回溯 将path的最后一个元素移除 并重复这个过程<br>由于每个数字只能用一次 所以递归时startIndex的参数值设为i+1<br><a href="https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">优质题解</a></p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">backTracking(n, k, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">path.offer(i);</span><br><span class="line">backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iii/">https://leetcode-cn.com/problems/combination-sum-iii/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 = 7<br>没有其他符合的组合了。</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 = 9<br>1 + 3 + 5 = 9<br>2 + 3 + 4 = 9<br>没有其他符合的组合了。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: k = 4, n = 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>2 &lt;= k &lt;= 9<br>1 &lt;= n &lt;= 60</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>每个数字只能用一次 跟上题一样 递归时startIndex的参数值设为i+1<br><img src="https://pic.leetcode-cn.com/133c024217fc0a415d92eb397787e791654dac7f225f57e0358dab95112c06f3-image.png" alt=""><br>还是画出树状结构 做减法 减到0即说明找到了符合条件的path值<br>如果减到负数就直接剪枝 当前分支只会越减越小 不可能为0了</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">backTracking(k, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (path.size() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">path.offer(i);</span><br><span class="line">backTracking(k, n - i, i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt=""></p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：digits = “”<br>输出：[]</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= digits.length &lt;= 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>创建一个长度为10的字符串数组 用来存储’0’ - ‘9’ 按键的对应字母值<br>把’0’和’1’对应的字符串设置为空字符串<br>设置一个num变量 用来表示遍历到digits中的第几个数字了<br>当num == digits.length()时 即找到一种组合 将其加入到结果列表中<br>然后我们就能根据digits中对应的数字顺序 依次遍历digits每个数字对应的字母值</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">StringBuffer path = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits.length()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">String[] nums = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">backTracking(digits, nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String digits, String[] nums, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num==digits.length())&#123;</span><br><span class="line">res.add(path.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String str = nums[digits.charAt(num)-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">path.append(str.charAt(i));</span><br><span class="line">backTracking(digits,nums,num+<span class="number">1</span>);</span><br><span class="line">path.deleteCharAt(path.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p><h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: candidates = [2], target = 1<br>输出: []</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都 互不相同<br>1 &lt;= target &lt;= 500</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>还是做减法 画出树状图<br>每个数字可以重复选取 所以递归的startIndex的参数值设为i<br>剪枝方法和之前一样 当target &lt; 0 时直接剪枝<br>当target == 0时 将当前路径加入到结果列表中</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">backTracking(candidates, target,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">path.offer(candidates[i]);</span><br><span class="line">backTracking(candidates, target - candidates[i],i);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii/">https://leetcode-cn.com/problems/combination-sum-ii/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。<br>注意：解集不能包含重复的组合。 </p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: candidates = [2,5,2,1,2], target = 5,<br>输出:<br>[<br>[1,2,2],<br>[5]<br>]</p><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= candidates.length &lt;= 100<br>1 &lt;= candidates[i] &lt;= 50<br>1 &lt;= target &lt;= 30</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>由于待选数组有重复值<br>先将待选数组排序<br>画出树状图<br>剪枝方法：避免同层选相同元素 这样会产生顺序不同的path结果<br>代码：if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1]) continue;<br><img src="https://pic.leetcode-cn.com/1599718525-iXEiiy-image.png" alt=""></p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Arrays.sort(candidates);</span><br><span class="line">backTracking(candidates, target, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">path.offer(candidates[i]);</span><br><span class="line">backTracking(candidates, target - candidates[i], i+<span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希去重</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">HashSet&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Arrays.sort(candidates);</span><br><span class="line">backTracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">set.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>( i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">path.offer(candidates[i]);</span><br><span class="line">backTracking(candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [0]<br>输出：[[],[0]]</p><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 10<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有元素 互不相同</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>不能选重复元素 所以递归中startIndex的参数值设为i+1<br>遍历到的每一个节点都是子集 不需要return;结束方法 </p><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">backTracking(nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">path.offer(nums[i]);</span><br><span class="line">backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets-ii/">https://leetcode-cn.com/problems/subsets-ii/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p><h2 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [0]<br>输出：[[],[0]]</p><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 10<br>-10 &lt;= nums[i] &lt;= 10</p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>待选数组中有重复元素 所以去重方法和 组合总和II 一样 先将待排数组排序<br>    if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1]) continue;<br>不能选重复元素 所以startIndex参数值设为i+1</p><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">backTracking(nums, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">path.offer(nums[i]);</span><br><span class="line">backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/increasing-subsequences/">https://leetcode-cn.com/problems/increasing-subsequences/</a></p><h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。<br>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><h2 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [4,6,7,7]<br>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</p><h2 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [4,4,3,2,1]<br>输出：[[4,4]]</p><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 15<br>-100 &lt;= nums[i] &lt;= 100</p><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><p>待排数组中有重复元素 但是这次又不能排序<br>分类讨论<br>每次遍历时 当path.size&gt;=2时  加入到结果数组中<br>当path中没有元素时 直接将当前元素加入<br>当path中有元素时 需判断当前元素是否大于末尾元素<br>否则跳过当前循环</p><h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">HashSet&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">backTracking(nums, <span class="number">0</span>);</span><br><span class="line">res.addAll(set);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>)</span><br><span class="line">set.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (path.size() == <span class="number">0</span>)</span><br><span class="line">path.add(nums[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt;= path.getLast())</span><br><span class="line">path.add(nums[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">backTracking(nums, i + <span class="number">1</span>);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><h2 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><h2 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p><h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：nums = [1]<br>输出：[[1]]</p><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 6<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><p>当path长度等于数组长度时 将当前path加入到结果中<br>无脑遍历即可 如果path中包含当前元素 直接跳过</p><h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">backTracking(nums);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (path.contains(num)) <span class="keyword">continue</span>;</span><br><span class="line">path.offer(num);</span><br><span class="line">backTracking(nums);</span><br><span class="line">path.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><h2 id="问题叙述-9"><a href="#问题叙述-9" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><h2 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p><h2 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 8<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p><h2 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h2><p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">看这篇题解就好啦</a></p><h2 id="代码提交-9"><a href="#代码提交-9" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"><span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">backTracking(nums,used);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">path.offer(nums[i]);</span><br><span class="line">used[i] = <span class="keyword">true</span>;</span><br><span class="line">backTracking(nums, used);</span><br><span class="line">path.removeLast();</span><br><span class="line">used[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一届蓝桥杯省赛 Java--B组</title>
      <link href="/2022/03/18/LanqiaoCup02/"/>
      <url>/2022/03/18/LanqiaoCup02/</url>
      
        <content type="html"><![CDATA[<h1 id="试题-A-门牌制作-5分"><a href="#试题-A-门牌制作-5分" class="headerlink" title="试题 A: 门牌制作(5分)"></a>试题 A: 门牌制作(5分)</h1><p>小蓝要为一条街的住户制作门牌号。<br>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。<br>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字<br>符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、 0、 1、 7，即需要 1 个<br>字符 0， 2 个字符 1， 1 个字符 7。<br>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>把每个数字转化成字符数组形式 依次遍历每个字符数组 遇到’2’则计数+1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line"><span class="keyword">char</span>[] ch = (i+<span class="string">&quot;&quot;</span>).toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c: ch) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：624</span></span><br></pre></td></tr></table></figure><h1 id="试题-B-寻找-2020-5分"><a href="#试题-B-寻找-2020-5分" class="headerlink" title="试题 B: 寻找 2020(5分)"></a>试题 B: 寻找 2020(5分)</h1><p>小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找<br>到这个数字矩阵中有多少个 2020 。<br>小蓝只关注三种构成 2020 的方式：<br>• 同一行里面连续四个字符从左到右构成 2020。<br>• 同一列里面连续四个字符从上到下构成 2020。<br>• 在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。<br>例如，对于下面的矩阵：<br>220000<br>000000<br>002202<br>000000<br>000022<br>002020<br>一共有 5 个 2020。其中 1 个是在同一行里的， 1 个是在同一列里的， 3 个<br>是斜线上的。<br>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一<br>个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。<br>请帮助小蓝确定在他的矩阵中有多少个 2020。</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[][] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//这里是一个小技巧</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">arr[i] = scan.nextLine().toCharArray();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//横向判断 注意j不要越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">3</span> &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i][j + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i][j + <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i][j + <span class="number">3</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纵向判断 注意i不要越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">3</span> &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">1</span>][j] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i + <span class="number">2</span>][j] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">3</span>][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//斜向判断 注意i和j不要越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">3</span> &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">3</span> &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">1</span>][j + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i + <span class="number">2</span>][j + <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">3</span>][j + <span class="number">3</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于没有数据 只能拿案例数据测试 </span></span><br></pre></td></tr></table></figure><h1 id="试题-C-蛇形填数-10分"><a href="#试题-C-蛇形填数-10分" class="headerlink" title="试题 C: 蛇形填数(10分)"></a>试题 C: 蛇形填数(10分)</h1><p>如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。<br><img src="https://img-blog.csdnimg.cn/20210117152841412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY0MDI2MA==,size_16,color_FFFFFF,t_70" alt=""><br>容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列 的数是多少？</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>第n行第n列前面有 2 <em> (n - 1) 行<br>第20行第20列前面有 38 行<br>38行对应的元素个数为 (1+38)</em>38/2 = 741个<br>在加上当前斜行的20个<br>答案为 761</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println((<span class="number">1</span> + <span class="number">38</span>) * <span class="number">38</span> / <span class="number">2</span> + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="试题-D-七段码-10分"><a href="#试题-D-七段码-10分" class="headerlink" title="试题 D: 七段码(10分)"></a>试题 D: 七段码(10分)</h1><p>小蓝要用七段码数码管来表示一种特殊的文字。<br><img src="https://img-blog.csdnimg.cn/20210117153800488.png" alt=""><br>上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。<br>小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。</p><p>例如： b 发光，其他二极管不发光可以用来表达一种字符。<br>例如： c 发光，其他二极管不发光可以用来表达一种字符。这种 方案与上 一行的方案可以用来表示不同的字符，尽管看上去比较相似。<br>例如： a, b, c, d, e 发光， f, g 不发光可以用来表达一种字符。<br>例如： b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光 的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><h1 id="试题-E-排序-15分"><a href="#试题-E-排序-15分" class="headerlink" title="试题 E: 排序(15分)"></a>试题 E: 排序(15分)</h1><p>小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。在冒泡排序中，每次只能交换相邻的两个元素。<br>小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。<br>例如，对于字符串 lan 排序，只需要 1 次交换。对于字符串 qiao 排序，总共需要 4 次交换。<br>小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100 次交换，可是他忘了吧这个字符串记下来，现在找不到了。<br>请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对该串的字符排序，正好需要 100 次交换。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。请注意字符串中不可以包含相同的字符。</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>cba这个例子 a需要交换两次 b需要交换1次 总共为2 + 1 = 3次<br>gfedcba这个例子 则需要6 + 5 + 4 + 3 + 2 + 1 = 21次<br>易知：14 + 13 + ··· + 1 = 105次<br>onmlkjihgfedcba这个序列需要15次 需要少交换五次 那我们将倒数第六位的字母放到第一位 就可以少交换5次<br>所以序列应该为 jonmlkihgfedcba<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="试题-F-成绩分析-15分"><a href="#试题-F-成绩分析-15分" class="headerlink" title="试题 F: 成绩分析(15分)"></a>试题 F: 成绩分析(15分)</h1><p>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是 一个 0 到 100 的整数。<br>请计算这次考试的最高分、最低分和平均分。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数 n，表示考试人数。 接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出三行。<br>第一行包含一个整数，表示最高分。<br>第二行包含一个整数，表示最低分。<br>第三行包含一个实数，四舍五入保留正好两位小数，表示平均分。</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>送分题</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n=scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i]=scan.nextInt();</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max) max=arr[i];</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;min) min=arr[i];</span><br><span class="line">sum+=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg=sum/n;</span><br><span class="line">System.out.println(max);</span><br><span class="line">System.out.println(min);</span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f&quot;</span>,avg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-G-单词分析-20分"><a href="#试题-G-单词分析-20分" class="headerlink" title="试题 G: 单词分析(20分)"></a>试题 G: 单词分析(20分)</h1><p>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不 住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得 最多来分辨单词。<br>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行包含一个单词，单词只由小写英文字母组成。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。<br>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>lanqiao</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>a<br>2</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>longlonglongistoolong</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>o<br>6</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有的评测用例，输入的单词长度不超过 1000。</p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>哈希<br>创建一个长度为26的数组下标0~25依次对应’a’~’z’<br>找到下标最大的 用下标 + ‘a’ 转化成字符 即为频次最多的字母</p><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">Arrays.fill(arr,<span class="number">0</span>);</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">char</span>[] word=scan.next().toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">arr[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> max= Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max) &#123;</span><br><span class="line">max=arr[i];</span><br><span class="line">index=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println((<span class="keyword">char</span>)(index+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-H-数字三角形-20分"><a href="#试题-H-数字三角形-20分" class="headerlink" title="试题 H: 数字三角形(20分)"></a>试题 H: 数字三角形(20分)</h1><p><img src="https://img-blog.csdnimg.cn/2021011715523376.png" alt=""><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。 对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示答案。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><p>27</p><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><p>简单dp<br>往左下走和往右下走的次数相差不能超过1<br>那也就是走到最下面一层 只可能出现在中间<br>如果是奇数 则就是中间位置的值<br>如果是偶数 则是两个中间值中的最大值</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">dp[i][j] = scan.nextInt();</span><br><span class="line">dp[i][j] += Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(n % <span class="number">2</span> == <span class="number">1</span> ? dp[n][n / <span class="number">2</span> + <span class="number">1</span>] : Math.max(dp[n][n / <span class="number">2</span>], dp[n][n / <span class="number">2</span> + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-I-子串分值和-25分"><a href="#试题-I-子串分值和-25分" class="headerlink" title="试题 I: 子串分值和(25分)"></a>试题 I: 子串分值和(25分)</h1><p>对于一个字符串 S，我们定义 S 的分值 f(S) 为 S 中出现的不同的字符个 数。例如 f(”aba”) = 2，f(”abc”) = 3, f(”aaa”) = 1。 现在给定一个字符串 S[0…n−1]（长度为 n），请你计算对于所有 S 的非空 子串 S<a href="0≤i≤ j &lt; n">i…j</a>，f(S[i…j]) 的和是多少。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行包含一个由小写字母组成的字符串 S。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数表示答案。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><p>ababc</p><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>28</p><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>子串 f值<br>a 1<br>ab 2<br>aba 2<br>abab 2<br>ababc 3<br>b 1<br>ba 2<br>bab 2<br>babc 3<br>a 1<br>ab 2<br>abc 3<br>b 1<br>bc 2<br>c 1</p><h2 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 20% 的评测用例，1≤n≤10；<br>对于 40% 的评测用例，1≤n≤100；<br>对于 50% 的评测用例，1≤n≤1000；<br>对于 60% 的评测用例，1≤n≤10000；<br>对于所有评测用例，1≤n≤100000。</p><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><p>暴力骗分 可以通过60%的案例<br>两层循环 按照样例说明的那种样式遍历<br>创建一个HashSet来对字母去重<br>HashSet.size()就是当前子串的不同字符个数</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str = scan.next();</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str.length(); j++) &#123;</span><br><span class="line">set.add(str.charAt(j));</span><br><span class="line">sum+=set.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-J-装饰珠-25分"><a href="#试题-J-装饰珠-25分" class="headerlink" title="试题 J: 装饰珠(25分)"></a>试题 J: 装饰珠(25分)</h1><p>在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取相应的技能，以提升自己的战斗能力。<br>已知猎人身上一共有 6 件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠 (也可以选择不镶嵌)。<br>装饰珠有M种，编号1至M，分别对应M 种技能，第i种装饰珠的等级为Li，只能镶嵌在等级大于等于Li的装饰孔中。<br>对第i种技能来说，当装备相应技能的装饰珠数量达到Ki个时，会产生Wi(Ki) 的价值。镶嵌同类技能的数量越多，产生的价值越大，即Wi(Ki − 1) &lt; Wi(Ki) 。但每个技能都有上限Pi(1 ≤ P i ≤ 7) ，当装备的珠子数量超过Pi时，只会产生Wi(Pi) 的价值。<br>对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得 6 件装备能得到的总价值达到最大。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第1至6行，包含6件装备的描述。其中第i的第一个整数Ni表示<br>第i件装备的装饰孔数量。后面紧接着Ni个整数，分别表示该装备上每个装饰孔的等级L(1 ≤ L ≤ 4) 。<br>第7行包含一个正整数M，表示装饰珠 (技能) 种类数量。<br>第8至 M + 7行，每行描述一种装饰珠 (技能) 的情况。每行的前两个整数Lj(1 ≤ Lj ≤ 4)和Pj(1 ≤ Pi ≤ 7)分别表示第j种装饰珠的等级和上限。接下来Pj个整数，其中第k个数表示装备该中装饰珠数量为k时的价值 Wj(k)。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行包含一个整数，表示能够得到的最大价值。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><p>1 1<br>2 1 2<br>1 1<br>2 2 2<br>1 1<br>1 3<br>3<br>1 5 1 2 3 5 8<br>2 4 2 4 8 15<br>3 2 5 10</p><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><p>20</p><h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>按照如下方式镶嵌珠子得到最大价值 18，括号内表示镶嵌的装饰珠的种类编号：<br>1: (1)<br>2: (1) (2)<br>3: (1)<br>4: (2) (2)<br>5: (1)<br>6: (2)<br>4 颗技能 1 装饰珠，4 颗技能 2 装饰珠 W1(4) + W2(4) = 5 + 15 = 20。</p><h2 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 30% 的评测用例，1 ≤ Ni ≤ 10, 1 ≤ M ≤ 20, 1 ≤ Wj(k) ≤ 500；<br>对于所有评测用例，1 ≤ Ni ≤ 50, 1 ≤ M ≤ 10000, 1 ≤ Wj(k) ≤ 10000。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二届蓝桥杯省赛 Java--B组</title>
      <link href="/2022/02/21/LanqiaoCup/"/>
      <url>/2022/02/21/LanqiaoCup/</url>
      
        <content type="html"><![CDATA[<h1 id="试题-A-ASC（5分）"><a href="#试题-A-ASC（5分）" class="headerlink" title="试题 A: ASC（5分）"></a>试题 A: ASC（5分）</h1><h2 id="已知大写字母-A-的-ASCII-码为-65，请问大写字母-L-的-ASCII-码是多少？"><a href="#已知大写字母-A-的-ASCII-码为-65，请问大写字母-L-的-ASCII-码是多少？" class="headerlink" title="已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？"></a>已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？</h2><h2 id="答案：-76"><a href="#答案：-76" class="headerlink" title="答案： 76"></a><strong>答案：</strong> 76</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println((<span class="keyword">int</span>)<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-B-卡片（5分）"><a href="#试题-B-卡片（5分）" class="headerlink" title="试题 B: 卡片（5分）"></a>试题 B: 卡片（5分）</h1><p>小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。</p><p>小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个， 就保存起来，卡片就不能用来拼其它数了。</p><p>小蓝想知道自己能从 1 拼到多少。</p><p>例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10， 但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。</p><h2 id="现在小蓝手里有-0-到-9-的卡片各-2021-张，共-20210-张，请问小蓝可以从-1-拼到多少？"><a href="#现在小蓝手里有-0-到-9-的卡片各-2021-张，共-20210-张，请问小蓝可以从-1-拼到多少？" class="headerlink" title="现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？"></a>现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？</h2><h2 id="答案：-3181"><a href="#答案：-3181" class="headerlink" title="答案： 3181"></a><strong>答案：</strong> 3181</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是哈希<br>模拟一遍这个流程就好了<br>创建一个长度为10的数组 将数组中的每个元素初始化为2021 代表0~9 总共十种卡片 每种有2021张<br>然后将数字转化成字符串 字符串再转化成字符数组 遍历字符数组 将每个字符对应的卡片张数-1<br>当遍历完某个数字之后 卡片张数变为负数 则当前数字无法拼出来 输出当前数字的上一个数字即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] cards = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(cards, <span class="number">2021</span>);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line">String str = num + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : c) &#123;</span><br><span class="line">cards[ch - <span class="string">&#x27;0&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cards[ch - <span class="string">&#x27;0&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(num - <span class="number">1</span>);</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="试题-C-直线（10分）"><a href="#试题-C-直线（10分）" class="headerlink" title="试题 C: 直线（10分）"></a>试题 C: 直线（10分）</h1><p>在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上， 那么这些点中任意两点确定的直线是同一条。</p><p>给定平面上 2 × 3 个整点 {(x, y)|0 ≤ x &lt; 2, 0 ≤ y &lt; 3, x ∈ Z, y ∈ Z}，即横坐标 是 0 到 1 (包含 0 和 1) 之间的整数、纵坐标是 0 到 2 (包含 0 和 2) 之间的整数 的点。这些点一共确定了 11 条不同的直线。</p><p>给定平面上 20 × 21 个整点 {(x, y)|0 ≤ x &lt; 20, 0 ≤ y &lt; 21, x ∈ Z, y ∈ Z}，即横 坐标是 0 到 19 (包含 0 和 19) 之间的整数、纵坐标是 0 到 20 (包含 0 和 20) 之 间的整数的点。请问这些点一共确定了多少条不同的直线。</p><h2 id="答案：-40257"><a href="#答案：-40257" class="headerlink" title="答案： 40257"></a><strong>答案：</strong> 40257</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>直线的斜截式 y=kx+b 只要每条直线的k和b不同 那就不是同一条直线<br>由于涉及到小数问题 直接比较大小会出错 这里我才用保留八位有效数字<br>浮点数比较大小 只要差值小于1e-8 即可认为相等<br>新建一个Fx类和Point类<br>Point类用来存放每一个点，遍历Point集合，将任意两点组成直线的k和b计算出来，并存入res集合<br>Fx类用来记录每两个点产生直线的k和b 并将它存入sdt集合中去重 平行于X轴和Y轴的单独处理 最后加上就行</p><p>HashSet去重：先判断hashCode（）是否相同，相同才会判断equals()<br>如果是需要对我们自定义的对象去重，就需要我们重写 hashCode 和 equals 方法<br>注意：HashSet要求放入的对象<strong>必须重写hashCode()</strong>,不然HashSet<strong>调用默认的hashCode方法判断对象的地址</strong>，不等就达不到想根据对象的值去重的目的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;Fx&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">ArrayList&lt;Point&gt; point = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">21</span>; y++) &#123;</span><br><span class="line">point.add(<span class="keyword">new</span> Point(x, y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Point p1 : point) &#123;</span><br><span class="line"><span class="keyword">for</span> (Point p2 : point) &#123;</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">if</span> (p2.getY() == p1.getY() || p2.getX() == p1.getX())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">k = (p2.getY() - p1.getY()) / (p2.getX() - p1.getX());</span><br><span class="line">b = p2.getY() - k * p2.getX();</span><br><span class="line">res.add(<span class="keyword">new</span> Fx(k, b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res.size() + <span class="number">20</span> + <span class="number">21</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fx</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fx</span><span class="params">(<span class="keyword">double</span> k, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.00000000&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.k = Double.parseDouble(df.format(k));</span><br><span class="line"><span class="keyword">this</span>.b = Double.parseDouble(df.format(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Fx)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Fx fx = (Fx) o;</span><br><span class="line"><span class="keyword">return</span> Double.compare(fx.k, k) == <span class="number">0</span> &amp;&amp; Double.compare(fx.b, b) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hash(k, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="试题-D-货物摆放（10分）"><a href="#试题-D-货物摆放（10分）" class="headerlink" title="试题 D: 货物摆放（10分）"></a>试题 D: 货物摆放（10分）</h1><p>小蓝有一个超大的仓库，可以摆放很多货物。</p><p>现在，小蓝有 n 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝 规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、 宽、高。 小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上 分别堆 L、W、H 的货物，满足 n = L × W × H。</p><p>给定 n，请问有多少种堆放货物的方案满足要求。 例如，当 n = 4 时，有以下 6 种方案：1×1×4、1×2×2、1×4×1、2×1×2、 2 × 2 × 1、4 × 1 × 1。</p><h2 id="请问，当-n-2021041820210418-（注意有-16-位数字）时，总共有多少种方案？"><a href="#请问，当-n-2021041820210418-（注意有-16-位数字）时，总共有多少种方案？" class="headerlink" title="请问，当 n = 2021041820210418 （注意有 16 位数字）时，总共有多少种方案？"></a>请问，当 n = 2021041820210418 （注意有 16 位数字）时，总共有多少种方案？</h2><h2 id="答案：-2430"><a href="#答案：-2430" class="headerlink" title="答案： 2430"></a><strong>答案：</strong> 2430</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>计算出因数然后无脑暴力三重循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> num = <span class="number">2021041820210418L</span>;</span><br><span class="line">HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt; Math.sqrt(num); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">set.add(i);</span><br><span class="line">set.add(num / i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> a : set)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> b : set)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> c : set)</span><br><span class="line"><span class="keyword">if</span> (a * b * c == num)</span><br><span class="line">res++;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="试题-E-路径（15分）"><a href="#试题-E-路径（15分）" class="headerlink" title="试题 E: 路径（15分）"></a>试题 E: 路径（15分）</h1><p>小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。</p><p>小蓝的图由 2021 个结点组成，依次编号 1 至 2021。</p><p>对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。</p><p>例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。</p><h2 id="请计算，结点-1-和结点-2021-之间的最短路径长度是多少。"><a href="#请计算，结点-1-和结点-2021-之间的最短路径长度是多少。" class="headerlink" title="请计算，结点 1 和结点 2021 之间的最短路径长度是多少。"></a>请计算，结点 1 和结点 2021 之间的最短路径长度是多少。</h2><h2 id="答案：10266387"><a href="#答案：10266387" class="headerlink" title="答案：10266387"></a><strong>答案：</strong>10266387</h2><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>先按题目要求建图，将所有节点初始化为0x3f3f3f3f<br>(0x3f3f3f3f的十进制是1061109567,是10^9级别的,而一般场合下的数据都是小于10^9的,所以它可以作为无穷大使用)<br>两个节点的绝对值小于等于21 则求最小公倍数<br><strong>最小公倍数公式 lcm = a * b / (gcd(a, b))</strong><br>lcm是最小公倍数 gcd是最大公约数<br><strong>欧几里得法求最大公约数 gcd(a, b) = gcd(b, a % b)</strong><br>然后用弗洛伊德算法 求最短路径即可<br>(时间复杂度n^3 仅限填空题可以用用 编程题还是要用迪杰斯特拉算法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2030</span>][<span class="number">2030</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2021</span>; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i][j] &gt; arr[i][k] + arr[k][j])</span><br><span class="line">arr[i][j] = arr[i][k] + arr[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++)</span><br><span class="line">arr[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(i - j) &lt;= <span class="number">21</span>)</span><br><span class="line">arr[i][j] = i * j / gcd(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Floyd();</span><br><span class="line">System.out.println(arr[<span class="number">1</span>][<span class="number">2021</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题-F-时间限制（15分）"><a href="#试题-F-时间限制（15分）" class="headerlink" title="试题 F: 时间限制（15分）"></a>试题 F: 时间限制（15分）</h1><p>小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取 了当前的时间，用一个整数表示，值为从 1970 年 1 月 1 日 00:00:00 到当前时 刻经过的毫秒数。</p><p>现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要 显示出时分秒即可，毫秒也不用显示，直接舍去即可。</p><p>给定一个用整数表示的时间，请将这个时间对应的时分秒输出。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行包含一个整数，表示时间。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出时分秒表示的当前时间，格式形如 HH:MM:SS，其中 HH 表示时，值 为 0 到 23，MM 表示分，值为 0 到 59，SS 表示秒，值为 0 到 59。时、分、秒 不足两位时补前导 0。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 1"></a>样例输入 1</h2><p>46800999</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 1"></a>样例输出 1</h2><p>13:00:00</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 2"></a>样例输入 2</h2><p>1618708103123</p><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 2"></a>样例输出 2</h2><p>01:08:23</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，给定的时间为不超过10^18的正整数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">long</span> time = scan.nextLong();</span><br><span class="line">time = time / <span class="number">1000</span> % (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, time / <span class="number">3600</span>, time / <span class="number">60</span> % <span class="number">60</span>, time % <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-G-砝码称重（20分）"><a href="#试题-G-砝码称重（20分）" class="headerlink" title="试题 G: 砝码称重（20分）"></a>试题 G: 砝码称重（20分）</h1><p>你有一架天平和 N 个砝码，这 N 个砝码重量依次是 W1,W2,⋅⋅⋅,WN。</p><p>请你计算一共可以称出多少种不同的正整数重量？</p><p>注意砝码可以放在天平两边。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数：W1,W2,W3,⋅⋅⋅,WN。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数代表答案。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>3</p><p>1 4 6</p><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>10</p><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>能称出的 10 种重量是：1、2、3、4、5、6、7、9、10、11。<br>1 = 1；</p><p>2 = 6 − 4 (天平一边放 6，另一边放 4)；</p><p>3 = 4 − 1；</p><p>4 = 4；</p><p>5 = 6 − 1；</p><p>6 = 6；</p><p>7 = 1 + 6；</p><p>9 = 4 + 6 − 1；</p><p>10 = 4 + 6；</p><p>11 = 1 + 4 + 6。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 50% 的评测用例，1≤N≤15。</p><p>对于所有评测用例，1≤N≤100，N 个砝码总重不超过 100000。</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>网上看别的题解都用的是dp，我这里有个不用dp的方法<br>建立一个set集合 用来去重<br>我们先将第一个砝码a存入set集合<br>每个砝码只有三种情况 放左边 放右边 不放<br>那对于第二个砝码b 我们有 a+b a-b b 三种情况<br>我们把这三种情况的结果放入set<br>然后再用一个list集合遍历即可<br>每次放一个砝码之前 都将set集合中的结果 初始化到list集合中<br>用list集合中的每个元素，对砝码的三种情况进行计算，并放入set集合中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = scan.nextInt();</span><br><span class="line">ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b : tmp) &#123;</span><br><span class="line">set.add(b + a);</span><br><span class="line"><span class="keyword">if</span> (b != a) set.add(Math.abs(b - a));</span><br><span class="line">&#125;</span><br><span class="line">set.add(a);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(set.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="试题-H-杨辉三角形（20分）"><a href="#试题-H-杨辉三角形（20分）" class="headerlink" title="试题 H: 杨辉三角形（20分）"></a>试题 H: 杨辉三角形（20分）</h1><p><img src="https://img-blog.csdnimg.cn/2021041817585283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTk2Njg2,size_16,color_FFFFFF,t_70#pic_center" alt="杨辉三角"></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>杨辉三角的第i行第j个的数都是组合数C(i, j) （i，j从0开始）<br>C(n, 1) = n 对应斜着的第二行 也就是一定有解<br>由于杨辉三角左右对称C(a, b) == C(a, a-b)，又由于找第一次出现，因此一定在左边，右边不用看</p><pre><code>        1  ---&gt; C(0, 0)      1     1   2  ---&gt; C(2, 1)  1   3                             ---&gt; C(2n, n)1   4   6  ---&gt; C(4, 2)</code></pre><p>  1   5   10<br>1   6   15  20 —-&gt; C(6, 3)</p><p>题目范围上限1E9，C(34, 17) &gt; 1E9, C(32, 16) &lt; 1E9，因此只要枚举前16个斜行即可</p><ol><li>每个斜行是依次递增的C(n,m) m相同n越大 C(n,m)越大</li><li>每个横行从中间到两边是递减的<br>因此我们直接从中间对称轴倒序二分找起即可<br>C(r, k)对应的位置为：(r + 1) * r / 2 + k + 1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i--, j++) &#123;</span><br><span class="line">res = res * i / j;</span><br><span class="line">            <span class="comment">//组合数是一步一步算的 如果当前数值已经超过我们要寻找的值了 就没必要继续算下去了 再继续算下去可能会超过long能存储的数据范围</span></span><br><span class="line"><span class="keyword">if</span> (res &gt; target) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//对每一斜行进行二分查找 找到了就直接输出所在位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * line;<span class="comment">//左端点就是上面字符画的规律值</span></span><br><span class="line"><span class="keyword">int</span> right = target;<span class="comment">//右端点取最坏情况 例如要查找1E9 那只能在C(1000000000,1)找到</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (C(mid, line) &gt;= target) right = mid;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C(left, line) != target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">System.out.println((<span class="keyword">long</span>) right * (right + <span class="number">1</span>) / <span class="number">2</span> + line + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">target = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> line = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">while</span> (line-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (check(line))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题-I-双向排序（25分）"><a href="#试题-I-双向排序（25分）" class="headerlink" title="试题 I: 双向排序（25分）"></a>试题 I: 双向排序（25分）</h1><p><img src="https://img-blog.csdnimg.cn/20210429211716488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="双向排序"></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>暴力解法会超时 所以这个题还是要找规律的(<del>比赛肯定想不出来</del>)<br>如果有两个<strong>连续</strong>的指令都是让我们降序排序，比如0 3和0 5，那么0 3这条指令就不需要进行操作，我们只需要执行操作区间更大的0 5<br>{ 1 2 3 4 5 6 7 }<br>0 3<br>{ 3 2 1 4 5 6 7 }<br>0 5<br>{ 5 4 3 2 1 6 7 }</p><p>再观察一下下面的两个操作<br>{ 1 2 3 4 5 6 7 }<br>0 5<br>{ 5 4 3 2 1 6 7 }<br>1 4<br>{ 5 4 3 1 2 6 7 }<br>0 5的意义就是将[1, 5]这个区间进行降序操作，而一开始整个区间[1, 7]都是升序的,我们要让[1,5]降序，那就只需要取[1,7]和[1,5]的交集，然后翻转这个交集，显然这个交集就是[1, 5]，翻转[1, 5]，于是我们得到了一个降序的[1, 5]区间，1 4的意义就是将[4, 7]这个区间进行升序操作，而最右边的区间[6, 7]已经是升序的了，并且里面所有的数字都比它们左边所有的数字都要大，<strong>所以[6, 7]区间的数字并不会变化，</strong>我们只需要接着取交集，取[1, 5]和[4, 7]的交集，得到一个[4, 5]的区间，翻转[4, 5]就是我们最终的答案。<br>要是上面两个操作之后，突然出现一个0 7的指令怎么办 显然执行0 7会覆盖之前两步的操作<br>所以不是连续的0操作最大就行了 而是要让后面比较大的0操作 <strong>覆盖掉之前操作区间所有比它小的操作</strong> 其间的1和0操作都会因为这个比较大的0操作而变得无效<br>经过上述这两步 我们就可以去掉很多无效操作 只保留有效操作 将这些有效操作入栈<br>栈维护出来之后，区间外部的东西就永远都不会动了，所以只需要一边缩区间一边填数字就行了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">static</span> PII[] stk = <span class="keyword">new</span> PII[N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">n = sc.nextInt();</span><br><span class="line">m = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> q = sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//求出连续操作的最长前缀</span></span><br><span class="line"><span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; stk[top].x == <span class="number">0</span>) q = Math.max(q, stk[top -- ].y);</span><br><span class="line"><span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; stk[top - <span class="number">1</span>].y &lt;= q) top -= <span class="number">2</span>;</span><br><span class="line">stk[ ++ top] = <span class="keyword">new</span> PII(<span class="number">0</span>, q);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//求出连续操作的最长后缀</span></span><br><span class="line"><span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; stk[top].x == <span class="number">1</span>) q = Math.min(q, stk[top --].y);</span><br><span class="line"><span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; stk[top - <span class="number">1</span>].y &gt;= q) top -= <span class="number">2</span>;</span><br><span class="line">stk[ ++ top] = <span class="keyword">new</span> PII(<span class="number">1</span>, q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//k是递减变量，l为左边界，r为右边界</span></span><br><span class="line"><span class="keyword">int</span> k = n, l = <span class="number">1</span>, r = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (stk[i].x == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//若为前缀操作，则(stk[i].y, r]不用操作，直接填数</span></span><br><span class="line"><span class="keyword">while</span> (r &gt; stk[i].y &amp;&amp; l &lt;= r) ans[r -- ] = k --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若为后缀操作，则[l, stk[i].y)不用操作，直接填数</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; stk[i].y &amp;&amp; l &lt;= r) ans[l ++ ] = k --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若l &lt; r, 表示中间还有些数没有填上，操作次数为奇数，则下一次操作为前缀操作</span></span><br><span class="line"><span class="keyword">if</span> (top % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) ans[l ++ ] = k --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) ans[r -- ] = k --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) System.out.print(ans[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PII</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PII</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力骗分能通过60%的案例</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">arr[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> split = scan.nextInt();</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">Arrays.sort(arr, <span class="number">0</span>, split, (o1, o2) -&gt; o2 - o1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Arrays.sort(arr, split - <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="试题-J-括号序列（25分）"><a href="#试题-J-括号序列（25分）" class="headerlink" title="试题 J: 括号序列（25分）"></a>试题 J: 括号序列（25分）</h1><p><img src="https://img-blog.csdnimg.cn/2021041817594584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTk2Njg2,size_16,color_FFFFFF,t_70#pic_center" alt="括号序列"></p><hr><p>摆烂了 有空再说</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/02/15/BinaryTree/"/>
      <url>/2022/02/15/BinaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[1,2,3]</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt=""><br>输入：root = [1,2]<br>输出：[1,2]</p><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt=""><br>输入：root = [1,null,2]<br>输出：[1,2]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>往左下走到头  无路可走的时候弹栈 往右走一步 继续往左走到头</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">pre(list, root);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">list.add(node.val);</span><br><span class="line">pre(list, node.left);</span><br><span class="line">pre(list, node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">res.add(root.val);</span><br><span class="line">stack.push(root);</span><br><span class="line">root = root.left;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode tmp = stack.poll();</span><br><span class="line">root = tmp.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[1,3,2]</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p><h2 id="示例-4-1"><a href="#示例-4-1" class="headerlink" title="示例 4"></a>示例 4</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt=""><br>输入：root = [1,2]<br>输出：[2,1]</p><h2 id="示例-5-1"><a href="#示例-5-1" class="headerlink" title="示例 5"></a>示例 5</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt=""><br>输入：root = [1,null,2]<br>输出：[1,2]</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>迭代算法和之前的前序遍历差不多</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">inorder(root, list);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">inorder(root.left, list);</span><br><span class="line">list.add(root.val);</span><br><span class="line">inorder(root.right, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(root);</span><br><span class="line">root = root.left;</span><br><span class="line">&#125;</span><br><span class="line">root = stack.poll();</span><br><span class="line">res.add(root.val);</span><br><span class="line">root = root.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵二叉树的根节点 root ，返回其节点值的后序遍历 。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt=""><br>输入：root = [1,null,2,3]<br>输出：[3,2,1]</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：[1]</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="进阶-2"><a href="#进阶-2" class="headerlink" title="进阶"></a>进阶</h2><p>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>迭代算法几乎和前序遍历一模一样 前序遍历是按照 中左右遍历，那后序遍历我们按照 中右左 再逆序即可</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">postorder(root, list);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">postorder(root.left, list);</span><br><span class="line">postorder(root.right, list);</span><br><span class="line">list.add(root.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">res.add(root.val);</span><br><span class="line">stack.push(root);</span><br><span class="line">root = root.right;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode tmp = stack.poll();</span><br><span class="line">root = tmp.left;</span><br><span class="line">&#125;</span><br><span class="line">Collections.reverse(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p><h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [1]<br>输出：[[1]]</p><h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>一层一层模拟<br>首先先将根节点加入到队列中<br>将每一层的元素入队后，记录队列中的元素个数(levelCount)<br>新建一个列表，将该层所有节点出队，每个节点出队的同时，将它的子节点入队<br>这样能保证每次遍历时，队列中的元素个数是每一层的元素个数<br>将这个列表添加到结果列表中<br>往复进行这个操作，直到队为空</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学会层序遍历之后，下面的十道题都可以通杀</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line">list.add(tmp.val);</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [1]<br>输出：[[1]]</p><h2 id="示例-3-4"><a href="#示例-3-4" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>在上题的代码上加一行逆序即可</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line">list.add(tmp.val);</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line">Collections.reverse(res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。<br>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt=""><br>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p><h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""><br>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>跟层序遍历的区别只有判断子节点是否为空</p><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">Node tmp = deque.pollFirst();</span><br><span class="line">list.add(tmp.val);</span><br><span class="line"><span class="keyword">for</span> (Node child : tmp.children) &#123;</span><br><span class="line"><span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">deque.offer(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt=""><br>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p><h2 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: [1,null,3]<br>输出: [1,3]</p><h2 id="示例-3-5"><a href="#示例-3-5" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: []<br>输出: []</p><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;= Node.val &lt;= 100 </p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>遍历到每层最后一个元素时，将它加入结果集合即可</p><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"><span class="keyword">if</span> (i == size - <span class="number">1</span>)</span><br><span class="line">res.add(tmp.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p><h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><h2 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。</p><h2 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt=""><br>输入：root = [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>树中节点数量在 [1, 10^4] 范围内<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1</p><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><p>一层一层遍历时，用一个变量对当前层的元素求和，再除以size，得到平均值，加入到结果集合中</p><h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line">sum += tmp.val;</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(sum / size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><p>每当遍历一层的时候 深度加一即可</p><h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line">depth++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h2 id="问题叙述-9"><a href="#问题叙述-9" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p><h2 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：2</p><h2 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [2,null,3,null,4,null,5,null,6]<br>输出：5</p><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>树中节点数的范围在 [0, 10^5] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h2><p>题目中说 最小深度是从根节点到最近叶子节点的最短路径上的节点数量<br>而叶子节点是指没有子节点的节点<br>跟最大深度类似 每当遍历一层的时候 深度加一<br>所以我们一层一层遍历 找到一个叶子节点的时候 返回它的深度即可</p><h2 id="代码提交-9"><a href="#代码提交-9" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line">depth++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"><span class="keyword">if</span> (tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p><h2 id="问题叙述-10"><a href="#问题叙述-10" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt=""><br>输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入: root = [1,2,3]<br>输出: [1,3]</p><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1</p><h2 id="思路分析-10"><a href="#思路分析-10" class="headerlink" title="思路分析"></a>思路分析</h2><p>遍历每一层的时候 实时更新一下最大值即可</p><h2 id="代码提交-10"><a href="#代码提交-10" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.add(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.poll();</span><br><span class="line">max = Math.max(max, tmp.val);</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.add(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.add(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p><h2 id="问题叙述-11"><a href="#问题叙述-11" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p><h2 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt=""><br>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p><h2 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：[]</p><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数量在 [0, 2^12 - 1] 范围内<br>-1000 &lt;= node.val &lt;= 1000</p><h2 id="进阶-3"><a href="#进阶-3" class="headerlink" title="进阶"></a>进阶</h2><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h2 id="思路分析-11"><a href="#思路分析-11" class="headerlink" title="思路分析"></a>思路分析</h2><p>每个元素出队的时候 让它的next指向队首元素即可 遍历到末尾元素时 让它指向null</p><h2 id="代码提交-11"><a href="#代码提交-11" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">Node tmp = deque.pollFirst();</span><br><span class="line"><span class="keyword">if</span> (i == size - <span class="number">1</span>) tmp.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> tmp.next = deque.peek();</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p><h2 id="问题叙述-12"><a href="#问题叙述-12" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树</p><p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><h2 id="进阶-4"><a href="#进阶-4" class="headerlink" title="进阶"></a>进阶</h2><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt=""><br>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。</p><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p><h2 id="思路分析-12"><a href="#思路分析-12" class="headerlink" title="思路分析"></a>思路分析</h2><p>跟上题的代码一模一样</p><h2 id="代码提交-12"><a href="#代码提交-12" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;Node&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">Node tmp = deque.pollFirst();</span><br><span class="line"><span class="keyword">if</span> (i == size - <span class="number">1</span>) tmp.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> tmp.next = deque.peek();</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><h2 id="问题叙述-13"><a href="#问题叙述-13" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><h2 id="示例-1-10"><a href="#示例-1-10" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt=""><br>输入：root = [1,2,3,4,5,6]<br>输出：6</p><h2 id="示例-2-10"><a href="#示例-2-10" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = []<br>输出：0</p><h2 id="示例-3-6"><a href="#示例-3-6" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1]<br>输出：1</p><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目范围是[0, 5 <em> 10^4]<br>0 &lt;= Node.val &lt;= 5 </em> 10^4<br>题目数据保证输入的树是 完全二叉树</p><h2 id="进阶-5"><a href="#进阶-5" class="headerlink" title="进阶"></a>进阶</h2><p>遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p><h2 id="思路分析-13"><a href="#思路分析-13" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-13"><a href="#代码提交-13" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line">list.add(tmp.val);</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.offer(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.offer(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h2 id="问题叙述-14"><a href="#问题叙述-14" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h2 id="示例-1-11"><a href="#示例-1-11" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt=""><br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><h2 id="示例-2-11"><a href="#示例-2-11" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt=""><br>输入：root = [2,1,3]<br>输出：[2,3,1]</p><h2 id="示例-3-7"><a href="#示例-3-7" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = []<br>输出：[]</p><h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目范围在 [0, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="思路分析-14"><a href="#思路分析-14" class="headerlink" title="思路分析"></a>思路分析</h2><p>层序遍历时 交换每个节点两个子节点即可</p><h2 id="代码提交-14"><a href="#代码提交-14" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = deque.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode tmp = deque.pollFirst();</span><br><span class="line">swapNode(tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) deque.push(tmp.left);</span><br><span class="line"><span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) deque.push(tmp.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">TreeNode tmp = root.left;</span><br><span class="line">root.left = root.right;</span><br><span class="line">root.right = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">TreeNode tmp;</span><br><span class="line">tmp = root.left;</span><br><span class="line">root.left = root.right;</span><br><span class="line">root.right = tmp;</span><br><span class="line">invertTree(root.left);</span><br><span class="line">invertTree(root.right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h2 id="问题叙述-15"><a href="#问题叙述-15" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><h2 id="示例-1-12"><a href="#示例-1-12" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt=""><br>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p><h2 id="示例-2-12"><a href="#示例-2-12" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt=""><br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><h2 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h2><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="思路分析-15"><a href="#思路分析-15" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们可以利用双端队列的特性 把他当成两个队列用<br>比较左右两边的节点是否对称 那我们把左边的节点从对头插入 右边的节点从队尾插入<br>节点入队的时候也要按对称的顺序</p><h2 id="代码提交-15"><a href="#代码提交-15" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offerFirst(root.left);</span><br><span class="line">deque.offerLast(root.right);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">TreeNode left = deque.pollFirst();</span><br><span class="line">TreeNode right = deque.pollLast();</span><br><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">deque.offerFirst(left.left);</span><br><span class="line">deque.offerFirst(left.right);</span><br><span class="line">deque.offerLast(right.right);</span><br><span class="line">deque.offerLast(right.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CompareNode(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">CompareNode</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> p.val == q.val &amp;&amp; CompareNode(p.left, q.right) &amp;&amp; CompareNode(p.right, q.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h2 id="问题叙述-16"><a href="#问题叙述-16" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt=""><br>输入：root = [3,9,20,null,null,15,7]<br>输出：true</p><h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt=""><br>输入：root = [1,2,2,3,3,null,null,4,4]<br>输出：false</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：root = []<br>输出：true</p><h2 id="提示-15"><a href="#提示-15" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数在范围 [0, 5000] 内<br>-10^4 &lt;= Node.val &lt;= 10^4</p><h2 id="思路分析-16"><a href="#思路分析-16" class="headerlink" title="思路分析"></a>思路分析</h2><p>对于当前遍历到的节点，先遍历它的左右子树是否平衡，再判断以当前节点为根节点的子树是否平衡，如果平衡，则返回它的高度，不平衡则返回-1(高度如果存在则必然大于等于0)，如果左子树或右子树有一个不平衡，或者左右子树高度差大于1，则整棵二叉树不平衡</p><h2 id="代码提交-16"><a href="#代码提交-16" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left_Height = height(root.left);</span><br><span class="line"><span class="keyword">int</span> right_Height = height(root.right);</span><br><span class="line"><span class="keyword">if</span> (left_Height == -<span class="number">1</span> || right_Height == -<span class="number">1</span> || Math.abs(left_Height - right_Height) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + Math.max(left_Height, right_Height);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths/">https://leetcode-cn.com/problems/binary-tree-paths/</a></p><h2 id="问题叙述-17"><a href="#问题叙述-17" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点 是指没有子节点的节点。</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>![])(<a href="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg">https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg</a>)<br>输入：root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p><h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：root = [1]<br>输出：[“1”]</p><h2 id="提示-16"><a href="#提示-16" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [1, 100] 内<br>-100 &lt;= Node.val &lt;= 100</p><h2 id="思路分析-17"><a href="#思路分析-17" class="headerlink" title="思路分析"></a>思路分析</h2><p>DFS<br>在用深度优先搜索遍历二叉树时，我们只需要考虑当前节点和他的子节点</p><ul><li>如果当前节点是叶子节点，那我们只需要在当前路径的末尾加上该节点，然后我们就得到了一条由根节点到叶子节点的路径，将路径加入到结果中即可</li><li>如果当前节点不是叶子节点，则在当前路径的末尾加上该节点，然后继续递归遍历该节点的子节点<h2 id="代码提交-17"><a href="#代码提交-17" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Magic(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Magic</span><span class="params">(TreeNode root, String curPath, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(curPath);</span><br><span class="line">sb.append(root.val);</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">res.add(sb.toString());</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sb.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">Magic(root.left, sb.toString(), res);</span><br><span class="line">Magic(root.right, sb.toString(), res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p><h2 id="问题叙述-18"><a href="#问题叙述-18" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt=""><br>输入: root = [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><h2 id="示例2-3"><a href="#示例2-3" class="headerlink" title="示例2"></a>示例2</h2><p>输入: root = [1]<br>输出: 0</p><h2 id="提示-17"><a href="#提示-17" class="headerlink" title="提示"></a>提示</h2><p>节点数在 [1, 1000] 范围内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路分析-18"><a href="#思路分析-18" class="headerlink" title="思路分析"></a>思路分析</h2><p>判断每个节点的左节点是否为叶子节点，然后递归的求取左子树的左叶子之和，右子树的左叶子之和，相加便是整个树的左叶子之和</p><h2 id="代码提交-18"><a href="#代码提交-18" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)</span><br><span class="line">sum += root.left.val;</span><br><span class="line"><span class="keyword">return</span> sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p><h2 id="问题叙述-19"><a href="#问题叙述-19" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p><h2 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt=""><br>输入: root = [2,1,3]<br>输出: 1</p><h2 id="示例2-4"><a href="#示例2-4" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt=""><br>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7</p><h2 id="提示-18"><a href="#提示-18" class="headerlink" title="提示"></a>提示</h2><p>二叉树的节点个数的范围是 [1,10^4]<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1 </p><h2 id="思路分析-19"><a href="#思路分析-19" class="headerlink" title="思路分析"></a>思路分析</h2><p>层序遍历YYDS<br>我们需要找最底层最左边节点的值<br>那我们层序遍历时 从右往左遍历 遍历到的最后一个元素就是要找的节点</p><h2 id="代码提交-19"><a href="#代码提交-19" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">root = deque.poll();</span><br><span class="line"><span class="keyword">if</span> (root.right != <span class="keyword">null</span>) deque.offer(root.right);</span><br><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span>) deque.offer(root.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p><h2 id="问题叙述-20"><a href="#问题叙述-20" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br>叶子节点 是指没有子节点的节点。</p><h2 id="示例1-5"><a href="#示例1-5" class="headerlink" title="示例1"></a>示例1</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt=""><br>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。</p><h2 id="示例2-5"><a href="#示例2-5" class="headerlink" title="示例2"></a>示例2</h2><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt=""><br>输入：root = [1,2,3], targetSum = 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 —&gt; 2): 和为 3<br>(1 —&gt; 3): 和为 4<br>不存在 sum = 5 的根节点到叶子节点的路径。</p><h2 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3"></a>示例3</h2><p>输入：root = [], targetSum = 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><h2 id="提示-19"><a href="#提示-19" class="headerlink" title="提示"></a>提示</h2><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;= Node.val &lt;= 1000<br>-1000 &lt;= targetSum &lt;= 1000</p><h2 id="思路分析-20"><a href="#思路分析-20" class="headerlink" title="思路分析"></a>思路分析</h2><p>递归<br>如果当前节点是叶子节点，那我们可以直接判断val是否等于targetSum<br>如果当前节点不是叶子节点，那我们递归的判断他的子节点的val是否满足targetSum-val</p><h2 id="代码提交-20"><a href="#代码提交-20" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val)</span><br><span class="line">|| hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><h2 id="问题叙述-21"><a href="#问题叙述-21" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><h2 id="示例-1-13"><a href="#示例-1-13" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt=""><br>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]</p><h2 id="示例2-6"><a href="#示例2-6" class="headerlink" title="示例2"></a>示例2</h2><p>输入：inorder = [-1], postorder = [-1]<br>输出：[-1]</p><h2 id="提示-20"><a href="#提示-20" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= inorder.length &lt;= 3000<br>postorder.length == inorder.length<br>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000<br>inorder 和 postorder 都由 不同 的值组成<br>postorder 中每一个值都在 inorder 中<br>inorder 保证是树的中序遍历<br>postorder 保证是树的后序遍历</p><h2 id="思路分析-21"><a href="#思路分析-21" class="headerlink" title="思路分析"></a>思路分析</h2><p>递归<br>终止条件是数组长度为0 也就是空节点<br>如果不为空 我们取后序遍历的最后一个节点作为根节点<br>我们按照这个根节点 可以把中序遍历数组分为左数组和右数组<br>同样 将后序遍历数组分为左数组和右数组<br>递归处理左区间和右区间<br>PS:题目中说 中序和后序遍历都是由不同的值构成 所以不用担心有重值的情况</p><h2 id="代码提交-21"><a href="#代码提交-21" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> n = postorder.length;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(postorder[n - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">root.left = buildTree(Arrays.copyOfRange(inorder, <span class="number">0</span>, i), Arrays.copyOfRange(postorder, <span class="number">0</span>, i));</span><br><span class="line">root.right = buildTree(Arrays.copyOfRange(inorder, i + <span class="number">1</span>, n), Arrays.copyOfRange(postorder, i, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a>从前序和中序遍历序列构造二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h2 id="问题叙述-22"><a href="#问题叙述-22" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><h2 id="示例-1-14"><a href="#示例-1-14" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt=""><br>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p><h2 id="示例-2-13"><a href="#示例-2-13" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: preorder = [-1], inorder = [-1]<br>输出: [-1]</p><h2 id="提示-21"><a href="#提示-21" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= preorder.length &lt;= 3000<br>inorder.length == preorder.length<br>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h2 id="思路分析-22"><a href="#思路分析-22" class="headerlink" title="思路分析"></a>思路分析</h2><p>和上题没有本质上的区别</p><h2 id="代码提交-22"><a href="#代码提交-22" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> n = preorder.length;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(inorder, <span class="number">0</span>, i));</span><br><span class="line">root.right = buildTree(Arrays.copyOfRange(preorder, i + <span class="number">1</span>, n), Arrays.copyOfRange(inorder, i + <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-binary-tree/">https://leetcode-cn.com/problems/maximum-binary-tree/</a></p><h2 id="问题叙述-23"><a href="#问题叙述-23" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:<br>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><h2 id="示例-1-15"><a href="#示例-1-15" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt=""><br>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p><ul><li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul><li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul><li>空数组，无子节点。</li><li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul><li>空数组，无子节点。</li><li>只有一个元素，所以子节点是一个值为 1 的节点。</li></ul></li></ul></li><li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul><li>只有一个元素，所以子节点是一个值为 0 的节点。</li><li>空数组，无子节点。<h2 id="示例-2-14"><a href="#示例-2-14" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt=""><br>输入：nums = [3,2,1]<br>输出：[3,null,2,null,1]<h2 id="提示-22"><a href="#提示-22" class="headerlink" title="提示"></a>提示</h2>1 &lt;= nums.length &lt;= 1000<br>0 &lt;= nums[i] &lt;= 1000<br>nums 中的所有整数 互不相同<h2 id="思路分析-23"><a href="#思路分析-23" class="headerlink" title="思路分析"></a>思路分析</h2>题目中已经给了思路了 照做就行 跟上题类似<h2 id="代码提交-23"><a href="#代码提交-23" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> maxIndex = findMaxIndex(nums);</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxIndex));</span><br><span class="line">root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="number">1</span>, nums.length));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">max = nums[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">https://leetcode-cn.com/problems/merge-two-binary-trees/</a><h2 id="问题叙述-24"><a href="#问题叙述-24" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。<h2 id="示例-1-16"><a href="#示例-1-16" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt=""><br>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<h2 id="示例-2-15"><a href="#示例-2-15" class="headerlink" title="示例 2"></a>示例 2</h2>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]<h2 id="提示-23"><a href="#提示-23" class="headerlink" title="提示"></a>提示</h2>两棵树中的节点数目在范围 [0, 2000] 内<br>-10^4 &lt;= Node.val &lt;= 10^4<h2 id="思路分析-24"><a href="#思路分析-24" class="headerlink" title="思路分析"></a>思路分析</h2>合并两棵树<br>如果root1是null 那就返回root2即可(root2是null也无所谓 反正也是返回null)<br>如果root2是null 那就返回root1<br>剩下的情况就是 root1和root2都不是null<br>那就把他们的值相加 合并成新节点<br>然后再用前序遍历递归处理即可(中序后序也可以)<h2 id="代码提交-24"><a href="#代码提交-24" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">TreeNode root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)</span><br><span class="line">root = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line"><span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line"><span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化版 直接在root1或root2上修改也行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line"><span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">root1.val += root2.val;</span><br><span class="line">root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"><span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a><h2 id="问题叙述-25"><a href="#问题叙述-25" class="headerlink" title="问题叙述"></a>问题叙述</h2>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。<br>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。<h2 id="示例-1-17"><a href="#示例-1-17" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 2<br>输出：[2,1,3]<h2 id="示例-2-16"><a href="#示例-2-16" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 5<br>输出：[]<h2 id="提示-24"><a href="#提示-24" class="headerlink" title="提示"></a>提示</h2>数中节点数在 [1, 5000] 范围内<br>1 &lt;= Node.val &lt;= 10^7<br>root 是二叉搜索树<br>1 &lt;= val &lt;= 10^7<h2 id="思路分析-25"><a href="#思路分析-25" class="headerlink" title="思路分析"></a>思路分析</h2>先来说一下什么叫二叉搜索树<br>在二叉搜索树中：</li></ul></li></ul></li></ul><ol><li>若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</li><li>若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</li><li>任意结点的左、右子树也分别为二叉搜索树。</li><li>二叉搜索树的中序遍历是升序<br>根据二叉搜索树的性质 如果要找的val值大于根节点的值 那val只可能在该根节点的右子树上找到<br>同理 如果要找的val值小于根节点的值 那val只可能在该根节点的左子树上找到<h2 id="代码提交-25"><a href="#代码提交-25" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val == val) <span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化版 前两条if语句可以合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">https://leetcode-cn.com/problems/validate-binary-search-tree/</a><h2 id="问题叙述-26"><a href="#问题叙述-26" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<h2 id="示例-1-18"><a href="#示例-1-18" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt=""><br>输入：root = [2,1,3]<br>输出：true<h2 id="示例2-7"><a href="#示例2-7" class="headerlink" title="示例2"></a>示例2</h2><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt=""><br>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<h2 id="提示-25"><a href="#提示-25" class="headerlink" title="提示"></a>提示</h2>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1<h2 id="思路分析-26"><a href="#思路分析-26" class="headerlink" title="思路分析"></a>思路分析</h2>二叉搜索树的中序遍历是升序的<br>所以我们用中序遍历二叉搜索树<br>如果当且节点值<strong>小于等于</strong>上一节点值 则满足条件<br>否则则不是二叉搜索树<h2 id="代码提交-26"><a href="#代码提交-26" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isValidBST(root.left)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt;= pre)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">pre = root.val;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的最小绝对值差"><a href="#二叉搜索树的最小绝对值差" class="headerlink" title="二叉搜索树的最小绝对值差"></a>二叉搜索树的最小绝对值差</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a><h2 id="问题叙述-27"><a href="#问题叙述-27" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。<br>差值是一个正数，其数值等于两值之差的绝对值。<h2 id="示例-1-19"><a href="#示例-1-19" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt=""><br>输入：root = [4,2,6,1,3]<br>输出：1<h2 id="示例2-8"><a href="#示例2-8" class="headerlink" title="示例2"></a>示例2</h2><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt=""><br>输入：root = [1,0,48,null,null,12,49]<br>输出：1<h2 id="提示-26"><a href="#提示-26" class="headerlink" title="提示"></a>提示</h2>树中节点的数目范围是 [2, 104]<br>0 &lt;= Node.val &lt;= 105<h2 id="思路分析-27"><a href="#思路分析-27" class="headerlink" title="思路分析"></a>思路分析</h2>题目要求找<strong>任意</strong>两节点之差绝对值的最小值<br>由于中序遍历的顺序是升序的 所以最小绝对值差 只可能是中序遍历序列中两个相邻元素之差<h2 id="代码提交-27"><a href="#代码提交-27" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">inorder(root, list);</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = Math.min(list.get(i + <span class="number">1</span>) - list.get(i), min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">inorder(root.left, list);</span><br><span class="line">list.add(root.val);</span><br><span class="line">inorder(root.right, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p><h2 id="问题叙述-28"><a href="#问题叙述-28" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：</p><ol><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树<h2 id="示例-1-20"><a href="#示例-1-20" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt=""><br>输入：root = [1,null,2,2]<br>输出：[2]<h2 id="示例-2-17"><a href="#示例-2-17" class="headerlink" title="示例 2"></a>示例 2</h2>输入：root = [0]<br>输出：[0]<h2 id="提示-27"><a href="#提示-27" class="headerlink" title="提示"></a>提示</h2>树中节点的数目在范围 [1, 10^4] 内<br>-10^5 &lt;= Node.val &lt;= 10^5<br>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）<h2 id="思路分析-28"><a href="#思路分析-28" class="headerlink" title="思路分析"></a>思路分析</h2>中序遍历是有序序列<br>所以这道题就简化为从有序序列中寻找众数<br>用pre记录当前节点的上一个节点 初始化为null<br>count记录当前数字重复次数<br>maxCount表示已经扫描过的数字中出现的最大次数<br>如果pre和root的值相同，也就是当前节点与上一个节点的值相等 则count++<br>pre为null时 是判断第一个节点 此时执行count++也没问题<br>否则 则将count初始化为1<br>然后将root赋给pre<br>接着比较当前的count和maxCount<br>如果二者相等 则有多个众数 将当前节点的val加入到结果中<br>如果当前的count大于maxCount 则说明出现了新的众数 将原有结果清空 同时将maxCount更新为当前count 将该节点的val加入到结果中<h2 id="代码提交-28"><a href="#代码提交-28" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">inorder(root, list);</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">res[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">inorder(root.left, list);</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.val == root.val) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = root;</span><br><span class="line"><span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">list.add(root.val);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">list.clear();</span><br><span class="line">maxCount = count;</span><br><span class="line">list.add(root.val);</span><br><span class="line">&#125;</span><br><span class="line">inorder(root.right, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a><h2 id="问题叙述-29"><a href="#问题叙述-29" class="headerlink" title="问题叙述"></a>问题叙述</h2>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<h2 id="示例-1-21"><a href="#示例-1-21" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<h2 id="示例-2-18"><a href="#示例-2-18" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<h2 id="示例-3-8"><a href="#示例-3-8" class="headerlink" title="示例 3"></a>示例 3</h2>输入：root = [1,2], p = 1, q = 2<br>输出：1<h2 id="提示-28"><a href="#提示-28" class="headerlink" title="提示"></a>提示</h2>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;= Node.val &lt;= 10^9<br>所有 Node.val 互不相同 。<br>p != q<br>p 和 q 均存在于给定的二叉树中。<h2 id="思路分析-29"><a href="#思路分析-29" class="headerlink" title="思路分析"></a>思路分析</h2>递归<br>若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</li><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p = root，且 q 在 root 的左或右子树中；</li><li>q = root，且 p 在 root 的左或右子树中；</li></ol><p>后序遍历整棵二叉树<br>用 left 和 right 分别表示 当前节点的左子树或右子树是否包含节点p或 q ，如果包含为true 否则为false<br>那么符合条件的最近公共祖先则满足以下条件:<br>        (left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right))<br>(left &amp;&amp; right)对应情况1 p和q分裂当前root节点的异侧<br>(root == p || root == q) &amp;&amp; (left || right) 对应条件2和3<br>由于我们是自底向顶遍历的 所以我们找到满足root == p || root == q的节点时 要判断它的左子树或右子树是否包含另一个节点<br>由于我们是自底向顶遍历的 所以满足条件的root必然是深度最大的 也就是最近的公共祖先</p><h2 id="代码提交-29"><a href="#代码提交-29" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">TreeNode res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPorQ</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> left = hasPorQ(root.left, p, q);</span><br><span class="line"><span class="keyword">boolean</span> right = hasPorQ(root.right, p, q);</span><br><span class="line"><span class="keyword">if</span> ((left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right)))</span><br><span class="line">res = root;</span><br><span class="line"><span class="keyword">return</span> left || right || root.val == p.val || root.val == q.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">hasPorQ(root, p, q);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><h2 id="问题叙述-30"><a href="#问题叙述-30" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><h2 id="示例-1-22"><a href="#示例-1-22" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><h2 id="示例-2-19"><a href="#示例-2-19" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h2 id="思路分析-30"><a href="#思路分析-30" class="headerlink" title="思路分析"></a>思路分析</h2><p>利用二叉搜索树的性质<br>左子树中所含节点的值 小于等于 当前节点的值<br>右子树中所含节点的值 大于等于 当前节点的值<br>从根节点开始遍历<br>如果当前节点的值大于p和q的值 那么p和q则应该在当前节点的左子树上 所以我们把当前节点移到它的左子节点上<br>如果当前节点的值小于p和q的值 那么p和q则应该在当前节点的右子树上 所以我们把当前节点移到它的右子节点上<br>如果不满足上述两条要求 则说明p和q分布在当前节点两侧 或者当前节点是p或q 满足要求 返回当前节点即可</p><p>直接用上题的代码也可以</p><h2 id="代码提交-30"><a href="#代码提交-30" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">root = root.left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">root = root.right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p><h2 id="问题叙述-31"><a href="#问题叙述-31" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><h2 id="示例-1-23"><a href="#示例-1-23" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""><br>输入：root = [4,2,7,1,3], val = 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p><h2 id="示例-2-20"><a href="#示例-2-20" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt=""><br>输入：root = [40,20,60,10,30,50,70], val = 25<br>输出：[40,20,60,10,30,50,70,null,null,25]</p><h2 id="示例-3-9"><a href="#示例-3-9" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<br>输出：[4,2,7,1,3,5]</p><h2 id="提示-29"><a href="#提示-29" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数将在 [0, 10^4]的范围内。<br>-10^8 &lt;= Node.val &lt;= 10^8<br>所有值 Node.val 是 独一无二 的。<br>-10^8 &lt;= val &lt;= 10^8<br>保证 val 在原始BST中不存在。</p><h2 id="思路分析-31"><a href="#思路分析-31" class="headerlink" title="思路分析"></a>思路分析</h2><p>递归<br>比较root.val和目标val的大小关系<br>如果root.val大于目标val 则说明需要插入到左子树中<br>如果root.val小于目标val 则说明需要插入到右子树中<br>如果此时的左/右子树为null  则表明可以直接插入 返回新建一个目标val的节点即可<br>否则的话 继续执行上述两步 直至找到一个合适的位置可供插入</p><h2 id="代码提交-31"><a href="#代码提交-31" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"><span class="keyword">if</span> (val &lt; root.val) root.left = insertIntoBST(root.left, val);</span><br><span class="line"><span class="keyword">if</span> (val &gt; root.val) root.right = insertIntoBST(root.right, val);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p><h2 id="问题叙述-32"><a href="#问题叙述-32" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。<h2 id="示例-1-24"><a href="#示例-1-24" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt=""><br>输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<h2 id="示例-2-21"><a href="#示例-2-21" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt=""><br>输入: root = [5,3,6,2,4,null,7], key = 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点<h2 id="示例-3-10"><a href="#示例-3-10" class="headerlink" title="示例 3"></a>示例 3</h2>输入: root = [], key = 0<br>输出: []<h2 id="提示-30"><a href="#提示-30" class="headerlink" title="提示"></a>提示</h2>节点数的范围 [0, 10^4].<br>-10^5 &lt;= Node.val &lt;= 10^5<br>节点值唯一<br>root 是合法的二叉搜索树<br>-10^5 &lt;= key &lt;= 10^5<h2 id="思路分析-32"><a href="#思路分析-32" class="headerlink" title="思路分析"></a>思路分析</h2>递归</li><li>没找到删除节点 返回原来的根节点即可</li><li>找到了目标节点 目标节点的两个孩子都不存在 那我们执行root=null:</li><li>找到了目标节点 目标节点的左孩子是null 那就直接把目标节点的right 替换到当前节点 root=root.right:</li><li>找到了目标节点 目标节点的右孩子是null 那就直接把目标节点的left 替换到当前节点 root=root.left:</li><li>找到了目标节点 目标节点的左右孩子均存在 由于二叉搜索树的中序遍历是递增的 那目标节点的左孩子树的所有值均小于右孩子树的最小值 所以我们找到右孩子树上的最左节点 也就是右孩子树上最小的节点 我们将目标节点的左孩子放在右孩子树上最小节点的左孩子的位置 就能满足题目要求<h2 id="代码提交-32"><a href="#代码提交-32" class="headerlink" title="代码提交"></a>代码提交</h2></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line"><span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) root = root.right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) root = root.left;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">TreeNode node = root.right;</span><br><span class="line"><span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">node.left = root.left;</span><br><span class="line">root = root.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">https://leetcode-cn.com/problems/trim-a-binary-search-tree/</a></p><h2 id="问题叙述-33"><a href="#问题叙述-33" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。<br>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><h2 id="示例-1-25"><a href="#示例-1-25" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt=""><br>输入：root = [1,0,2], low = 1, high = 2<br>输出：[1,null,2]</p><h2 id="示例-2-22"><a href="#示例-2-22" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt=""><br>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3<br>输出：[3,2,null,1]</p><h2 id="提示-31"><a href="#提示-31" class="headerlink" title="提示"></a>提示</h2><p>树中节点数在范围 [1, 10^4] 内<br>0 &lt;= Node.val &lt;= 10^4<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;= low &lt;= high &lt;= 10^4</p><h2 id="思路分析-33"><a href="#思路分析-33" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-33"><a href="#代码提交-33" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果当前节点的值 比左区间端点还小 那就尝试一下当前节点的右节点</span></span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">root = root.right;</span><br><span class="line">root = trimBST(root, low, high);</span><br><span class="line"><span class="comment">//如果当前节点的值 比右区间断电还大 那就尝试一下当前节点的左节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">root = root.left;</span><br><span class="line">root = trimBST(root, low, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前节点满足在区间内 那就先序遍历递归处理所有节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root.left = trimBST(root.left, low, high);</span><br><span class="line">root.right = trimBST(root.right, low, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简洁版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; high) <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">root.left = trimBST(root.left, low, high);</span><br><span class="line">root.right = trimBST(root.right, low, high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将有序数组转化为二叉搜索树"><a href="#将有序数组转化为二叉搜索树" class="headerlink" title="将有序数组转化为二叉搜索树"></a>将有序数组转化为二叉搜索树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h2 id="问题叙述-34"><a href="#问题叙述-34" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。<br>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><h2 id="示例-1-26"><a href="#示例-1-26" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt=""><br>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：<br><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt=""></p><h2 id="示例-2-23"><a href="#示例-2-23" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt=""><br>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</p><h2 id="提示-32"><a href="#提示-32" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 按 严格递增 顺序排列</p><h2 id="思路分析-34"><a href="#思路分析-34" class="headerlink" title="思路分析"></a>思路分析</h2><p>二分 每次找出数组最中间的值 令它作为根节点</p><h2 id="代码提交-34"><a href="#代码提交-34" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="keyword">null</span> : Magic(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">Magic</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> mid = ((right + left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">root.left = Magic(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">root.left = Magic(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="把二叉搜索树转化为累加树"><a href="#把二叉搜索树转化为累加树" class="headerlink" title="把二叉搜索树转化为累加树"></a>把二叉搜索树转化为累加树</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><h2 id="问题叙述-35"><a href="#问题叙述-35" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br>提醒一下，二叉搜索树满足下列约束条件：<br>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><h2 id="示例-1-27"><a href="#示例-1-27" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt=""><br>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><h2 id="示例-2-24"><a href="#示例-2-24" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：root = [0,null,1]<br>输出：[1,null,1]</p><h2 id="示例-3-11"><a href="#示例-3-11" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：root = [1,0,2]<br>输出：[3,3,2]</p><h2 id="示例-4-2"><a href="#示例-4-2" class="headerlink" title="示例 4"></a>示例 4</h2><p>输入：root = [3,2,4,1]<br>输出：[7,9,4,10]</p><h2 id="提示-33"><a href="#提示-33" class="headerlink" title="提示"></a>提示</h2><p>树中的节点数介于 0 和 10^4 之间。<br>每个节点的值介于 -10^4 和 10^4 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p><h2 id="思路分析-35"><a href="#思路分析-35" class="headerlink" title="思路分析"></a>思路分析</h2><p>读不懂题 然后我去看了1038题 总算读懂了<br>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。<br>由于中序遍历是递增的 左边到右边依次增大<br>所以每个节点的值是 本身+右边所有节点<br>所以我们从右往左进行中序遍历即可  每个节点的值 都等于 自身+上一个节点</p><h2 id="代码提交-35"><a href="#代码提交-35" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">convertBST(root.right);</span><br><span class="line">num += root.val;</span><br><span class="line">root.val = num;</span><br><span class="line">convertBST(root.left);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2022/02/13/StackAndQueue/"/>
      <url>/2022/02/13/StackAndQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的括号-括号匹配"><a href="#有效的括号-括号匹配" class="headerlink" title="有效的括号(括号匹配)"></a>有效的括号(括号匹配)</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：s = “()”<br>输出：true</p><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p>输入：s = “()[]{}”<br>输出：true</p><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><p>输入：s = “(]”<br>输出：false</p><h2 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h2><p>输入：s = “([)]”<br>输出：false</p><h2 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a>示例 5：</h2><p>输入：s = “{[]}”<br>输出：true</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= s.length &lt;= 104<br>s 仅由括号 ‘()[]{}’ 组成</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>栈的先入口处的特点刚好与本题的括号匹配特点一致<br>如果遇到左括号则入栈，遇到右括号应将对应的栈顶左括号出栈<br>遍历结束之后，栈为空则符合条件</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">ch = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span> || ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">stack.push(ch);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty() || stack.peek() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span> stack.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty() || stack.peek() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span> stack.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty() || stack.peek() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">ch = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || ch != stack.peek())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除字符串中所有相邻重复项"><a href="#删除字符串中所有相邻重复项" class="headerlink" title="删除字符串中所有相邻重复项"></a>删除字符串中所有相邻重复项</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：”abbaca”<br>输出：”ca”</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= S.length &lt;= 20000<br>S 仅由小写英文字母组成。</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">c = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty() || stack.peek() != c)</span><br><span class="line">stack.push(c);</span><br><span class="line"><span class="keyword">else</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">str = stack.pop() + str;<span class="comment">//注意是逆序相加</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> slow = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; fast &lt; str.length; fast++) &#123;</span><br><span class="line"><span class="keyword">if</span> (slow == -<span class="number">1</span> || str[slow] != str[fast])</span><br><span class="line">str[++slow] = str[fast];</span><br><span class="line"><span class="keyword">else</span> slow--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(str, <span class="number">0</span>, slow + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表达式</a>，求表达式的值。<br>有效的算符包括 +、-、<em>、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>注意 <em>*两个整数之间的除法只保留整数部分</em></em>。<br>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：tokens = [“2”,”1”,”+”,”3”,”<em>“]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) </em> 3) = 9</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：tokens = [“4”,”13”,”5”,”/“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”/“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= tokens.length &lt;= 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “/“），或是在范围 [-200, 200] 内的一个整数</p><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。<br>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) <em> ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) </em> ) 。<br>逆波兰表达式主要有以下两个优点：</p><ol><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中<h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2></li></ol><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">stack.push(stack.pop() + stack.pop());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">stack.push(-stack.pop() + stack.pop());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">stack.push(stack.pop() * stack.pop());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line"><span class="keyword">int</span> a = stack.pop();</span><br><span class="line"><span class="keyword">int</span> b = stack.pop();</span><br><span class="line">stack.push(b / a);</span><br><span class="line">&#125; <span class="keyword">else</span> stack.push(Integer.parseInt(tokens[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]</p><p>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1], k = 1<br>输出：[1]</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104<br>1 &lt;= k &lt;= nums.length</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>将每一个元素添加到队列中 只要新元素大于队尾元素（这种情况队尾元素不可能是滑动窗口内的最大值），<br>那么队尾元素出队，也就是我们维护的是一个单调递减的队列<br>又由于处在队首的元素是最早进队的，所以我们还需要判断，队首元素是否还在滑动窗口内</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.getLast()])</span><br><span class="line">deque.pollLast();</span><br><span class="line">deque.addLast(i);</span><br><span class="line"><span class="keyword">if</span> (deque.peek() &lt; i - k + <span class="number">1</span>)</span><br><span class="line">deque.poll();</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k)</span><br><span class="line">result[i + <span class="number">1</span> - k] = nums[deque.peek()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2022/02/02/list/"/>
      <url>/2022/02/02/list/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合框架概述"><a href="#Java集合框架概述" class="headerlink" title="Java集合框架概述"></a>Java集合框架概述</h1><h2 id="集合框架与数组的对比及概述"><a href="#集合框架与数组的对比及概述" class="headerlink" title="集合框架与数组的对比及概述"></a>集合框架与数组的对比及概述</h2><h3 id="集合的框架"><a href="#集合的框架" class="headerlink" title="集合的框架"></a>集合的框架</h3><ol><li><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器</p><blockquote><p>说明：此时的存储主要是指内存层面的存储，不涉及到持久化的存储(.txt，.jpg，.avi，数据库中)</p></blockquote></li><li><p>数组在存储多个数据封面的特点</p></li></ol><ul><li>一旦初始化后，它的长度就固定了</li><li>数组一旦定义好，它的数据类型也固定了，我们只能操作指定类型的数据  (String[] arr; int[] arr; double[] arr;)</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高</li><li>对于获取数组中实际元素的个数的需求，数组没有提供现成的属性或方法可用(长度为10的数组，而我只初始化了5个元素)</li><li>数组存储数据的特点：有序，可重复。(对于无序，不可重复的需求，无法满足)</li></ul><h2 id="集合框架涉及到的API"><a href="#集合框架涉及到的API" class="headerlink" title="集合框架涉及到的API"></a>集合框架涉及到的API</h2><ul><li>Java集合可分为Collection和Map两种体系<ul><li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul><li>List：元素有序，可重复的集合(ArrayList，LinkedList,vector)  —-&gt; 动态数组</li><li>Set：元素无序，不可重复的集合(HashSet,LinkedHashSet,TreeSet)  —-&gt; 高中数学里的集合</li></ul></li><li>Map接口：双列数据，保存具有映射关系的”key-value对”的集合  ——&gt;函数 y=f(x)<br><img src="https://img-blog.csdnimg.cn/img_convert/4a9d3171541866ba77e2291ce41e9962.png" alt="Collection接口继承树"><br><img src="https://img-blog.csdnimg.cn/img_convert/a1fdb6d75598e87a224697d12c2c2bcf.png" alt="Map接口继承树"><br><strong>在开发中很少直接使用Collection集合，通常都是使用该集合的子集合：List集合、Queue集合以及Set集合。</strong></li></ul></li></ul><h2 id="Collection接口的常用方法"><a href="#Collection接口的常用方法" class="headerlink" title="Collection接口的常用方法"></a>Collection接口的常用方法</h2><ol><li>boolean add(Object obj)    添加元素</li><li>boolean addAll(Collection coll)    添加元素</li><li>int size()    获取有效元素个数</li><li>boolean isEmpty()    是否为空集合</li><li>boolean contains(Object obj)    是否包含某个元素，是通过元素的equals方法来判断是否为同一个对象</li><li>boolean cotainsAll(Collection coll)    </li><li>boolean retainAll(Collection coll)</li><li>boolean equals(Object obj)</li><li>Object[] toArray()</li><li>hashCode()</li><li>iterator()</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2022/01/23/Str/"/>
      <url>/2022/01/23/Str/</url>
      
        <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= s.length &lt;= 105<br>s[i] 都是 ASCII 码表中的可打印字符</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>双指针，交换首尾即可</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = s.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = s[low];</span><br><span class="line">s[low] = s[high];</span><br><span class="line">s[high] = tmp;</span><br><span class="line">low++;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：s = “abcd”, k = 2<br>输出：”bacd”</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文组成<br>1 &lt;= k &lt;= 104</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>反转部分与上题相同，我们只需要找好区间即可。<br>找到每个2k区间的起点start，然后反转start，start+k的区间。<br>但题目中说：如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br>所以我们的结尾区间应该是Math.MIN(start+k,s.length-1)</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line"><span class="keyword">int</span> start = i;</span><br><span class="line"><span class="keyword">int</span> end = Math.min(arr.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = arr[start];</span><br><span class="line">arr[start] = arr[end];</span><br><span class="line">arr[end] = tmp;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= s 的长度 &lt;= 10000</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>方法一：直接用自带的replaceAll方法<br>方法二：创建一个StringBuilder，将原字符串中的元素挨个加入sb中，如果遇到了空格则改为添加”%20”<br>方法三：双指针，先遍历一遍原字符串，每遇到一个空格，便再添加两个空格的长度(将一个空格换成%20需要额外两个空间)。左指针指向原字符串末尾，右指针指向扩展至和的字符串末尾，然后依次往前遍历，只要左指针指向的字符不是空格，则将它写到右指针的位置上，遇到空格则右指针往前进行三次赋值。</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == c) sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = s.length() - <span class="number">1</span>;</span><br><span class="line">s += str.toString();</span><br><span class="line"><span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (chars[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">chars[right] = chars[left];</span><br><span class="line">&#125;</span><br><span class="line">left--;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a>反转字符串里的单词</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个字符串s，逐个翻转字符串中的所有单词。<br>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。<br>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。</li><li>翻转后单词间应当仅用一个空格分隔。</li><li>翻转后的字符串中不应包含额外的空格。<h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2>输入：s = “the sky is blue”<br>输出：”blue is sky the”<h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2>输入：s = “  hello world  “<br>输出：”world hello”<br>解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2>输入：s = “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2>输入：s = “  Bob    Loves  Alice   “<br>输出：”Alice Loves Bob”<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h2>输入：s = “Alice does not even like bob”<br>输出：”bob like even not does Alice”<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2>1 &lt;= s.length &lt;= 104<br>s 包含英文大小写字母、数字和空格 ‘ ‘<br>s 中 至少存在一个 单词<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2>请尝试使用 O(1) 额外空间复杂度的原地解法。<h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2>正则表达式的使用：\s+可以匹配任何空格字符(\f换页 \n换行 \r回车 \t制表 \v垂直制表)，因为反斜杠在Java里是转义字符，所以我们这里要用”\s+”</li></ul></blockquote><p>String.join也是jdk1.8新增的一个静态方法，返回值是String类型</p><p>使用方式如下所示：<br>String result = String.join(“-“,“a”,“b”,“c”,“d”);<br>输出结果如下：a-b-c-d</p><p>也可使用如下方式：<br>String[] arr = {“a”,“b”,“c”,“d”};<br>String result = String.join(“-“,arr);<br>输出结果如下：a-b-c-d</p><p>参数列表：<br>　　1. 表示连接的符号<br>　　2. 表示被连接的数组（也可以是集合），或者是要连接的多个字符串</p><p>所以我们先用trim()方法清除前导空格和尾部空白，再用\s+匹配多个空格切片，将其存入list中，再用reverse()方法将list列表反转，再用空格字符连接作为返回值即可。</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于Java的String的不可变性，所以没有空间复杂度为O(1)的原地解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">s = s.trim();</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>1 &lt;= k &lt; s.length &lt;= 10000</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>方法一：<br>因为Java中String的不可变性，所以这里不能用String(效率低，占空间)，而是用StringBuilder，手动模拟即可，从n开始，将元素逐渐加入到sb中<br>方法二：<br>从n位置分为两个子串，将这两个子串换位置相加</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; n+s.length(); i++) &#123;</span><br><span class="line">sb.append(s.charAt(i%s.length()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.substring(n)+s.substring(<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr(())"></a>实现strStr(())</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-strstr/">https://leetcode-cn.com/problems/implement-strstr/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：haystack = “hello”, needle = “ll”<br>输出：2</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：haystack = “aaaaa”, needle = “bba”<br>输出：-1</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：haystack = “”, needle = “”<br>输出：0</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= haystack.length, needle.length &lt;= 5 * 104<br>haystack 和 needle 仅由小写英文字符组成</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>大海捞针的英文版：Looking for a needle in a haystack</p></blockquote><p>暴力算法：用needle串和haystack串的所有长度等于needle的子串挨个比较，为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配（可以通过设置一个flag来实现），对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 -1。</p><p>KMP算法：难点在于k=next[k]这句，我也是查了好多资料才搞明白。<br><img src="https://img-blog.csdnimg.cn/20200820183256674.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92,size_16,color_FFFFFF,t_70" alt="KMP"></p><p>next数组也是各有不同，我这里用的是第一行这种的。<br><img src="/img/next.png" alt="next"></p><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是一个冷酷无情的API选手</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KMP（next数组从-1开始）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] next, String needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] ned = needle.toCharArray();</span><br><span class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; ned.length - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (k == -<span class="number">1</span> || ned[j] == ned[k]) &#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125; <span class="keyword">else</span> k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (needle.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (haystack.isEmpty() || haystack.length() &lt; needle.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[haystack.length()];</span><br><span class="line">getNext(next, needle);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == -<span class="number">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= needle.length()) <span class="keyword">return</span> i - needle.length();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">https://leetcode-cn.com/problems/repeated-substring-pattern/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: “aba”<br>输出: False</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>由于next数组不同，所以代码也会有些许不同。<br>next[len-1]=7，我们再后补一个空格，next[len]=8，此时的8就是字符串asdfasdfasdf的最长相同前后缀的长度<br>(len-next[len])也就是 12（字符串长度）-8（最长公共前后缀的长度）= 4 ，4刚好可以被12（字符串长度）整除，所以说明有重复字串（asdf）<br>说明：数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</p><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s + s;</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] next, String needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] ned = (needle+<span class="string">&quot; &quot;</span>).toCharArray();</span><br><span class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; ned.length-<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (k == -<span class="number">1</span> || ned[j] == ned[k]) &#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125; <span class="keyword">else</span> k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">getNext(next, s);</span><br><span class="line"><span class="keyword">if</span> (next[len] != <span class="number">0</span> &amp;&amp; len % (len - (next[len])) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2022/01/21/HashTable/"/>
      <url>/2022/01/21/HashTable/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: s = “rat”, t = “car”<br>输出: false</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= s.length, t.length &lt;= 5 * 104<br>s 和 t 仅包含小写字母</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>方法一：创建一个长度为26的整形数组(a~z)，用来记录每个字符出现的次数，遍历s的时候，遍历到的每个字符+1，遍历t的时候，遍历到的每个字符-1。如果最后的数组元素全为0，那么这两个字符串是字母异位的。</p></blockquote><p>方法二：把两个字符串转化为字符数组，然后对数组排序，如果两个字符串组成的字符相同，那么排序之后的两个数组应该相等。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">table[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray())</span><br><span class="line">table[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : table)</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/01/19/LinkedList/"/>
      <url>/2022/01/19/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">https://leetcode-cn.com/problems/remove-linked-list-elements/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：head = [], val = 1<br>输出：[]</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：head = [7,7,7,7], val = 7<br>输出：[]</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>列表中的节点数目在范围 [0, 104] 内<br>1 &lt;= Node.val &lt;= 50<br>0 &lt;= val &lt;= 50</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>创建一个虚拟头结点，从这个头结点的下一个元素挨个判断，如果满足条件则跳过该节点，否则顺序遍历到最后一个元素，最终返回虚拟头结点的下一个节点即可。（因为原头结点可能被删除了）</p></blockquote><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode newhead=<span class="keyword">new</span> ListNode();</span><br><span class="line">newhead.next=head;</span><br><span class="line">ListNode tmp = newhead;</span><br><span class="line"><span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.next.val == val) &#123;</span><br><span class="line">tmp.next = tmp.next.next;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newhead.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-linked-list/">https://leetcode-cn.com/problems/design-linked-list/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能</p><ol><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ol></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>太基础了，没啥好说的…<br>注意index是从0开始索引</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">LinkList next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkList</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">LinkList head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">head = <span class="keyword">new</span> LinkList(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">LinkList tmp = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">addAtIndex(size, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">size++;</span><br><span class="line">LinkList tmp = head;</span><br><span class="line">LinkList addnum = <span class="keyword">new</span> LinkList(val);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line">addnum.next = tmp.next;</span><br><span class="line">tmp.next = addnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">LinkList tmp = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line">tmp.next = tmp.next.next;</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="链表1"></p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：head = [1,2]<br>输出：[2,1]<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="链表2"></p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：head = []<br>输出：[]</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;= Node.val &lt;= 5000</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>双指针 一图懂<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="双指针反转"></p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">ListNode cur = head;</span><br><span class="line">ListNode tmp;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">tmp = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>来源：（Leecode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：head = []<br>输出：[]</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：head = [1]<br>输出：[1]</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;= Node.val &lt;= 100</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>递归实现</p><ol><li>返回值：交换完成的子链表</li><li>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换</li><li>终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换    <h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode next=head.next;</span><br><span class="line">head.next=swapPairs(next.next);</span><br><span class="line">next.next=head;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h1>来源:(Leetcode)<br>链接:<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="删除链表"><br>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2>输入：head = [1], n = 1<br>输出：[]<h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h2>输入：head = [1,2], n = 1<br>输出：[1]<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2>链表中结点的数目为 sz<br>1 &lt;= sz &lt;= 30<br>0 &lt;= Node.val &lt;= 100<br>1 &lt;= n &lt;= sz</li></ol></blockquote><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>你能尝试使用一趟扫描实现吗？</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点的下一个节点就可以了。<br>由于头结点也可能被删除，所以我们创建一个虚拟头结点，让fast和slow初始状态都指向dummy节点，将虚拟头结点的下一个节点作为返回值。</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">ListNode fast = dummy;</span><br><span class="line">ListNode slow = dummy;</span><br><span class="line"><span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) fast = fast.next;</span><br><span class="line"><span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line">slow.next=slow.next.next;</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="相交1"><br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须<strong>保持其原始结构</strong>。</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="事例1"><br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="事例2"><br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><h2 id="示例-3-4"><a href="#示例-3-4" class="headerlink" title="示例 3"></a>示例 3</h2><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="事例3"><br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;= m, n &lt;= 3 * 104<br>1 &lt;= Node.val &lt;= 105<br>0 &lt;= skipA &lt;= m<br>0 &lt;= skipB &lt;= n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</p></blockquote><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>力扣—相交链表题解：我走完我的路，就去走你的路，你走完你的路，再来走我的路，如果我们有缘的话，就会在人生的十字路口相遇，然后一起走完剩下的路，如果我们没机会相遇的话，就在各自的路上当孤勇者吧</p><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">ListNode girl = headA;</span><br><span class="line">ListNode boy = headB;</span><br><span class="line"><span class="keyword">while</span> (boy != girl) &#123;</span><br><span class="line">girl = girl == <span class="keyword">null</span> ? headB : girl.next;</span><br><span class="line">boy = boy == <span class="keyword">null</span> ? headA : boy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改 链表。</p><h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="环链表1"><br>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="2"><br>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><h2 id="示例-3-5"><a href="#示例-3-5" class="headerlink" title="示例 3"></a>示例 3</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="3"><br>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;= Node.val &lt;= 105<br>pos 的值为 -1 或者链表中的一个有效索引</p></blockquote><h2 id="进阶-2"><a href="#进阶-2" class="headerlink" title="进阶"></a>进阶</h2><p>你是否可以使用 O(1) 空间解决此题？</p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>相遇的情况<br>设链表共有 a+b 个节点，其中链表头部到链表入口有a个节点（不计链表入口节点），链表环有b个节点，设两指针分别走了f，s步，则有f=2s。而在环内相遇也就是f比s多走了n圈，即f=s+nb，解得f=2nb，s=nb。<br>一个指针从头走到环口需要的步数是k=a+nb，而f和s在环内相遇的步数是nb，所以也就是s再走a步，即可到达环口，所以我们在头结点再定义一个指针，当它与s相遇的时候，那个节点就是环口。</li><li>不相遇的情况<br>不相遇也就是无环，既fast==null或fast.next==null<h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode fast = head;</span><br><span class="line">ListNode slow = head;</span><br><span class="line">ListNode result = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (result != slow) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">result = result.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/01/18/Array/"/>
      <url>/2022/01/18/Array/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>设定左右指针</li><li>找出中间位置，并判断该位置值是否等于 target</li><li>nums[mid] == target 则返回该位置下标</li><li>nums[mid] &gt; target 则右侧指针移到中间</li><li>nums[mid] &lt; target 则左侧指针移到中间</li></ul></blockquote><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num=nums[mid];</span><br><span class="line"><span class="keyword">if</span>(num==target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num)</span><br><span class="line">right=mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num)</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:<br>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);<br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 50<br>0 &lt;= val &lt;= 100</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>由于题目中要求删除等于val的元素，所以我们最终返回的数组长度肯定小于原数组长度。所以我们可以直接把返回的数组覆盖在原数组上。使用双指针，右指针依次遍历数组元素，左指针用来赋值。</p><ul><li>如果右指针的值不等于val，那我们就把这个值赋给左指针所指位置，同时左右指针都后移一位</li><li>如果右指针的值等于val，那我们就只把右指针往后移一位，左指针不动<br>然后我们就能保证在[0,left)这个区间内的所有元素都不等于val，当右指针遍历完数组之后，left的值就是题目要求的返回值。<h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (val != nums[i]) &#123;</span><br><span class="line">nums[left] = nums[i];</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按 非递减顺序 排序</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>请你设计时间复杂度为 O(n) 的算法解决本问题</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>暴力解法就是先平方再排序，这里说明一下时间复杂度为O(n)的解法。<br>首先，平方的最大值肯定是在两头出现，所以我们采用双指针，一个指向0位置，一个指向n-1位置。每次比较二者取正的最大值，将其平方后逆序放进数组即可。</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">while</span> (index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(-nums[left]&gt;nums[right])&#123;</span><br><span class="line">res[index--]=nums[left]*nums[left];</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">res[index--]=nums[right]*nums[right];</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：target = 4, nums = [1,4,4]<br>输出：1</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]<br>输出：0</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= target &lt;= 109<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 105</p><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>还是采用双指针，最短长度minlength先初始化为Integer.MAX_VALUE，初始状态两个指针都指向第一个元素，然后往后依次挪动右指针，然后记录两个指针之间的值的和。当两个指针间的和满足要求时(sum&gt;=target)，记录当前的最短长度(minlength=Math.min(minlength,right-left))。然后左指针往后挪，同时sum-=num[left]，始终保证sum是左右指针之间的值的和，依次遍历数组，每次符合条件的时候比较一下最短长度minlength即可。</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minlength=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (right&lt;nums.length)&#123;</span><br><span class="line">sum+=nums[right++];</span><br><span class="line"><span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">minlength=Math.min(minlength,right-left);</span><br><span class="line">sum-=nums[left++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minlength==Integer.MAX_VALUE?<span class="number">0</span>:minlength;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="螺旋数组"><br>输入：n = 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：n = 1<br>输出：[[1]]</p><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= n &lt;= 20</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>生成一个n×n的矩阵，然后开始模拟向内环绕的填入过程即可<br>设定上下左右四个边界(left,right,top,down)，初始值num=1，终止条件num==n*n<br>按照从左往右 从上往下 从右往左 从下往上 顺序循环<br>以从左往右为例，每次执行的操作：填入num，num++，然后更新边界。从左往右填完之后，上边界+1，也就是从下一行继续从左往右填入。<br>其他的也一样，从上往下填完之后，右边界-1，从左一列继续从上往下填；从右往左填完之后，下边界-1，从上一行继续从右往左；从下往上填完之后，左边界+1，从右一列继续从下往上填. 也就是一圈一圈向内收缩</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, down = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">arr[top][i] = num++;</span><br><span class="line">top++;<span class="comment">//下一行行从左到右</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= down; i++)</span><br><span class="line">arr[i][right] = num++;</span><br><span class="line">right--;<span class="comment">//左一列从上到下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">arr[down][i] = num++;</span><br><span class="line">down--;<span class="comment">//上一行从右到左</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">arr[i][left] = num++;</span><br><span class="line">left++;<span class="comment">//右一列从下到上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/01/11/GreedyMethod/"/>
      <url>/2022/01/11/GreedyMethod/</url>
      
        <content type="html"><![CDATA[<h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/assign-cookies">https://leetcode-cn.com/problems/assign-cookies</a></p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p></blockquote><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= g.length &lt;= 3 <em> 104<br>0 &lt;= s.length &lt;= 3 </em> 104<br>1 &lt;= g[i], s[j] &lt;= 231 - 1</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>将小孩和饼干从小到大依次排序，想要吃饱的孩子最多，那就要尽可能的避免浪费。<br>这里的局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。<br>所以我们可以从小到大依次遍历饼干数组，如果发现能喂饱当前孩子，则对下一个孩子开始投喂，最终能喂到第几个孩子，结果就是几了。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">Arrays.sort(g);<span class="comment">//孩子</span></span><br><span class="line">Arrays.sort(s);<span class="comment">//饼干</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;<span class="comment">//从小到大依次遍历饼干，将饼干喂给孩子</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; g.length &amp;&amp; s[i] &gt;= g[index])<span class="comment">//只要没遍历到最后一个孩子，且饼干能喂饱当前孩子</span></span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="买卖彩票的最佳时机"><a href="#买卖彩票的最佳时机" class="headerlink" title="买卖彩票的最佳时机"></a>买卖彩票的最佳时机</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入: prices = [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= prices.length &lt;= 3 * 104<br>0 &lt;= prices[i] &lt;= 104</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>这道题「贪心」的地方在于，对于「今天的股价 - 昨天的股价」，得到的结果有3种可能：正数，负数，零，贪心的算法决策是：<strong>只加正数</strong></p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">result += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game-ii">https://leetcode-cn.com/problems/jump-game-ii</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p></blockquote><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: nums = [2,3,1,1,4]<br>输出 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: nums = [2,3,0,1,4]<br>输出: 2</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 104<br>0 &lt;= nums[i] &lt;= 1000</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>逆向思维，从最后一个位置跳回去，每次跳尽可能大的距离，来保证跳的步数最小。<br>也就是从左往右开始遍历，看看哪个位置可以一步跳到结果（i+nums[i]&gt;=currentIndex），然后在找这一步的上一步，只要没到达起点，就一直执行下去。</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> currentIndex = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentIndex; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + nums[i] &gt;= currentIndex) &#123;</span><br><span class="line">step++;</span><br><span class="line">currentIndex = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game">https://leetcode-cn.com/problems/jump-game</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p></blockquote><h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p><h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 3 * 104<br>0 &lt;= nums[i] &lt;= 105</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>如果某一个作为<strong>起跳点</strong>的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为<strong>起跳点</strong>（i&lt;=currentMaxLength）</li><li>可以对每一个能作为<strong>起跳点</strong>的格子都尝试跳一次，把<strong>能跳到最远的距离</strong>不断更新（currentMaxLength=Math.max(currentMaxLength,i+nums[i])）</li><li>如果可以一直跳到最后，就成功了（currentMaxLength&gt;=nums.length-1）</li></ol><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> currentMaxLength=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=currentMaxLength)</span><br><span class="line">currentMaxLength=Math.max(currentMaxLength,i+nums[i]);</span><br><span class="line"><span class="keyword">if</span>(currentMaxLength&gt;=nums.length-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p><p>输出: 3</p><p>解释<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入:<br>gas  = [2,3,4]<br>cost = [3,4,3]</p><p>输出: -1</p><p>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>当gas的总和小于cost的总和时，无论从哪里出发，都一定不能环绕形势一周</li><li>gas[i]-cost[i]为当天剩下的油，i从0开始计算，累加到最后一站的时候，如果累加没有出现负数，说明从0出发，油没有断过，那么0就是起点。如果油断了，即出现负数，累加清零，将下一个点作为起点重新开始计算。<strong>局部最优：</strong>当前累加gas[i]-cost[i]的和currentGas一旦小于0，起始位置至少要是i+1，因为从i开始一定不行。<strong>全局最优：</strong>找到可以跑一圈的起始位置。</li><li>如下图所示，当我们已经判断了能环绕一周之后，即有a+b+c+d+e&gt;=0</li></ol><p><img src="/img/加油站.png" alt="加油站"></p><blockquote><p>对于例子1，按照步骤2的计算<br>a<0 出现负数，将下一个点作为起点重新计算b>0 b+c<0 出现负数，将下一个点作为起点重新计算c<0 出现负数，将下一个点作为起点重新计算d>0 d+e&gt;0 没有出现负数，d既是结果<br>说明：我们已经判断了能环绕一周，根据上式：a<0 b+c<0 我们能得出 a+b+c<0 又d+e>0 a+b+c+d+e&gt;=0 得出d+e+a+b+c 这个顺序也就是从d出发 环绕一周能满足油不断<br>对于例子2，大家可以自行验证一下，这里不予赘述</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> currentGas = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sumGas = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">currentGas += gas[i] - cost[i];</span><br><span class="line">sumGas += gas[i] - cost[i];</span><br><span class="line"><span class="keyword">if</span> (currentGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">start = i + <span class="number">1</span>;</span><br><span class="line">currentGas = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sumGas &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/candy/">https://leetcode-cn.com/problems/candy/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：ratings = [1,0,2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p><h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：ratings = [1,2,2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>n == ratings.length<br>1 &lt;= n &lt;= 2 <em> 104<br>0 &lt;= ratings[i] &lt;= 2 </em> 104</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><p>把一个大问题拆分为两个小问题，要保证相邻两个孩子评分更高的孩子会获得更多的糖果，那这个相邻可以是左相邻或者是右相邻。</p><ol><li>从左到右依次遍历，比较右孩子评分比左孩子评分高的情况，如果右孩子的分数高，那他的糖果就比左孩子多一颗，否则的话把他的糖果初始化为1颗，保证每个孩子都有糖果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; candy.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> candy[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>从右向左遍历，比较左孩子评分比右孩子评分高的情况，如果左孩子的分数高，那他的糖果数在右孩子的基础上加一颗，但是由于之前我们已经对所有孩子的糖果进行了初始化，原先的糖果已经满足了第一种情况，所以这次的糖果分配不能破坏第一种情况的规则，所以左孩子的糖果数应该是比较该孩子在第一种情况下的糖果数，和在他右边孩子的糖果数加一，取一个最大值。如果我没有叙述清楚的话，看一下代码就懂了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = candy.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>])</span><br><span class="line">candy[i] = Math.max(candy[i], candy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>本题采用了两次贪心的策略：<br>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。<br>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。<br>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。<h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] candy = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">candy[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; candy.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> candy[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = candy.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>])</span><br><span class="line">candy[i] = Math.max(candy[i], candy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s : candy)</span><br><span class="line">sum += s;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lemonade-change/">https://leetcode-cn.com/problems/lemonade-change/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。</p><h2 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：bills = [5,5,10]<br>输出：true<br>示例 4：<br>输入：bills = [10,10]<br>输出：false</p><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= bills.length &lt;= 105<br>bills[i] 不是 5 就是 10 或是 20 </p><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><p>5美元不用找零<br>10美元需要1张5美元找零<br>20美元需要1张10美元和1张5美元找零，或者3张5美元找零，我们优先选择用1张10美元和一张5美元找零。<br>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！<br>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> five = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bills[i] == <span class="number">5</span>)</span><br><span class="line">five++;</span><br><span class="line"><span class="keyword">if</span> (bills[i] == <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> (five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ten++;</span><br><span class="line">five--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ten--;</span><br><span class="line">five--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>)</span><br><span class="line">five -= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><h2 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</p><h2 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= people.length &lt;= 2000<br>0 &lt;= hi &lt;= 106<br>0 &lt;= ki &lt; people.length<br>题目数据确保队列可以被重建</p><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们按照身高降序排列，如果身高相同，按照k值升序排列（这里我们需要重写一下compare方法），题目中的k值是该人前面有k个身高大于等于他的，所以排好序之后，依次按照k值进行插入即可。</p><h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1[<span class="number">0</span>]==o2[<span class="number">0</span>]?o1[<span class="number">1</span>]-o2[<span class="number">1</span>]:o2[<span class="number">0</span>]-o1[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">List list=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] person:people)&#123;</span><br><span class="line">list.add(person[<span class="number">1</span>],person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>[][]) list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改用Lambda表达式</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">Arrays.sort(people, (o1, o2) -&gt; o1[<span class="number">0</span>]==o2[<span class="number">0</span>]?o1[<span class="number">1</span>]-o2[<span class="number">1</span>]:o2[<span class="number">0</span>]-o1[<span class="number">0</span>]);</span><br><span class="line">List list=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] person:people)&#123;</span><br><span class="line">list.add(person[<span class="number">1</span>],person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>[][]) list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。<br>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。<br>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><h2 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p><h2 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：points = [[1,2],[3,4],[5,6],[7,8]]<br>输出：4</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：points = [[1,2],[2,3],[3,4],[4,5]]<br>输出：2</p><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2><p>输入：points = [[1,2]]<br>输出：1</p><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h2><p>输入：points = [[2,3],[2,3]]<br>输出：1</p><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= points.length &lt;= 104<br>points[i].length == 2<br>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</p><h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2><p>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。<br>按照气球的右边界升序排列，然后依次比较相邻两个气球，看看区间是否有重叠（前面区间的结束点&gt;=后面区间的起点），如果区间出现重叠，则将后面区间的结束点更新为前面区间的结束点。如果没有重叠区间，则箭数+1。<br><img src="/img/射爆气球.png" alt="射气球"><br>核心代码就是这段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">arrows++;</span><br><span class="line"><span class="keyword">else</span> points[i][<span class="number">1</span>] = points[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arrows = <span class="number">1</span>;</span><br><span class="line">Arrays.sort(points, Comparator.comparingInt(o -&gt; o[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">arrows++;</span><br><span class="line"><span class="keyword">else</span> points[i][<span class="number">1</span>] = points[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrows;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><h2 id="问题叙述-9"><a href="#问题叙述-9" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。<br>注意:<br>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><h2 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入: [ [1,2], [2,3], [3,4], [1,3] ]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><h2 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入: [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p><h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3:"></a>示例 3:</h2><p>输入: [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><h2 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h2><p>跟上题的思路一样，先按照右边界进行排序，当相邻两个区间存在交集时，更新后面集合的结束点。</p><h2 id="代码提交-9"><a href="#代码提交-9" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> remove=<span class="number">0</span>;</span><br><span class="line">Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) </span><br><span class="line"><span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">remove++;</span><br><span class="line">intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> remove;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划(DP)</title>
      <link href="/2022/01/07/DP/"/>
      <url>/2022/01/07/DP/</url>
      
        <content type="html"><![CDATA[<h1 id="印章"><a href="#印章" class="headerlink" title="印章"></a>印章</h1><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行两个正整数n和m</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数P表示答案，保留4位小数。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>2 3</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>0.7500</p><h2 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h2><p>1≤n，m≤20</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先建立一个二维数组 dp[m][n]<br>数组中的每个元素dp[i][j]表示买i张集齐j种的概率(假设数组下标从1开始，方便理解)<br>假设有3种图案，买了3张。<br>我们先来看一般情况：</p><blockquote><p>分析：n种图案，买m张，买到每种图案的概率p=1/n。当买的张数比图案总数小的时候，那必然不能集齐。也就是当i&lt;j时，dp[i][j]=0。<br><img src="/img/印章1.png" alt="i&lt;j"><br>分析：当j=1时，也就是凑齐一种即可，买一张凑齐一种的概率是1，买两张凑齐一种(这一种是任意一种，所以概率要乘以n)的概率是p^2*n，买i张凑齐一种的概率是p^i*n，又p=1/n，故买i张凑齐1中的概率是p^(i-1)。<br><img src="/img/印章2.png" alt="j=1"><br>然后再看看其他情况：<br>分析；当我们想计算2张2种的情况时，可以由1张1种的基础上，再买到不同于这1张的其余两张，也就是dp[2][2]=dp[1][1]*p*2=2/3。<br>当我们想计算3张2种的情况是，可以由2张2种的基础上，再买到1种已拥有的，或者由2张1种的情况下，买到1种未拥有的，也就是dp[3][2]=dp[2][2]*p*2+dp[2][1]*p*2=6/9。综上所述，dp[i][j]=dp[i-1][j]*(j*p)+dp[i-1][j-1]*(n-j+1)*p;(注：此解的数组下标从1开始，下文的Java代码数组下标从0开始)<br><img src="/img/印章3.png" alt="其余情况"><br>依次类推就能计算出3张3种的结果了。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line"><span class="keyword">double</span> p = <span class="number">1.0</span> / n;</span><br><span class="line"><span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[m][n];</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.0000&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = Math.pow(p, i);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] * p * (j + <span class="number">1</span>) + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (n - j) * p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(df.format(dp[m - <span class="number">1</span>][n - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="拿金币"><a href="#拿金币" class="headerlink" title="拿金币"></a>拿金币</h1><h2 id="资源限制-1"><a href="#资源限制-1" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题叙述-1"><a href="#问题叙述-1" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>有一个N x N的方格,每一个格子都有一些金币,只要站在格子里就能拿到里面的金币。你站在最左上角的格子里,每次可以从一个格子走到它右边或下边的格子里。请问如何走才能拿到最多的金币。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数n。<br>以下n行描述该方格。金币数保证是不超过1000的正整数。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>最多能拿金币数量。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>3<br>1 3 3<br>2 2 2<br>3 1 2</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>11</p><h2 id="数据规模和约定-1"><a href="#数据规模和约定-1" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h2><p>n&lt;=1000</p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>跟上题一样，先建立一个二维数组dp[n][n]<br>数组中的每个元素dp[i][j]表示到达该位置时，所获得的最大金币数。</p><blockquote><p>分析：一层一层遍历就好了，当j==0时，也就是在第一行，每个格子所获得的的最大金币数即为：本格子的金币数，加上左边格子所获得的的最大金币数，arr[i][j] += arr[i][j - 1];<br>当i==0时，也就是在第一列，第一列的每个格子能获取到的最大金币数为：本格子的金币数，加上上方格子的获取到的最大金币数，arr[i][j] += arr[i - 1][j];。（图示仅限于方便理解，实际上是一层一层出结果的，不是图中先把第一行第一列的结果算完。）<br><img src="/img/吃金币1.png" alt="一条道走到黑"><br>当我们算到中间格子时，就出现了选择，要想获取最大金币数，那就应该用本格的金币数，加上MAX（上边格子，左边格子），很显然选择上边格子能获取到最大金币数。也就是<br>arr[i][j] += Math.max(arr[i - 1][j], arr[i][j - 1]);<br><img src="/img/吃金币2.png" alt="最优吃金币"></p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">dp[i][j] += Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[n-<span class="number">1</span>][n-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence">https://leetcode-cn.com/problems/wiggle-subsequence</a></p><h2 id="问题叙述-2"><a href="#问题叙述-2" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。<br>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。<br>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。<br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7</p><h2 id="解释：这个序列包含几个长度为-7-摆动序列。"><a href="#解释：这个序列包含几个长度为-7-摆动序列。" class="headerlink" title="解释：这个序列包含几个长度为 7 摆动序列。"></a>解释：这个序列包含几个长度为 7 摆动序列。</h2><p>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：nums = [1,2,3,4,5,6,7,8,9]<br>输出：2</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 1000<br>0 &lt;= nums[i] &lt;= 1000</p><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>up[i]表示 从0~i中 最后两个数字是递增的最长摆动序列<br>down[i]表示 从0~i中 最后两个数字是递减的最长摆动序列<br>下面进行分类讨论<br>nums[i+1]&gt;nums[i] 最后两个数字是递增的 nums[i-1]和nums[i]</p></blockquote><p>拿示例2举例</p><blockquote><p>17&gt;1         up = down+1 = 2<br>5<17         down = up+1 = 3 10>5         up = down+1 = 4<br>13&gt;10       up = down+1 = 4<br>15&gt;13       up = down+1 = 4<br>10<15       down = up+1 = 55<10         down = up+1 = 516>5         up = down+1 = 6<br>8&lt;16         down = up+1 = 7<br>连续的up操作或者down操作是无效的 数据不会更新<br>只有up和down交替操作 数据才会更新 从而达到摆动序列的效果</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">up = down + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>])</span><br><span class="line">down = up + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="number">0</span> : Math.max(up, down);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></p><h2 id="问题叙述-3"><a href="#问题叙述-3" class="headerlink" title="问题叙述"></a>问题叙述</h2><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><h2 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><h2 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1]<br>输出：1</p><h2 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：nums = [5,4,-1,7,8]<br>输出：23</p><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104</p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>创建一个等长的一维数组dp[nums.length]<br>数组中的每一个元素dp[i]是以nums[i]结尾的最大子序列和<br>初始化dp[0]=nums[0]<br>则状态转移方程为dp[i]=Math.max(dp[i-1]+nums[i],nums[i])<br>每次遍历完一个元素之后 实时保存一下最大值 最后作为结果返回即可</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">dp[i]=Math.max(nums[i], dp[i - <span class="number">1</span>]+nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></p><h2 id="问题叙述-4"><a href="#问题叙述-4" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 n ，请计算 F(n) 。</p><h2 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：n = 2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><h2 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：n = 3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><h2 id="示例-3-2"><a href="#示例-3-2" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：n = 4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= n &lt;= 30</p><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>状态转移方程题目中已经给出<br>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h2 id="问题叙述-5"><a href="#问题叙述-5" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h2 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ul><li>1 阶 + 1 阶</li><li>2 阶<h2 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2"></a>示例 2</h2>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</li><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2>1 &lt;= n &lt;= 45<h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2>dp[i]表示到达第i阶台阶的种数<br>到达第i阶台阶 只能由第i-1阶走一步 或者i-2阶走两步<br>所以到第i阶的种数 就是第i-1阶和第i-2阶的种数之和<br>状态转移方程     dp[i] = dp[i - 1] + dp[i - 2];<br>初始化             dp[1] = 1;  dp[2] = 2;<h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p><h2 id="问题叙述-6"><a href="#问题叙述-6" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。<br>请你计算并返回达到楼梯顶部的最低花费。</p><h2 id="示例-1-4"><a href="#示例-1-4" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。<br>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>总花费为 15 。</p><h2 id="示例-2-4"><a href="#示例-2-4" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p><ul><li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2>2 &lt;= cost.length &lt;= 1000<br>0 &lt;= cost[i] &lt;= 999<h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2>dp[i]表示到达第i阶台阶的最小花费<br>由于可以从下标0或下标1起步<br>那么就可以初始化dp[0] = 0;  dp[1] = 0;<br>状态转移方程 dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);<br>到达第i阶台阶<br>可以由第i-1阶台阶 花费cost[i-1]到达<br>也可由第i-2阶台阶 花费cost[i-2]到达<br>从二者中取最小值<h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cost.length; i++) &#123;</span><br><span class="line">dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[cost.length];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a><h2 id="问题叙述-7"><a href="#问题叙述-7" class="headerlink" title="问题叙述"></a>问题叙述</h2>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<h2 id="示例-1-5"><a href="#示例-1-5" class="headerlink" title="示例 1"></a>示例 1</h2><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""><br>输入：m = 3, n = 7<br>输出：28<h2 id="示例-2-5"><a href="#示例-2-5" class="headerlink" title="示例 2"></a>示例 2</h2>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</li></ul><ol><li>向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向下<h2 id="示例-3-3"><a href="#示例-3-3" class="headerlink" title="示例 3"></a>示例 3</h2>输入：m = 7, n = 3<br>输出：28<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2>输入：m = 3, n = 3<br>输出：6<h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10^9<h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2>dp[i][j]表示 走到第i行第j列 的路径条数<br>第一行和第一列只有一种走法 所以初始化为1即可<br>由于只能往右走和往下走<br>所以每个位置 只能由其上方或者左方走来<br>所以状态转移方程为  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><h2 id="问题叙述-8"><a href="#问题叙述-8" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><h2 id="示例-1-6"><a href="#示例-1-6" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt=""><br>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<h2 id="示例-2-6"><a href="#示例-2-6" class="headerlink" title="示例 2"></a>示例 2</h2><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt=""><br>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1<h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2>m == obstacleGrid.length<br>n == obstacleGrid[i].length<br>1 &lt;= m, n &lt;= 100<br>obstacleGrid[i][j] 为 0 或 1<h2 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h2>跟上题一样 不过在初始化时 需要判断当前位置不是障碍物<h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line"><span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h1>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a><h2 id="问题叙述-9"><a href="#问题叙述-9" class="headerlink" title="问题叙述"></a>问题叙述</h2>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。<br>返回 你可以获得的最大乘积 。<h2 id="示例-1-7"><a href="#示例-1-7" class="headerlink" title="示例 1"></a>示例 1</h2>输入: n = 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。<h2 id="示例-1-8"><a href="#示例-1-8" class="headerlink" title="示例 1"></a>示例 1</h2>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2>2 &lt;= n &lt;= 58<h2 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h2>dp[i] 表示将i拆解为若干个整数 获得的最大乘积值<br>由于题目中的范围是[2,58]<br>所以我们先初始化 dp[2] = 1;<br>如何得到dp[i]<br>j从1到i-1遍历<br>dp[i] = i <em> (i - j) 或者 dp[i] = j </em> dp[i - j]<br>每次遍历从中取最大值<br>所以状态转移方程为 dp[i] = Math.max(dp[i], Math.max(j <em> (i - j), j </em> dp[i - j]));<h2 id="代码提交-9"><a href="#代码提交-9" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><h2 id="问题叙述-10"><a href="#问题叙述-10" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h2 id="示例-1-9"><a href="#示例-1-9" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p><h2 id="示例-2-7"><a href="#示例-2-7" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 100</p><h2 id="思路分析-10"><a href="#思路分析-10" class="headerlink" title="思路分析"></a>思路分析</h2><p>转化为01背包问题<br>dp[j]表示容量为j的背包 从前i个元素中任取 能装下的最大物品之和<br>如果数组之和为奇数 则不可能分为两个和相等的子集 直接return false;<br>最终我们判断容量为sum/2的背包 最多能装下多少物品</p><h2 id="也就是-return-dp-sum-2-sum-2"><a href="#也就是-return-dp-sum-2-sum-2" class="headerlink" title="也就是 return dp[sum/2] == sum/2;"></a>也就是 return dp[sum/2] == sum/2;</h2><p>状态转移方程分析<br>每种数字只有取与不取两种状态<br>如果不取的话 那么dp[j]保持上一步的状态即可<br>如果取的话 需要腾出对应的空间 也就是在dp[j-nums[i]]的基础上 数字所占空间nums[i]<br>所以状态转移方程为<br>一维：dp[j] = Math.max(dp[j], dp[j - num] + num);<br>二维：dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);</p><h2 id="代码提交-10"><a href="#代码提交-10" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> target = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - num] + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target] == target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = nums[<span class="number">0</span>]; j &lt;= target; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= nums[i])</span><br><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i]] + nums[i]);</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][target] == target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">https://leetcode-cn.com/problems/last-stone-weight-ii/</a></p><h2 id="问题叙述-11"><a href="#问题叙述-11" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p><h2 id="示例-1-10"><a href="#示例-1-10" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：stones = [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><h2 id="示例-2-8"><a href="#示例-2-8" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：stones = [31,26,33,21,40]<br>输出：5</p><h2 id="示例-3-4"><a href="#示例-3-4" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：stones = [1,2]<br>输出：1</p><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 100</p><h2 id="思路分析-11"><a href="#思路分析-11" class="headerlink" title="思路分析"></a>思路分析</h2><p>转化为01背包问题<br>题目想要最后一块石头的重量最小<br>那我们就把石头分成两堆  使两堆石头的质量差值最小即可<br>那我们就可以把问题转化为 容量为sum/2的背包 最多能装下多重的石头<br>设这背包的最大重量为A<br>那另一堆的重量为sum-A<br>题目所求则是 sum-A-A=sum-2A</p><h2 id="将sum-2A作为最终结果返回即可"><a href="#将sum-2A作为最终结果返回即可" class="headerlink" title="将sum-2A作为最终结果返回即可"></a>将sum-2A作为最终结果返回即可</h2><p>状态转移方程分析<br>每种物品只有取与不取两种状态<br>如果不取的话 那么dp[j]保持上一步的状态即可<br>如果取的话 需要腾出对应的空间 也就是在dp[j-stones[i]]的基础上 加上石头的质量stones[i]<br>所以状态转移方程为<br>一维：dp[j] = Math.max(dp[j], dp[j - num] + num);<br>二维：dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);</p><h2 id="代码提交-11"><a href="#代码提交-11" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">sum += stone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum - <span class="number">2</span> * dp[target];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">sum += stone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length][target + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = stones[<span class="number">0</span>]; j &lt;= target; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = stones[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= stones[i])</span><br><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i]] + stones[i]);</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum - <span class="number">2</span> * dp[stones.length - <span class="number">1</span>][target];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p><h2 id="问题叙述-12"><a href="#问题叙述-12" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 nums 和一个整数 target 。<br>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：<br>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><h2 id="示例-1-11"><a href="#示例-1-11" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p><h2 id="示例-2-9"><a href="#示例-2-9" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：nums = [1], target = 1<br>输出：1</p><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-1000 &lt;= target &lt;= 1000</p><h2 id="思路分析-12"><a href="#思路分析-12" class="headerlink" title="思路分析"></a>思路分析</h2><p>转化为01背包问题<br>题目意思是 随便加 加减符号 求凑出某个数的方法数<br>那我们就可以把这堆数 分为两个子集 然后做差 使差值为target<br>两个子集A和B<br>A + B = sum<br>A - B = target<br>2 * A = sum + target<br>A = (sum + target) / 2<br>每个A都对应着唯一的B和target 所以我们求出能凑出A的所有子集种类即可<br>dp[j] 表示填满容量为j的背包 有多少种方法<br>填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。<br>所以状态转移方程为 dp[j] += dp[j - nums[i]]</p><h2 id="代码提交-12"><a href="#代码提交-12" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">0</span>) size = -size;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">https://leetcode-cn.com/problems/ones-and-zeroes/</a></p><h2 id="问题叙述-13"><a href="#问题叙述-13" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。<br>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><h2 id="示例-1-12"><a href="#示例-1-12" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><h2 id="示例-2-10"><a href="#示例-2-10" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：strs = [“10”, “0”, “1”], m = 1, n = 1<br>输出：2<br>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= strs.length &lt;= 600<br>1 &lt;= strs[i].length &lt;= 100<br>strs[i] 仅由 ‘0’ 和 ‘1’ 组成<br>1 &lt;= m, n &lt;= 100</p><h2 id="思路分析-13"><a href="#思路分析-13" class="headerlink" title="思路分析"></a>思路分析</h2><p>转化为01背包问题 只不过有两个背包容量<br>dp[i][j]表示 使用i个0 j个1的情况下，可以得到的最大字符串数量<br>如果i &lt; 当前字符串的ZeroCount 或者 j &lt; 当前字符串的OneCount 则不能选取当前字符串 dp[i][j]保持不变<br>如果i &gt;= 当前字符串的ZeroCount 且 j &gt;= 当前字符串的OneCount 则可以选取当前字符串 也就是dp[i - ZeroCount][j - OneCount]+1<br>从这两种情况中 取最大字符串数量<br>所以状态转移方程为 dp[i][j] = Math.max(dp[i - OneCount][j - ZeroCount]+1, dp[i][j]);</p><h2 id="代码提交-13"><a href="#代码提交-13" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line"><span class="keyword">int</span> ZeroCount = <span class="number">0</span>, OneCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) ZeroCount++;</span><br><span class="line"><span class="keyword">else</span> OneCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= ZeroCount; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= OneCount; j--) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i - ZeroCount][j - OneCount] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h1><p>来源：力扣（Leetcode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><h2 id="问题叙述-14"><a href="#问题叙述-14" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。<br>假设每一种面额的硬币有无限个。<br>题目数据保证结果符合 32 位带符号整数。</p><h2 id="示例-1-13"><a href="#示例-1-13" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p><h2 id="示例-2-11"><a href="#示例-2-11" class="headerlink" title="示例 2"></a>示例 2</h2><p>输入：amount = 3, coins = [2]<br>输出：0<br>解释：只用面额 2 的硬币不能凑成总金额 3 。</p><h2 id="示例-3-5"><a href="#示例-3-5" class="headerlink" title="示例 3"></a>示例 3</h2><p>输入：amount = 10, coins = [10]<br>输出：1</p><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;= coins.length &lt;= 300<br>1 &lt;= coins[i] &lt;= 5000<br>coins 中的所有值 互不相同<br>0 &lt;= amount &lt;= 5000</p><h2 id="思路分析-14"><a href="#思路分析-14" class="headerlink" title="思路分析"></a>思路分析</h2><p>完全背包问题 每个元素可以无限取 正序遍历<br>dp[j] 表示凑成总金额j的货币组合数为 dp[j]<br>dp[j] 就是所有的dp[j - coins[i]]相加<br>所以状态转移方程为：dp[j] += dp[j - coins[i]];</p><h2 id="代码提交-14"><a href="#代码提交-14" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法训练 </tag>
            
            <tag> 动态规划(DP) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯入门习题</title>
      <link href="/2022/01/06/lanqiao/"/>
      <url>/2022/01/06/lanqiao/</url>
      
        <content type="html"><![CDATA[<h1 id="数列排序"><a href="#数列排序" class="headerlink" title="数列排序"></a>数列排序</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T52">http://lx.lanqiao.cn/problem.page?gpid=T52</a></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200<br>输入格式<br>　　第一行为一个整数n。<br>　　第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。<br>输出格式<br>　　输出一行，按从小到大的顺序输出排序后的数列。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>8 3 6 4 9</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>3 4 6 8 9</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n= scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i]= scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T50">http://lx.lanqiao.cn/problem.page?gpid=T50</a>   </p><h2 id="资源限制-1"><a href="#资源限制-1" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。<br>　　注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>FFFF</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>65535</p><h2 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String hex= scan.next();</span><br><span class="line">System.out.println(Long.valueOf(hex,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T49">http://lx.lanqiao.cn/problem.page?gpid=T49</a></p><h2 id="资源限制-2"><a href="#资源限制-2" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。<br>　　给出一个非负整数，将它表示成十六进制的形式。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出这个整数的16进制表示</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><p>30</p><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><p>1E</p><h2 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> target= scan.nextInt();</span><br><span class="line">System.out.println(Integer.toHexString(target).toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特殊回文数"><a href="#特殊回文数" class="headerlink" title="特殊回文数"></a>特殊回文数</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T48">http://lx.lanqiao.cn/problem.page?gpid=T48</a></p><h2 id="资源限制-3"><a href="#资源限制-3" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　123321是一个非常特殊的数，它从左边读和从右边读是一样的。<br>　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入一行，包含一个正整数n。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　按从小到大的顺序输出满足条件的整数，每个整数占一行。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><p>52</p><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>899998<br>989989<br>998899</p><h2 id="代码提交-3"><a href="#代码提交-3" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n= scan.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i+j+k+j+i)==n)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+i+j+k+j+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i+j+k+k+j+i)==n)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+i+j+k+k+j+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T47">http://lx.lanqiao.cn/problem.page?gpid=T47</a></p><h2 id="资源限制-4"><a href="#资源限制-4" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　按从小到大的顺序输出满足条件的四位十进制数。</p><h2 id="代码提交-4"><a href="#代码提交-4" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+i+j+j+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h1><p>来源：<a href="http://lx.lanqiao.cn/problem.page?gpid=T46">http://lx.lanqiao.cn/problem.page?gpid=T46</a></p><h2 id="资源限制-5"><a href="#资源限制-5" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1<em>1</em>1+5<em>5</em>5+3<em>3</em>3。编程求所有满足这种条件的三位十进制数。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。</p><h2 id="代码提交-5"><a href="#代码提交-5" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a=i/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b=i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c=i%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>((a*a*a+b*b*b+c*c*c)==i)</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h1><h2 id="资源限制-6"><a href="#资源限制-6" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h2><p>杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。</p><p>　　<br>它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。</p><p>　　<br>下面给出了杨辉三角形的前4行：</p><p>　　<br>   1</p><p>　　<br>  1 1</p><p>　　<br> 1 2 1</p><p>　　<br>1 3 3 1</p><p>　　<br>给出n，输出它的前n行。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个数n。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。<br>样例输入<br>4</p><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><p>1<br>1 1<br>1 2 1<br>1 3 3 1</p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n &lt;= 34。</p><h2 id="代码提交-6"><a href="#代码提交-6" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i ; j++) &#123;</span><br><span class="line">arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找整数"><a href="#查找整数" class="headerlink" title="查找整数"></a>查找整数</h1><h2 id="资源限制-7"><a href="#资源限制-7" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数n。</p><p>第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。</p><p>第三行包含一个整数a，为待查找的数。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><p>6<br>1 9 4 8 3 9<br>9</p><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p><h2 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n &lt;= 1000。</p><h2 id="代码提交-7"><a href="#代码提交-7" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n=scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i]= scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> target=scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(target==arr[i])&#123;</span><br><span class="line">result=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数列特征"><a href="#数列特征" class="headerlink" title="数列特征"></a>数列特征</h1><h2 id="资源限制-8"><a href="#资源限制-8" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出n个数，找出这n个数的最大值，最小值，和。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为整数n，表示数的个数。</p><p>第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>1 3 -2 4 5</p><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><p>5<br>-2<br>11</p><h2 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n &lt;= 10000。</p><h2 id="代码提交-8"><a href="#代码提交-8" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = scanner.nextInt();</span><br><span class="line">sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(arr[n-<span class="number">1</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字母图形"><a href="#字母图形" class="headerlink" title="字母图形"></a>字母图形</h1><h2 id="资源限制-9"><a href="#资源限制-9" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h2><p>利用字母可以组成一些美丽的图形，下面给出了一个例子：</p><p>ABCDEFG</p><p>BABCDEF</p><p>CBABCDE</p><p>DCBABCD</p><p>EDCBABC</p><p>这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出n行，每个m个字符，为你的图形。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 7</p><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><p>ABCDEFG<br>BABCDEF<br>CBABCDE<br>DCBABCD<br>EDCBABC</p><h2 id="数据规模与约定-3"><a href="#数据规模与约定-3" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n, m &lt;= 26。</p><h2 id="代码提交-9"><a href="#代码提交-9" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line"><span class="keyword">char</span>[][] result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> min =<span class="number">26</span>;</span><br><span class="line"><span class="keyword">while</span> (--min&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">result[min][min] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> tmp1=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> tmp2=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = min+<span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">result[min][i]=++tmp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j=min-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">result[min][j]=++tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">System.out.print(result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01字串"><a href="#01字串" class="headerlink" title="01字串"></a>01字串</h1><h2 id="资源限制-10"><a href="#资源限制-10" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：</p><p>00000</p><p>00001</p><p>00010</p><p>00011</p><p>00100</p><p>请按从小到大的顺序输出这32种01串。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>本试题没有输入。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出32行，按从小到大的顺序每行一个长度为5的01串。</p><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><p>00000<br>00001<br>00010<br>00011<br>&lt;以下部分省略&gt;</p><h2 id="代码提交-10"><a href="#代码提交-10" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; l++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">2</span>; m++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + i + j + k + l + m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闰年判断"><a href="#闰年判断" class="headerlink" title="闰年判断"></a>闰年判断</h1><h2 id="资源限制-11"><a href="#资源限制-11" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个年份，判断这一年是不是闰年。</p><p>当以下情况之一满足时，这一年是闰年：</p><ol><li><p>年份是4的倍数而不是100的倍数；</p></li><li><p>年份是400的倍数。</p></li></ol><p>其他的年份都不是闰年。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个整数y，表示当前的年份。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><p>2013</p><h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><p>no</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><p>2016</p><h2 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h2><p>yes</p><h2 id="数据规模与约定-4"><a href="#数据规模与约定-4" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1990 &lt;= y &lt;= 2050。</p><h2 id="代码提交-11"><a href="#代码提交-11" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> year=scan.nextInt();</span><br><span class="line"><span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h1><h2 id="资源限制-12"><a href="#资源限制-12" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h2><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个整数n。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个整数，表示Fn除以10007的余数。</p><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p><h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><p>10</p><h2 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h2><p>55</p><h2 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h2><p>22</p><h2 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h2><p>7704</p><h2 id="数据规模与约定-5"><a href="#数据规模与约定-5" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n &lt;= 1,000,000。</p><h2 id="代码提交-12"><a href="#代码提交-12" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] resule = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">resule[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">resule[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">resule[i] = ((resule[i - <span class="number">1</span>] + resule[i - <span class="number">2</span>]) % <span class="number">10007</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(resule[n - <span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="圆的面积"><a href="#圆的面积" class="headerlink" title="圆的面积"></a>圆的面积</h1><h2 id="资源限制-13"><a href="#资源限制-13" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-13"><a href="#问题描述-13" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定圆的半径r，求圆的面积。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个整数r，表示圆的半径。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。</p><h2 id="说明：在本题中，输入是一个整数，但是输出是一个实数。"><a href="#说明：在本题中，输入是一个整数，但是输出是一个实数。" class="headerlink" title="说明：在本题中，输入是一个整数，但是输出是一个实数。"></a>说明：在本题中，输入是一个整数，但是输出是一个实数。</h2><p>对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须严格的输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。</p><h2 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h2><p>4</p><h2 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h2><p>50.2654825</p><h2 id="数据规模与约定-6"><a href="#数据规模与约定-6" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= r &lt;= 10000。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。</p><h2 id="代码提交-13"><a href="#代码提交-13" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.PI*r*r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DecimalFormat df=<span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.0000000&quot;</span>);</span><br><span class="line">Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> r=scan.nextInt();</span><br><span class="line">System.out.println(df.format(Area(r)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="序列求和"><a href="#序列求和" class="headerlink" title="序列求和"></a>序列求和</h1><h2 id="资源限制-14"><a href="#资源限制-14" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s   内存限制：256.0MB</p><h2 id="问题描述-14"><a href="#问题描述-14" class="headerlink" title="问题描述"></a>问题描述</h2><p>求1+2+3+…+n的值。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包括一个整数n。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包括一个整数，表示1+2+3+…+n的值。</p><h2 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h2><p>4</p><h2 id="样例输出-14"><a href="#样例输出-14" class="headerlink" title="样例输出"></a>样例输出</h2><p>10</p><h2 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h2><p>100</p><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>有一些试题会给出多组样例输入输出以帮助你更好的做题。<br>一般在提交之前所有这些样例都需要测试通过才行，但这不代表这几组样例数据都正确了你的程序就是完全正确的，潜在的错误可能仍然导致你的得分较低。</p><h2 id="样例输出-15"><a href="#样例输出-15" class="headerlink" title="样例输出"></a>样例输出</h2><p>5050</p><h2 id="数据规模与约定-7"><a href="#数据规模与约定-7" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>1 &lt;= n &lt;= 1,000,000,000。</p><h2 id="代码提交-14"><a href="#代码提交-14" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Sum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> + n) * n / <span class="number">2</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">long</span> n = scan.nextLong();</span><br><span class="line">System.out.println(Sum(n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java---多线程</title>
      <link href="/2021/12/25/Thread/"/>
      <url>/2021/12/25/Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念-程序、进程、线程"><a href="#基本概念-程序、进程、线程" class="headerlink" title="基本概念: 程序、进程、线程"></a>基本概念: 程序、进程、线程</h1><ul><li><p>程序(program): 为完成特定任务、用某种语言编写的一组指令的集合。即指<strong>一段静态的代码</strong>，静态对象。</p></li><li><p>进程(process): 是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p>线程(thread):  线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p></li><li><p>简而言之：<strong>一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</strong></p></li></ul><p><img src="/img/进程.png" alt="进程"></p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><img src="https://gitee.com/lsqpic/BlogPicBed-1/raw/master/img/2021/01/16/20210123234436.jpg" alt="进程与线程"></p><h3 id="单核CPU与多核CPU的理解"><a href="#单核CPU与多核CPU的理解" class="headerlink" title="单核CPU与多核CPU的理解"></a>单核CPU与多核CPU的理解</h3><ul><li><p>单核CPU其实是一种假的多线程，因为在一个时间单元内只能执行一个线程的任务。举个不恰当的例子：我在打英雄联盟，同时要在QQ跟两个妹子聊天。游戏是全屏的，所以必须要切屏出去回消息。我就好比是一个单核CPU，在一个时间单元只能执行一个线程任务，所以只能一边打游戏一边切屏出去回复两个妹子(<del>就当是提升游戏难度了</del>)，如若游戏里死了(<del>不可能的</del>)或者妹子还没回复我，那我就可以把她们”挂起”(<del>晾着她，等她回我了，再搭理她</del>)。但是由于我切屏回复的速度非常快，所以妹子感觉不出来我在多线操作。</p></li><li><p>如果是多核CPU的话，就用Python写个糊弄学大师，把QQ和脚本挂我云服务器上，这样脚本帮我回复妹子，我可以专心打游戏，我与脚本各司其职。</p></li><li><p>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p></li></ul><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul><li>并行：多核cpu运行。多线程时，真正的在同一时刻运行。</li><li>并发：单核cpu运行多线程时，时间片进行很快的切换，线程轮流执行cpu。(抢票/秒杀活动)</li></ul><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><p>用多线程只有一个目的，那就是更好的利用CPU的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应”多角色”的程序代码，最起码每个角色要给他一个线程，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的”生产者，消费者模型”(下文会详细说明)。</p><h1 id="线程的创建与使用"><a href="#线程的创建与使用" class="headerlink" title="线程的创建与使用"></a>线程的创建与使用</h1><h2 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h2><ul><li>Java语言的JVM允许程序运行多个线程，他通过java.lang.Thread类来体现。</li><li>Thread类的特性<ol><li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，通常把run()方法的主体称为线程体</li><li>通过Thread对象的start()方法而不是run()方法来启动这个线程，而非直接调用run()</li></ol></li></ul><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><ol><li>Thread()：创建新的Thread对象</li><li>Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</li><li>Thread(String threadname)：创建线程并指定线程实例名</li><li>Thread(Runnable target, String threadname)：创建新的Thread对象</li></ol><h2 id="创建多线程的方式一：继承Thread类"><a href="#创建多线程的方式一：继承Thread类" class="headerlink" title="创建多线程的方式一：继承Thread类"></a>创建多线程的方式一：继承Thread类</h2><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread的run()方法 —-&gt; 将此线程的方法声明在run()中</li><li>创建Thread类的子对象</li><li>通过此对象调用start()<br>例子：创建一个线程，遍历100以内的所有偶数，创建匿名子类实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">//2.重写Thread的run()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//3.创建Thread类的子对象</span></span><br><span class="line">MyThread mythread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//此步骤是将创建的线程命名为&quot;线程1-&quot; 方便观察结果对比</span></span><br><span class="line">mythread.setName(<span class="string">&quot;线程1-&quot;</span>);</span><br><span class="line"><span class="comment">//4.通过此对象调用start()</span></span><br><span class="line">mythread.start();</span><br><span class="line"><span class="comment">//创建Thread类的匿名子类的方式</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">//将main()命名为主线程-</span></span><br><span class="line">Thread.currentThread().setName(<span class="string">&quot;主线程-&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">部分运行结果：</span><br><span class="line">Thread-<span class="number">170</span></span><br><span class="line">Thread-<span class="number">180</span></span><br><span class="line">主线程-<span class="number">5</span></span><br><span class="line">线程<span class="number">1</span>-<span class="number">36</span></span><br><span class="line">线程<span class="number">1</span>-<span class="number">38</span></span><br><span class="line">主线程-<span class="number">7</span></span><br><span class="line">Thread-<span class="number">190</span></span><br><span class="line">Thread-<span class="number">1100</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">显而易见，三个线程的运行结果之间存在交叉(没有出现交叉的请多执行几遍)</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>例子：创建三个窗口卖票，总票数为100张 (存在线程安全问题，后面会解决)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w1 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w2 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w3 = <span class="keyword">new</span> Window();</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里的static 三个窗口共卖100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票号&quot;</span>+ticket--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">部分输出结果：</span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">7</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">5</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">1</span></span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/img_convert/7a640e36cea308b9eeaabe6e715eb4bd.png" alt="理想状态"><br>若在输出语句之前加上sleep(10)，让线程进入if判断语句之后休眠10ms，则会导致下面的运行结果,出现重票和错票。<br>一个线程进入if判断语句之后休眠了，还没有完成自减的操作，此时另一个线程也进来了，一次判断导致了两次自减，所以就会出现了重票和错票的现象。<br>解决办法就是加个锁(同步监视器)，一个线程执行过程中，不让别的线程进来就好了，下文会提供解决办法。<br><img src="https://img-blog.csdnimg.cn/img_convert/3b3d209bdf2c3351f5f525a73eacea0a.png" alt="极端状态"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">0</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">1</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="Thread类的有关方法"><a href="#Thread类的有关方法" class="headerlink" title="Thread类的有关方法"></a>Thread类的有关方法</h2><ol><li>start():启动当前线程，执行当前线程的run()</li><li>run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>currentThread(): 静态方法，返回当前代码执行的线程</li><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li><li>yield():释放当前CPU的执行权</li><li>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到<strong>线程b完全执行完以后</strong>，线程a才结束阻塞状态。</li><li>stop():<strong>已过时</strong>。当执行此方法时，强制结束当前线程。</li><li>sleep(long millitime)：让当前线程”睡眠”指定时间的millitime(毫秒)。在指定的millitime毫秒时间内，当前线程是阻塞状态的。</li><li>isAlive()：返回boolean，判断线程是否还活着</li></ol><p>前五个方法已经在刚刚的代码中使用过了，这里着重介绍后五个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread01 myThread01 = <span class="keyword">new</span> MyThread01();</span><br><span class="line">myThread01.start();</span><br><span class="line">        <span class="comment">//输出线程存活状态</span></span><br><span class="line">System.out.println(myThread01.isAlive());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;张&quot;</span> + i);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//每次输出之后休眠10ms</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//输出张10之后，将myThread01线程执行完</span></span><br><span class="line">myThread01.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//输出线程存活状态</span></span><br><span class="line">System.out.println(myThread01.isAlive());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//当i==2时，释放当前CPU的执行权，等待分配</span></span><br><span class="line">                <span class="comment">//也可以理解为抢球，谁抢到就谁执行</span></span><br><span class="line">MyThread01.yield();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(getName() + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">张<span class="number">0</span></span><br><span class="line">张<span class="number">1</span></span><br><span class="line">Thread-<span class="number">00</span></span><br><span class="line">Thread-<span class="number">01</span></span><br><span class="line">张<span class="number">2</span></span><br><span class="line">张<span class="number">3</span></span><br><span class="line">Thread-<span class="number">02</span></span><br><span class="line">张<span class="number">4</span></span><br><span class="line">Thread-<span class="number">03</span></span><br><span class="line">Thread-<span class="number">04</span></span><br><span class="line">张<span class="number">5</span></span><br><span class="line">张<span class="number">6</span></span><br><span class="line">Thread-<span class="number">05</span></span><br><span class="line">Thread-<span class="number">06</span></span><br><span class="line">张<span class="number">7</span></span><br><span class="line">张<span class="number">8</span></span><br><span class="line">Thread-<span class="number">07</span></span><br><span class="line">张<span class="number">9</span></span><br><span class="line">Thread-08</span><br><span class="line">张<span class="number">10</span></span><br><span class="line">Thread-09</span><br><span class="line">Thread-<span class="number">010</span></span><br><span class="line">Thread-<span class="number">011</span></span><br><span class="line">Thread-<span class="number">012</span></span><br><span class="line">Thread-<span class="number">013</span></span><br><span class="line">Thread-<span class="number">014</span></span><br><span class="line">Thread-<span class="number">015</span></span><br><span class="line">Thread-<span class="number">016</span></span><br><span class="line">Thread-<span class="number">017</span></span><br><span class="line">Thread-018</span><br><span class="line">Thread-019</span><br><span class="line">张<span class="number">11</span></span><br><span class="line">张<span class="number">12</span></span><br><span class="line">张<span class="number">13</span></span><br><span class="line">张<span class="number">14</span></span><br><span class="line">张<span class="number">15</span></span><br><span class="line">张<span class="number">16</span></span><br><span class="line">张<span class="number">17</span></span><br><span class="line">张<span class="number">18</span></span><br><span class="line">张<span class="number">19</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><ul><li>调度策略<ul><li>时间片</li><li>抢占式：高优先级的线程抢占CPU<br><img src="https://img-blog.csdnimg.cn/img_convert/df274b909314af5c7603df80e60c64f9.png" alt="时间片"></li></ul></li><li>同优先级的线程采用先进先出的队列模式，使用时间片策略</li><li>对于高优先级，使用优先调度的抢占式策略</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><ul><li>线程的优先级等级<ul><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5 —-&gt;默认优先级</li></ul></li><li>涉及的方法<ul><li>getPriority() ：返回线程优先值</li><li>setPriority(intnewPriority) ：改变线程的优先级</li></ul></li><li>说明:高优先级的线程要抢占低优先级线程cpu的执行权。<ul><li>但是只是从概率上讲，高优先级的线程高概率的情况下被执行。</li><li>并不意味着只有当高优先级的线程执行完以后，低优先级的线程才会被执行。</li></ul></li></ul><h2 id="创建多线程的方式二：实现Runnable接口"><a href="#创建多线程的方式二：实现Runnable接口" class="headerlink" title="创建多线程的方式二：实现Runnable接口"></a>创建多线程的方式二：实现Runnable接口</h2><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法:run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><p>将上面的练习改写成用Runnable接口实现的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTicket</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">Window window = <span class="keyword">new</span> Window();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里不需要加static</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法:run()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">部分运行结果：</span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">5</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">0</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号-<span class="number">1</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="继承方式和实现方式的联系与区别"><a href="#继承方式和实现方式的联系与区别" class="headerlink" title="继承方式和实现方式的联系与区别"></a>继承方式和实现方式的联系与区别</h2><ul><li>比较上述两种创建线程的方式<ul><li>开发中：优先选择实现Runnable接口的方式</li><li>原因：没有类的单继承性的局限性，实现方式更适合来处理多个线程共享数据的情况。</li></ul></li><li>联系：Thread类也实现了Runnable接口 -&gt; public class Thread implements Runnable</li><li>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操作和功能</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b29133ad93d3839d259de57bbfa1397a.png" alt="生命周期"></p><h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><blockquote><p>Java中的线程分为两类，一种是守护线程，一种是用户线程</p></blockquote><ul><li>它们在几乎每个方面都是相同的，唯一的区别是JVM何时离开</li><li>守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成守护线程</li><li>Java垃圾回收就是一个典型的守护线程。</li><li>若JVM中都是守护线程，当前JVM将退出。</li></ul><h2 id="同步代码块处理实现Runnable接口的线程安全问题"><a href="#同步代码块处理实现Runnable接口的线程安全问题" class="headerlink" title="同步代码块处理实现Runnable接口的线程安全问题"></a>同步代码块处理实现Runnable接口的线程安全问题</h2><blockquote><p>例子:创建三个窗口卖票，总票数为100张.使用实现RunnabLe接口的方式</p><ol><li>卖票过程中出现重票、错票 —-&gt; 出现了线程的安全问题</li><li>问题出现的原因:当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票</li><li>如何解决:当一个线程在操作ticket的时候，其他线程不能参与进来。直到线程操作完ticket时，其他线程才可以操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li><li>在java中，我们通过同步机制，来解决线程的安全问题。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码</span></span><br><span class="line"><span class="comment">//同步是一种高开销的操作，因此应该尽量减少同步的内容。 </span></span><br><span class="line"><span class="comment">//通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTicket</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window window = <span class="keyword">new</span> Window();</span><br><span class="line">Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//Object object=new Object();</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//synchronized (object)&#123;</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">部分执行结果：</span><br><span class="line"></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">5</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">4</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">3</span>-卖票号<span class="number">1</span></span><br><span class="line"></span><br><span class="line">可以看到已经不存在重票和错票的情况了</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ol><li>操作共享数据的代码，即为需要被同步的代码—-&gt;不能包含代码多了，也不能包含代码少了。</li><li>共享数据:多个线程共同操作的变量。比如: ticket就是共享数据</li><li>同步监视器，俗称:锁。任何一个类的对象，都可以来充当锁。要求:多个线程必须要共用同一把锁。 </li><li>补充:在实现RunnabLe接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li></ol></blockquote><h2 id="同步代码块处理继承Thread类的线程安全问题"><a href="#同步代码块处理继承Thread类的线程安全问题" class="headerlink" title="同步代码块处理继承Thread类的线程安全问题"></a>同步代码块处理继承Thread类的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w1 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w2 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w3 = <span class="keyword">new</span> Window();</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//声明一个静态的obj也可以当锁</span></span><br><span class="line"><span class="comment">//private static Object object = new Object();</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//synchronized (object) &#123;</span></span><br><span class="line"><span class="comment">//注意这里不能用this，此时的this指的是w1，w2，w3三个对象，并不是唯一的</span></span><br><span class="line"><span class="comment">//这里使用的是类锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (Window.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">部分执行结果：</span><br><span class="line"></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">7</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">6</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">5</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">2</span>-卖票号<span class="number">1</span></span><br><span class="line"></span><br><span class="line">可以看到已经不存在重票和错票的情况了</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同步方法处理实现Runnable的线程安全问题"><a href="#同步方法处理实现Runnable的线程安全问题" class="headerlink" title="同步方法处理实现Runnable的线程安全问题"></a>同步方法处理实现Runnable的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方式二:同步方法</span><br><span class="line">如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的</span><br><span class="line">同步的方式，解决了线程的安全问题。---好处</span><br><span class="line">操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。---局限性</span><br><span class="line">使用 <span class="keyword">synchronized</span>关键字，可以修饰普通方法、静态方法，以及语句块。由于java的每个对象都有一个内置锁，</span><br><span class="line">当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</span><br><span class="line">需要注意的是调用静态方法时，锁住的不是对象，锁住的是类。</span><br><span class="line"><span class="comment">//修饰普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修饰静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTicket</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window window = <span class="keyword">new</span> Window();</span><br><span class="line">Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!show())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修饰普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">部分执行结果：</span><br><span class="line"></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">6</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">5</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">4</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">3</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>-卖票号<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同步方法处理继承Thread类的线程安全问题"><a href="#同步方法处理继承Thread类的线程安全问题" class="headerlink" title="同步方法处理继承Thread类的线程安全问题"></a>同步方法处理继承Thread类的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w1 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w2 = <span class="keyword">new</span> Window();</span><br><span class="line">Window w3 = <span class="keyword">new</span> Window();</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!show())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修饰静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">//同步监视器：Window4.class</span></span><br><span class="line"><span class="comment">//private boolean show() &#123;       同步监视器：t1,t2,t3。此种解决方式是错误的,仍会出现重票错票</span></span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><blockquote><p>银行有一个账户。<br>有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。<br>分析:</p><ol><li>是否是多线程问题？ 是，两个储户线程</li><li>是否有共享数据？ 有，账户(或账户余额)</li><li>是否有线程安全问题？ 有</li><li>需要考虑如何解决线程安全问题？ 同步机制:有三种方式。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">SaveMoney</span><span class="params">(<span class="keyword">double</span> cash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cash &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">money += cash;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;存入&quot;</span> + cash + <span class="string">&quot;元，当前余额&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.account = account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">account.SaveMoney(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="number">0</span>);</span><br><span class="line">Customer c1 = <span class="keyword">new</span> Customer(account);</span><br><span class="line">Customer c2 = <span class="keyword">new</span> Customer(account);</span><br><span class="line">c1.setName(<span class="string">&quot;客户1-&quot;</span>);</span><br><span class="line">c2.setName(<span class="string">&quot;客户2-&quot;</span>);</span><br><span class="line">c1.start();</span><br><span class="line">c2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">客户<span class="number">1</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">1000.0</span>元</span><br><span class="line">客户<span class="number">1</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">2000.0</span>元</span><br><span class="line">客户<span class="number">1</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">3000.0</span>元</span><br><span class="line">客户<span class="number">2</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">4000.0</span>元</span><br><span class="line">客户<span class="number">2</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">5000.0</span>元</span><br><span class="line">客户<span class="number">2</span>-存入<span class="number">1000.0</span>元，当前余额<span class="number">6000.0</span>元</span><br></pre></td></tr></table></figure><h2 id="死锁的问题"><a href="#死锁的问题" class="headerlink" title="死锁的问题"></a>死锁的问题</h2><blockquote><p>演示线程的死锁</p><ol><li>死锁的理解:不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁(<del>两个死傲娇互相暗恋，都在等对方先表白，形成死锁</del>)</li><li>说明:出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续，所以我们使用同步时，要避免出现死锁。</li><li>解决办法：专门的算法、原则(尽可能避免出现死锁)，尽量减少同步资源的定义，尽量避免嵌套同步。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，当第一个线程拿到s1锁的时候，休眠了0.1秒的时间内，第二个线程拿到了s2锁。当第一个线程醒了之后，需要拿s2锁，而第二个线程拿着s2锁，又需要拿s1锁，于是两个线程就僵持下去，形成死锁。(加sleep()方法只是增加发生的可能性，不加sleep()方法也有几率会发生死锁)</p></blockquote><h2 id="Lock锁的方式解决线程安全问题"><a href="#Lock锁的方式解决线程安全问题" class="headerlink" title="Lock锁的方式解决线程安全问题"></a>Lock锁的方式解决线程安全问题</h2><ul><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>ReentrantLock类实现了Lock ，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li><li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li></ul><blockquote><p>synchronized 与Lock的异同？</p><ol><li>相同:二者都可以解决线程安全问题</li><li>不同: synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器，Lock需要手动的启动同步(Lock())，同时结束同步也需要手动的实现(unLock())</li><li>优先使用顺序: Lock &gt;&gt; 同步代码块 &gt;&gt; 同步方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTicket</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window window = <span class="keyword">new</span> Window();</span><br><span class="line">Thread w1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">Thread w3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">w1.setName(<span class="string">&quot;窗口1-&quot;</span>);</span><br><span class="line">w2.setName(<span class="string">&quot;窗口2-&quot;</span>);</span><br><span class="line">w3.setName(<span class="string">&quot;窗口3-&quot;</span>);</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2.调用锁定方法：lock()</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票号&quot;</span> + ticket--);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p>线程通信的例子:使用两个线程打E1-100。线程l，线程2交替打印</p><blockquote><p>涉及到的三个方法:<br>wait():—旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。<br>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。<br>notifyALL()：—旦执行此方法，就会唤醒所有被wait的线程。<br>说明:</p><ol><li>wait(),notify(),notifyALl()三个方法<strong>必须使用在同步代码块或同步方法中</strong>。</li><li>wait(),notify(),notifyAlL()三个方法的调用者<strong>必须是同步代码块或同步方法中的同步监视器</strong>。否则，会出现ILLegaLMonitorstateException异常</li><li>wait(),notify(),notifyAll()三个方法是定义在java.Lang.object类中。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Number number = <span class="keyword">new</span> Number();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(number);</span><br><span class="line">t1.setName(<span class="string">&quot;线程一：&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;线程二：&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//2.唤醒被wait的线程，从而达到两个线程交替运行的效果</span></span><br><span class="line">notify();</span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + num++);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.使得调用如下wait()方法的线程进入阻塞状态,并释放锁</span></span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sleep-和wait-的异同"><a href="#sleep-和wait-的异同" class="headerlink" title="sleep()和wait()的异同"></a>sleep()和wait()的异同</h3><blockquote><p>相同点</p><ul><li>一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>不同点</li><li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li></ul></blockquote><h2 id="经典例题：生产者-消费者问题"><a href="#经典例题：生产者-消费者问题" class="headerlink" title="经典例题：生产者/消费者问题"></a>经典例题：生产者/消费者问题</h2><blockquote><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产;如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p><p>这里可能出现两个问题:</p><ol><li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li><li>消费者比生产者快时，消费者会取相同的数据。</li></ol><p>分析:</p><ol><li>是否是多线程的问题？      是，生产者的线程，消费者的线程</li><li>是否有共享数据的问题？      是，店员、产品、产品数</li><li>如何解决线程的安全问题？    同步机制，有三种方法</li><li>是否涉及线程的通信？        是</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">InProduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (productCount &lt; <span class="number">20</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在生产第&quot;</span> + (++productCount) + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">notify();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">SaleProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (productCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在购买第&quot;</span> + (productCount--) + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">notify();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">clerk.InProduction();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">clerk.SaleProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">Producer producer = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer(clerk);</span><br><span class="line">producer.setName(<span class="string">&quot;生产者-&quot;</span>);</span><br><span class="line">customer.setName(<span class="string">&quot;消费者-&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line">customer.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建多线程的方式三：实现Callable接口"><a href="#创建多线程的方式三：实现Callable接口" class="headerlink" title="创建多线程的方式三：实现Callable接口"></a>创建多线程的方式三：实现Callable接口</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建饥荒专用服务器</title>
      <link href="/2021/12/20/server/"/>
      <url>/2021/12/20/server/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>闲得无聊买了三年的腾讯云服务器，以后游戏挂机刷东西就可以在服务器上完成了<del>再也不用担心游戏本扰民了</del></p><p>用Python的pyautogui库可以完成许多重复性工作(可以模拟达到按键精灵的效果)</p><p>本文先简要描述一下搭建饥荒专用服务器的流程(steam版)</p><p>以下是本文所需的全部文件</p><p>提取码: 9527  <a class="btn-beautify pink large" href="https://pan.baidu.com/s/1XIaqVzuWrkGAa3wZKd1WyQ"   title="百度网盘下载链接"><i class="far fa-hand-point-right"></i><span>百度网盘下载链接</span></a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>不多说，先买好云服务器(我买的腾讯云)  <a class="btn-beautify blue large" href="https://cloud.tencent.com/act/new?from=15616"   title="戳这里"><i class="far fa-hand-point-right"></i><span>戳这里</span></a></p><p>然后修改密码</p><p><img src="/img/修改密码.png" alt="修改密码"></p><p>复制公网IP，并通过win10的远程桌面链接，连接到云服务器上</p><p><img src="/img/公网IP.png" alt="公网IP"> <img src="/img/远程连接.png" alt="远程连接"></p><p>然后将网盘下载好的内容复制到<strong>服务器</strong>的 文档 目录下</p><p><img src="/img/此电脑.png" alt="此电脑"></p><p>打开steamcmd文件夹，然后双击里面的.exe文件进行安装</p><p>打开脚本文件夹，以管理员身份运行里面的update文件</p><p>然后在<strong>自己电脑</strong>上新创建一个世界，到达选人物界面断开连接即可</p><p><img src="/img/断开.png" alt="断开连接"></p><p>将刚创建的存档<strong>复制到服务器</strong>的  C:\Users\Administrator\Documents\Klei\DoNotStarveTogether  目录下</p><p>并将存档名改为 “Cluster_1” 进入该存档 创建一个”cluster_token.txt”文本文件</p><p><img src="/img/令牌.png" alt="令牌"></p><p>从<strong>自己的电脑</strong>上复制mod文件  在 steam\steamapps\common\Don’t Starve Together\mods 目录下和 steam\steamapps\workshop\content\322330均是</p><p>将所有的mod名改成<strong>workshop-nums</strong>的形式(例：workshop-8516651315)  并复制所有mod</p><p><img src="/img/复制就好.png" alt="steam mods"></p><p><img src="/img/修改.png" alt="修改"></p><p>粘贴到云服务器的  C:\Users\Administrator\Documents\steamcmd\steamapps\common\Don’t Starve Together Dedicated Server\mods  目录下</p><p>实际上只需要复制你开服用的mod就行，但为了日后方便，还是将所有的mod都复制过来比较稳妥，这个过程可能耗时很长，请耐心等待</p><p>完成上述操作之后，将脚本文件中的start和startcave文件复制到<br>C:\Users\Administrator\Documents\steamcmd\steamapps\common\Don’t Starve Together Dedicated Server\bin 目录下并运行</p><p><img src="/img/完成图.png" alt="完成图"></p><p>运行完毕后，大功告成，在自己电脑上测试，看看能否搜到刚创建的服务器</p><p><img src="/img/大功告成.png" alt="大功告成"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Don&#39;t Starve Together </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/2021/11/10/SortMenu/"/>
      <url>/2021/11/10/SortMenu/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>排序算法是《数据结构与算法》中最基本的算法之一。</p><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，</p><p>而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><p>用一张图概括：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="排序算法稳定性图片"></p><h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p><p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p><p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 </p><p>希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p><h2 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><p>名词解释：</p><ul><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，</p><p>因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，</p><p>它的工作原理是通过构建有序序列，对于未排序数据，</p><p>在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入(折半插入)。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。</p><p>（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p><p>由于没有改变两个元素的相对顺序，所以插入排序是稳定的）</p><p><del>跟斗地主一样,左起第一张牌当成有序序列，第二张牌到最后一张当成是无序序列。</del></p><p><del>从头到尾依次扫描未排序的牌，将扫描到的每一张牌插入到有序序列的适当位置。</del></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="插入排序"></p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//第一张牌有序，所以从第二张牌开始往前比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">//把这张牌拿在手里</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">//j=i-1是手牌的前一张，只要还没到最左边的牌，就一直比较下去</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="comment">//如果前面的牌比手牌大，那就把前面的牌往后移</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//j = j + 1;</span></span><br><span class="line"><span class="comment">//arr[j] = temp;</span></span><br><span class="line">arr[++j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序过程及效率"><a href="#排序过程及效率" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/直接插入排序.png" alt="直接插入排序"></p><h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><h2 id="直接插入排序的优化——折半插入排序"><a href="#直接插入排序的优化——折半插入排序" class="headerlink" title="直接插入排序的优化——折半插入排序"></a>直接插入排序的优化——折半插入排序</h2><p>查找采用折半查找方法，称为二分插入排序或折半插入排序。</p><p>二分插入排序算法的原理和插入排序算法原理一样，都是把要插入的数作为手牌，</p><p>只不过优化了查找要插入位置的算法进行二分，与中间(m=(low+hgih)/2)的数值作比较，</p><p>小则high=m-1，反之low=m+1,一直到low&gt;high,high+1为要插入的位置。</p><p><del>学会这种方法，斗地主插牌就比别人快啦</del></p><h3 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binInsertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= temp)</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">high++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[high] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-1"><a href="#排序过程及效率-1" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/折半插入排序.png" alt="折半插入排序"></p><h2 id="—-2"><a href="#—-2" class="headerlink" title="—-"></a>—-</h2><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，</p><p>待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>将n个元素分成d个组：</p><p>{R[0]  ,R[d],  R[2d], ···  ,R[kd]  }</p><p>{R[1]  ,R[1+d],  R[1+2d], ···  ,R[1+kd] }</p><p>···</p><p>{R[d-1]  ,R[2d-1],  R[3d-1], ···  ,R[(k+1)d-1]}</p><p>相距d个位置的元素分为一组，然后在组内完成排序</p><p>① d=arr.length/2</p><p>② 将排序序列分为d个组，在组内进行直接插入排序</p><p>③ 递减d=d/2，重复②，直到d=0</p><p>由于算法最后一趟对所有元素进行了直接插入排序，所以结果是一定正确的</p><p>由于不同组别可能存在两个或若干个相同的元素，在各自组内直接插入排序之后，</p><p>可能会导致相等元素在排序之后的相对位置发生改变，所以希尔排序是不稳定的。</p><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="希尔排序"></p><h3 id="Java代码实现-2"><a href="#Java代码实现-2" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; length; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - step;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-2"><a href="#排序过程及效率-2" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/希尔排序.png" alt="希尔排序"></p><h2 id="—-3"><a href="#—-3" class="headerlink" title="—-"></a>—-</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，</p><p>一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p>走访数列的工作是重复地进行直到没有再需要交换，</p><p>也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。</p><p>这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡动图"></p><h3 id="Java代码演示"><a href="#Java代码演示" class="headerlink" title="Java代码演示"></a>Java代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                设定一个标记，若为true，则表示此次循环没有进行交换，</span></span><br><span class="line"><span class="comment">                也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line"><span class="comment">                例如已经顺序排好的数列。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">CreatStuScore.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-3"><a href="#排序过程及效率-3" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/冒泡排序.png" alt="冒泡排序"></p><h2 id="—-4"><a href="#—-4" class="headerlink" title="—-"></a>—-</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。</p><p>所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></p><h3 id="Java代码演示-1"><a href="#Java代码演示-1" class="headerlink" title="Java代码演示"></a>Java代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">// 总共要经过 N-1 轮比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="comment">// 每轮需要比较的次数 N-i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line"><span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp=arr[min];</span><br><span class="line">arr[min]=arr[i];</span><br><span class="line">arr[i]=arr[min];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-4"><a href="#排序过程及效率-4" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/选择排序.png" alt="选择排序"></p><h2 id="—-5"><a href="#—-5" class="headerlink" title="—-"></a>—-</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。</p><p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li><p>将序列中待排数字分为若干组，每个数字分为一组</p></li><li><p>将若干组两两合并，保证合并后的组是有序的</p></li><li><p>重复第二步操作直至剩下一组，排序完成</p></li></ul><p><img src="/img/归并步骤1.png" alt="算法步骤图1"></p><p><img src="/img/归并步骤2.png" alt="算法步骤图2"></p><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="归并排序"></p><h3 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a>Java实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(arr, arr.length);</span><br><span class="line"><span class="keyword">if</span> (temp.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (<span class="keyword">int</span>) Math.floor(temp.length / <span class="number">2</span>);</span><br><span class="line"><span class="comment">//分而治之的分</span></span><br><span class="line"><span class="keyword">int</span>[] left = Arrays.copyOfRange(temp, <span class="number">0</span>, mid);</span><br><span class="line"><span class="keyword">int</span>[] right = Arrays.copyOfRange(temp, mid, temp.length);</span><br><span class="line"><span class="comment">//递归调用，将左右子序列继续分为两组，直至每组只有一个元素</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="keyword">return</span> mergeZ(mergeSortZ(left), mergeSortZ(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeZ(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//比较两个子序列中的第一个元素，将较小元素加入到结果序列中</span></span><br><span class="line"><span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//此步操作相当于剔除left序列中的第一个元素，从而诞生新的第一个元素</span></span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一方序列的元素全部加入到结果序列中后，将剩余子序列的元素全部加入到结果序列中</span></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-5"><a href="#排序过程及效率-5" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/归并排序.png" alt="归并排序"></p><h2 id="—-6"><a href="#—-6" class="headerlink" title="—-"></a>—-</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。</p><p>在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，</p><p>快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）</p><p>可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，</p><p>就是快，而且效率高！它是处理大数据最快的排序算法之一了。</p><h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>选定Pivot中心轴</li><li>将大于Pivot的数字放在Pivot的右边</li><li>将小于Pivot的数字放在Pivot的左边</li><li>分别对左右子序列重复前三步操作</li></ul><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="快速排序"></p><h3 id="Java代码实现-3"><a href="#Java代码实现-3" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSortZ(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line"><span class="keyword">int</span> left = L, right = R;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本思想</span></span><br><span class="line"><span class="comment">1.选定Pivot中心轴</span></span><br><span class="line"><span class="comment">2.将大于Pivot的数字放在Pivot的右边</span></span><br><span class="line"><span class="comment">3.将小于Pivot的数字放在Pivot的左边</span></span><br><span class="line"><span class="comment">4.分别对左右子序列重复前三部操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">//右下标对应的元素若大于pivot，则不进行操作，右下标自减</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表右下标遇到了比pivot小的元素，将该元素放到左边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴</span></span><br><span class="line"><span class="comment">//左下标对应的元素若小于pivot，则不进行操作，左下标自增</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表左下标遇到了比pivot大的元素，将该元素放到右边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[right] = arr[left];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴 将pivot放在左右下标交汇点</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">arr[left] = pivot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//递归调用，分别对左右子序列重复进行上述操作</span></span><br><span class="line">quickSortZ(arr, L, right - <span class="number">1</span>);</span><br><span class="line">quickSortZ(arr, right + <span class="number">1</span>, R);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-6"><a href="#排序过程及效率-6" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/快速排序.png" alt="快速排序"></p><h2 id="—-7"><a href="#—-7" class="headerlink" title="—-"></a>—-</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><p>本文采用的大顶堆。</p><h3 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>创建一个堆 H[0 ~ arr.length-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="堆排序动画"></p><h3 id="Java代码实现-4"><a href="#Java代码实现-4" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSortZ(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对传进来的数组拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"><span class="comment">//获取传进来的数组的长度</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">//以该数组来建一个堆</span></span><br><span class="line">buildMaxHeapZ(arr, len);</span><br><span class="line"><span class="comment">//将堆尾元素和堆首元素交换，交换到堆尾的元素已经排好序了，所以数组长度/堆长度减一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(arr, <span class="number">0</span>, i);</span><br><span class="line">len--;</span><br><span class="line">heapifyZ(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大顶堆  因为下标是从0开始 所以其实这里的len/2是最后一个非叶节点或非叶节点的下一个 但是不影响结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapZ</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapifyZ(arr, i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成将以i对应的非叶节点的数，调整成大顶堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   第一个非叶节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 调整长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapifyZ</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//根节点下标从0开始 双亲节点下标是i 子节点下标是2i+1和2i+2</span></span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左孩子的值比爹大  那就左孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有孩子的值比爹大  那就有孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大值发生了变化，则可能会产生新的最大值，进行递归调用</span></span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"><span class="comment">//将最大值对应的下标作为双亲结点</span></span><br><span class="line">swap(arr, i, largest);</span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line">heapifyZ(arr, largest, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序过程及效率-7"><a href="#排序过程及效率-7" class="headerlink" title="排序过程及效率"></a>排序过程及效率</h3><p><img src="/img/堆排序.png" alt="堆排序过程及效率"></p><h2 id="—-8"><a href="#—-8" class="headerlink" title="—-"></a>—-</h2><h2 id="Java完整代码—CreatStuScore类"><a href="#Java完整代码—CreatStuScore类" class="headerlink" title="Java完整代码—CreatStuScore类"></a>Java完整代码—CreatStuScore类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatStuScore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] scores(<span class="keyword">int</span> count) &#123;</span><br><span class="line">args=<span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; args.length) &#123;</span><br><span class="line">args[i++] = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java完整代码—FinalTest类"><a href="#Java完整代码—FinalTest类" class="headerlink" title="Java完整代码—FinalTest类"></a>Java完整代码—FinalTest类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;直接插入排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.insertSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n直接插入排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.insertSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，直接插入排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;冒泡排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.bubbleSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n冒泡排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.bubbleSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，冒泡插入排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BinInsertSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;折半插入排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.binInsertSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n折半插入排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.binInsertSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，折半插入排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.shellSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n希尔排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.shellSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，希尔排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;选择排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.selectSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n选择排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.selectSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，选择排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;快速排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">Sort.quickSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;\n快速排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.quickSortZ(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，快速排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">16</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;归并排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">arrays = Sort.mergeSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n归并排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.mergeSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，归并排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序过程</span></span><br><span class="line"><span class="keyword">int</span>[] arrays = CreatStuScore.scores(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;堆排序前:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">arrays = Sort.heapSort(arrays);</span><br><span class="line">System.out.println(<span class="string">&quot;\n堆排序后:&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line"><span class="comment">//性能测试</span></span><br><span class="line">arrays = CreatStuScore.scores(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">Sort.heapSortZ(arrays);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = end - start;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;对&quot;</span> + arrays.length + <span class="string">&quot;个随机数，堆排序耗时&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="—-9"><a href="#—-9" class="headerlink" title="—-"></a>—-</h2><h2 id="Java完整代码—Sort类"><a href="#Java完整代码—Sort类" class="headerlink" title="Java完整代码—Sort类"></a>Java完整代码—Sort类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//第一张牌有序，所以从第二张牌开始往前比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">//把这张牌拿在手里</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="comment">//从该牌的左起第一张开始比较，手牌小于左边的牌，则将左边的牌后移</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binInsertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= temp)</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">high++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[high] = temp;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; length; i++) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = i - step;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">arr[j + step] = arr[j];</span><br><span class="line">j -= step;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + step] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                设定一个标记，若为true，则表示此次循环没有进行交换，</span></span><br><span class="line"><span class="comment">                也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line"><span class="comment">                例如已经顺序排好的数列。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">// 总共要经过 N-1 轮比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> minPos = i;</span><br><span class="line"><span class="comment">// 每轮需要比较的次数 N-i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[minPos]) &#123;</span><br><span class="line"><span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">minPos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != minPos) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[minPos];</span><br><span class="line">arr[minPos] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line"><span class="keyword">int</span> left = L, right = R;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本思想</span></span><br><span class="line"><span class="comment">1.选定Pivot中心轴</span></span><br><span class="line"><span class="comment">2.将大于Pivot的数字放在Pivot的右边</span></span><br><span class="line"><span class="comment">3.将小于Pivot的数字放在Pivot的左边</span></span><br><span class="line"><span class="comment">4.分别对左右子序列重复前三部操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">//右下标对应的元素若大于pivot，则不进行操作，右下标自减</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表右下标遇到了比pivot小的元素，将该元素放到左边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴</span></span><br><span class="line"><span class="comment">//左下标对应的元素若小于pivot，则不进行操作，左下标自增</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表左下标遇到了比pivot大的元素，将该元素放到右边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[right] = arr[left];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴 将pivot放在左右下标交汇点</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">arr[left] = pivot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//递归调用，分别对左右子序列重复进行上述操作</span></span><br><span class="line">quickSort(arr, L, right - <span class="number">1</span>);</span><br><span class="line">quickSort(arr, right + <span class="number">1</span>, R);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(arr, arr.length);</span><br><span class="line"><span class="keyword">if</span> (temp.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (<span class="keyword">int</span>) Math.floor(temp.length / <span class="number">2</span>);</span><br><span class="line"><span class="comment">//分而治之的分</span></span><br><span class="line"><span class="keyword">int</span>[] left = Arrays.copyOfRange(temp, <span class="number">0</span>, mid);</span><br><span class="line"><span class="keyword">int</span>[] right = Arrays.copyOfRange(temp, mid, temp.length);</span><br><span class="line"><span class="comment">//递归调用，将左右子序列继续分为两组，直至每组只有一个元素</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(temp));</span></span><br><span class="line"><span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//比较两个子序列中的第一个元素，将较小元素加入到结果序列中</span></span><br><span class="line"><span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//此步操作相当于剔除left序列中的第一个元素，从而诞生新的第一个元素</span></span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一方序列的元素全部加入到结果序列中后，将剩余子序列的元素全部加入到结果序列中</span></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(result));</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对传进来的数组拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"><span class="comment">//获取传进来的数组的长度</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">//以该数组来建一个堆</span></span><br><span class="line">buildMaxHeap(arr, len);</span><br><span class="line"><span class="comment">//将堆尾元素和堆首元素交换，交换到堆尾的元素已经排好序了，所以数组长度/堆长度减一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(arr, <span class="number">0</span>, i);</span><br><span class="line">len--;</span><br><span class="line">heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大顶堆  因为下标是从0开始 所以其实这里的len/2是最后一个非叶节点或非叶节点的下一个 但是不影响结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(arr, i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成将以i对应的非叶节点的数，调整成大顶堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   第一个非叶节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 调整长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//根节点下标从0开始 双亲节点下标是i 子节点下标是2i+1和2i+2</span></span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左孩子的值比爹大  那就左孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有孩子的值比爹大  那就有孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大值发生了变化，则可能会产生新的最大值，进行递归调用</span></span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"><span class="comment">//将最大值对应的下标作为双亲结点</span></span><br><span class="line">swap(arr, i, largest);</span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line">heapify(arr, largest, len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//******************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//第一张牌有序，所以从第二张牌开始往前比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">//把这张牌拿在手里</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">j=i-1就是从这张牌的前一张开始比较，</span></span><br><span class="line"><span class="comment">只要还没到最左边的牌，就一直比较下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="comment">//前面的牌比手牌大，那就把前面的牌往后移</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[++j] = temp;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binInsertSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= temp)</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">high++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[high] = temp;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; length; i++) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = i - step;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">arr[j + step] = arr[j];</span><br><span class="line">j -= step;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + step] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                设定一个标记，若为true，则表示此次循环没有进行交换，</span></span><br><span class="line"><span class="comment">                也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line"><span class="comment">                例如已经顺序排好的数列。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">// 总共要经过 N-1 轮比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="comment">// 每轮需要比较的次数 N-i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line"><span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = arr[min];</span><br><span class="line">arr[min] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSortZ(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R)</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line"><span class="keyword">int</span> left = L, right = R;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本思想</span></span><br><span class="line"><span class="comment">1.选定Pivot中心轴</span></span><br><span class="line"><span class="comment">2.将大于Pivot的数字放在Pivot的右边</span></span><br><span class="line"><span class="comment">3.将小于Pivot的数字放在Pivot的左边</span></span><br><span class="line"><span class="comment">4.分别对左右子序列重复前三部操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">//右下标对应的元素若大于pivot，则不进行操作，右下标自减</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表右下标遇到了比pivot小的元素，将该元素放到左边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴</span></span><br><span class="line"><span class="comment">//左下标对应的元素若小于pivot，则不进行操作，左下标自增</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出上面的while循环，代表左下标遇到了比pivot大的元素，将该元素放到右边</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">arr[right] = arr[left];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右下标 双向奔赴 将pivot放在左右下标交汇点</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">arr[left] = pivot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//递归调用，分别对左右子序列重复进行上述操作</span></span><br><span class="line">quickSortZ(arr, L, right - <span class="number">1</span>);</span><br><span class="line">quickSortZ(arr, right + <span class="number">1</span>, R);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSortZ(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(arr, arr.length);</span><br><span class="line"><span class="keyword">if</span> (temp.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (<span class="keyword">int</span>) Math.floor(temp.length / <span class="number">2</span>);</span><br><span class="line"><span class="comment">//分而治之的分</span></span><br><span class="line"><span class="keyword">int</span>[] left = Arrays.copyOfRange(temp, <span class="number">0</span>, mid);</span><br><span class="line"><span class="keyword">int</span>[] right = Arrays.copyOfRange(temp, mid, temp.length);</span><br><span class="line"><span class="comment">//递归调用，将左右子序列继续分为两组，直至每组只有一个元素</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="keyword">return</span> mergeZ(mergeSortZ(left), mergeSortZ(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeZ(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//比较两个子序列中的第一个元素，将较小元素加入到结果序列中</span></span><br><span class="line"><span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//此步操作相当于剔除left序列中的第一个元素，从而诞生新的第一个元素</span></span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一方序列的元素全部加入到结果序列中后，将剩余子序列的元素全部加入到结果序列中</span></span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = left[<span class="number">0</span>];</span><br><span class="line">left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result[i++] = right[<span class="number">0</span>];</span><br><span class="line">right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSortZ(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对传进来的数组拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"><span class="comment">//获取传进来的数组的长度</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">//以该数组来建一个堆</span></span><br><span class="line">buildMaxHeapZ(arr, len);</span><br><span class="line"><span class="comment">//将堆尾元素和堆首元素交换，交换到堆尾的元素已经排好序了，所以数组长度/堆长度减一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(arr, <span class="number">0</span>, i);</span><br><span class="line">len--;</span><br><span class="line">heapifyZ(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大顶堆  因为下标是从0开始 所以其实这里的len/2是最后一个非叶节点或非叶节点的下一个 但是不影响结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapZ</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapifyZ(arr, i, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成将以i对应的非叶节点的数，调整成大顶堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   第一个非叶节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 调整长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapifyZ</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//根节点下标从0开始 双亲节点下标是i 子节点下标是2i+1和2i+2</span></span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左孩子的值比爹大  那就左孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有孩子的值比爹大  那就有孩子当爹</span></span><br><span class="line"><span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大值发生了变化，则可能会产生新的最大值，进行递归调用</span></span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"><span class="comment">//将最大值对应的下标作为双亲结点</span></span><br><span class="line">swap(arr, i, largest);</span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line">heapifyZ(arr, largest, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown</title>
      <link href="/2021/11/10/MarkDown/"/>
      <url>/2021/11/10/MarkDown/</url>
      
        <content type="html"><![CDATA[<h1 id="学了五分钟的MarkDown语法"><a href="#学了五分钟的MarkDown语法" class="headerlink" title="学了五分钟的MarkDown语法"></a>学了五分钟的MarkDown语法</h1><h1 id="以后可能会继续更新"><a href="#以后可能会继续更新" class="headerlink" title="以后可能会继续更新"></a>以后可能会继续更新</h1><p><a href="https://dillinger.io/">在线编译器</a></p><h2 id="1-标题语法"><a href="#1-标题语法" class="headerlink" title="1.标题语法"></a>1.标题语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标题语法</span></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试环节"><a href="#测试环节" class="headerlink" title="测试环节"></a>测试环节</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加粗</span></span><br><span class="line">**我被加粗了**</span><br><span class="line"><span class="comment">// 代码高亮</span></span><br><span class="line">==HIGH LIGHT==</span><br><span class="line"><span class="comment">// 删除线</span></span><br><span class="line">~~我被删除啦~~</span><br><span class="line"><span class="comment">// 斜体</span></span><br><span class="line">*我是斜体字*</span><br></pre></td></tr></table></figure><h3 id="测试环节-1"><a href="#测试环节-1" class="headerlink" title="测试环节"></a>测试环节</h3><p><strong>我被加粗了</strong></p><p>==HIGH LIGHT==</p><p><del>我被删除啦</del></p><p><em>我是斜体字</em></p><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用语法</span></span><br><span class="line">&gt;作者: Kyle_CyaN</span><br><span class="line">&gt;&gt;作者: Kyle_CyaN</span><br><span class="line">&gt;&gt;&gt;作者: Kyle_CyaN</span><br><span class="line">&gt;&gt;&gt;&gt;作者: Kyle_CyaN</span><br></pre></td></tr></table></figure><h3 id="测试环节-2"><a href="#测试环节-2" class="headerlink" title="测试环节"></a>测试环节</h3><blockquote><p>作者: Kyle_CyaN</p><blockquote><p>作者: Kyle_CyaN</p><blockquote><p>作者: Kyle_CyaN</p><blockquote><p>作者: Kyle_CyaN</p></blockquote></blockquote></blockquote></blockquote><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割线1</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">// 分割线2</span></span><br><span class="line">***</span><br></pre></td></tr></table></figure><h3 id="测试环节-3"><a href="#测试环节-3" class="headerlink" title="测试环节"></a>测试环节</h3><hr><hr><h2 id="5-图片插入"><a href="#5-图片插入" class="headerlink" title="5.图片插入"></a>5.图片插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线图片或本地图片</span></span><br><span class="line">![我的图片](photo/me.png)</span><br></pre></td></tr></table></figure><h3 id="测试环节-4"><a href="#测试环节-4" class="headerlink" title="测试环节"></a>测试环节</h3><p><img src="https://img2.baidu.com/it/u=1519358925,3330107491&amp;fm=26&amp;fmt=auto" alt="我的图片"></p><h2 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6.超链接"></a>6.超链接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超链接语法</span></span><br><span class="line">[这里是BILIBILI](https:<span class="comment">//www.bilibili.com/)</span></span><br></pre></td></tr></table></figure><h3 id="测试环节-5"><a href="#测试环节-5" class="headerlink" title="测试环节"></a>测试环节</h3><p><a href="https://www.bilibili.com/">哔哩哔哩</a></p><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无序列表</span></span><br><span class="line">- 目录<span class="number">1</span></span><br><span class="line">- 目录<span class="number">2</span></span><br><span class="line">- 目录<span class="number">3</span></span><br><span class="line"><span class="comment">// 有序列表</span></span><br><span class="line"><span class="number">1.</span> 目录<span class="number">4</span></span><br><span class="line"><span class="number">2.</span> 目录<span class="number">5</span></span><br><span class="line"><span class="number">3.</span> 目录<span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="测试环节-6"><a href="#测试环节-6" class="headerlink" title="测试环节"></a>测试环节</h3><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><ol><li>目录4</li><li>目录5</li><li>目录6</li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>做表格当然是用工具啦，毕竟手敲那么累<br><a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/10/hello-world/"/>
      <url>/2021/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>这是我第一次使用<a href="https://hexo.io/">Hexo</a>框架搭建博客!<br>采用的主题是<a href="https://github.com/jerryc127/hexo-theme-butterfly">ButterFly</a><br>花了我一个晚上才搭建好，可以说是把能踩的坑全都踩了一遍。<br>以后会在这个小破站不定期更新一些学到的新东西。<br>如果想联系我的话，我的邮箱是Cyderpunk2077@gmail.com。</p><h1 id="这里是我的QQ号"><a href="#这里是我的QQ号" class="headerlink" title="这里是我的QQ号"></a>这里是我的QQ号</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowQQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String Ciphertext = <span class="string">&quot;1235689&quot;</span>;</span><br><span class="line">String QQ = <span class="string">&quot;&quot;</span> +</span><br><span class="line">Ciphertext.charAt(<span class="number">0</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">3</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">5</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">4</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">2</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">5</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">3</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">1</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">6</span>) +</span><br><span class="line">Ciphertext.charAt(<span class="number">4</span>);</span><br><span class="line">System.out.println(QQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
